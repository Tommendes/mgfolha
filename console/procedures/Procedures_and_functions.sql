/*
SQLyog Professional v12.12 (64 bit)
MySQL - 10.4.8-MariaDB : Database - mysql
*********************************************************************
*/

/*!40101 SET NAMES utf8 */;

/*!40101 SET SQL_MODE=''*/;

/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
CREATE DATABASE /*!32312 IF NOT EXISTS*/`mysql` /*!40100 DEFAULT CHARACTER SET latin1 */;

USE `mysql`;

/*Table structure for table `proc` */

DROP TABLE IF EXISTS `proc`;

CREATE TABLE if not exists `proc` (
  `db` char(64) CHARACTER SET utf8 COLLATE utf8_bin NOT NULL DEFAULT '',
  `name` char(64) NOT NULL DEFAULT '',
  `type` enum('FUNCTION','PROCEDURE','PACKAGE','PACKAGE BODY') NOT NULL,
  `specific_name` char(64) NOT NULL DEFAULT '',
  `language` enum('SQL') NOT NULL DEFAULT 'SQL',
  `sql_data_access` enum('CONTAINS_SQL','NO_SQL','READS_SQL_DATA','MODIFIES_SQL_DATA') NOT NULL DEFAULT 'CONTAINS_SQL',
  `is_deterministic` enum('YES','NO') NOT NULL DEFAULT 'NO',
  `security_type` enum('INVOKER','DEFINER') NOT NULL DEFAULT 'DEFINER',
  `param_list` blob NOT NULL,
  `returns` longblob NOT NULL,
  `body` longblob NOT NULL,
  `definer` char(141) CHARACTER SET utf8 COLLATE utf8_bin NOT NULL DEFAULT '',
  `created` timestamp NOT NULL DEFAULT current_timestamp() ON UPDATE current_timestamp(),
  `modified` timestamp NOT NULL DEFAULT '0000-00-00 00:00:00',
  `sql_mode` set('REAL_AS_FLOAT','PIPES_AS_CONCAT','ANSI_QUOTES','IGNORE_SPACE','IGNORE_BAD_TABLE_OPTIONS','ONLY_FULL_GROUP_BY','NO_UNSIGNED_SUBTRACTION','NO_DIR_IN_CREATE','POSTGRESQL','ORACLE','MSSQL','DB2','MAXDB','NO_KEY_OPTIONS','NO_TABLE_OPTIONS','NO_FIELD_OPTIONS','MYSQL323','MYSQL40','ANSI','NO_AUTO_VALUE_ON_ZERO','NO_BACKSLASH_ESCAPES','STRICT_TRANS_TABLES','STRICT_ALL_TABLES','NO_ZERO_IN_DATE','NO_ZERO_DATE','INVALID_DATES','ERROR_FOR_DIVISION_BY_ZERO','TRADITIONAL','NO_AUTO_CREATE_USER','HIGH_NOT_PRECEDENCE','NO_ENGINE_SUBSTITUTION','PAD_CHAR_TO_FULL_LENGTH','EMPTY_STRING_IS_NULL','SIMULTANEOUS_ASSIGNMENT') NOT NULL DEFAULT '',
  `comment` text CHARACTER SET utf8 COLLATE utf8_bin NOT NULL,
  `character_set_client` char(32) CHARACTER SET utf8 COLLATE utf8_bin DEFAULT NULL,
  `collation_connection` char(32) CHARACTER SET utf8 COLLATE utf8_bin DEFAULT NULL,
  `db_collation` char(32) CHARACTER SET utf8 COLLATE utf8_bin DEFAULT NULL,
  `body_utf8` longblob DEFAULT NULL,
  `aggregate` enum('NONE','GROUP') NOT NULL DEFAULT 'NONE',
  PRIMARY KEY (`db`,`name`,`type`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8 COMMENT='Stored Procedures';

/*Data for the table `proc` */

insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_major','getEventoSistema','FUNCTION','getEventoSistema','SQL','CONTAINS_SQL','NO','DEFINER','v_dominio VARCHAR(255),v_evento TEXT, \n	v_classevento VARCHAR(255), v_tabela_bd VARCHAR(255), v_id_registro INT(11), v_id_user INT(11)','int(11)','BEGIN\n		DECLARE id_evento INT(11);\n		DECLARE ip, geo_td, geo_ln VARCHAR(255);\n		SELECT er.ip,er.geo_lt,er.geo_ln INTO ip, geo_td, geo_ln FROM eventos er WHERE er.id_user = v_id_user ORDER BY er.id DESC LIMIT 1;\n		-- SET id_evento = (SELECT MAX(id) FROM eventos);\n		INSERT INTO megasses_folha.eventos (\n			id,slug,STATUS,dominio,evento,classevento,tabela_bd,id_registro,\n			ip,geo_lt,geo_ln,id_user,username,data_registro,created_at,updated_at\n		) VALUES (\n			null,SHA(CONCAT(UNIX_TIMESTAMP(NOW()),v_dominio,v_evento,v_classevento)),10,v_dominio,v_evento,v_classevento,v_tabela_bd,v_id_registro,\n			ip, geo_td, geo_ln,\n			v_id_user,(SELECT username FROM megasses_folha.user WHERE id = v_id_user),FROM_UNIXTIME(NOW()),UNIX_TIMESTAMP(NOW()),UNIX_TIMESTAMP(NOW())\n		);\n		return (SELECT MAX(id) FROM eventos);\n	END','root@localhost','2019-06-13 10:02:47','2019-06-13 10:02:47','NO_AUTO_VALUE_ON_ZERO','Auxilia no registro de um evento de sistema','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN\n		DECLARE id_evento INT(11);\n		DECLARE ip, geo_td, geo_ln VARCHAR(255);\n		SELECT er.ip,er.geo_lt,er.geo_ln INTO ip, geo_td, geo_ln FROM eventos er WHERE er.id_user = v_id_user ORDER BY er.id DESC LIMIT 1;\n		-- SET id_evento = (SELECT MAX(id) FROM eventos);\n		INSERT INTO megasses_folha.eventos (\n			id,slug,STATUS,dominio,evento,classevento,tabela_bd,id_registro,\n			ip,geo_lt,geo_ln,id_user,username,data_registro,created_at,updated_at\n		) VALUES (\n			null,SHA(CONCAT(UNIX_TIMESTAMP(NOW()),v_dominio,v_evento,v_classevento)),10,v_dominio,v_evento,v_classevento,v_tabela_bd,v_id_registro,\n			ip, geo_td, geo_ln,\n			v_id_user,(SELECT username FROM megasses_folha.user WHERE id = v_id_user),FROM_UNIXTIME(NOW()),UNIX_TIMESTAMP(NOW()),UNIX_TIMESTAMP(NOW())\n		);\n		return (SELECT MAX(id) FROM eventos);\n	END','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_major','getDFPcc','FUNCTION','getDFPcc','SQL','CONTAINS_SQL','NO','DEFINER','v_dominio VARCHAR(255),v_ano VARCHAR(4),v_mes VARCHAR(2),\n	v_parcela VARCHAR(3),v_id_cad_servidor VARCHAR(255)','int(11)','BEGIN\n    DECLARE v_id_cad_pccs INT(11);    \n	SELECT fin_sfuncional.id_cad_pccs\n	FROM fin_sfuncional\n	WHERE fin_sfuncional.dominio = v_dominio AND fin_sfuncional.ano = v_ano \n	AND fin_sfuncional.mes = v_mes AND fin_sfuncional.parcela = v_parcela \n	AND fin_sfuncional.id_cad_servidores = v_id_cad_servidor\n	INTO v_id_cad_pccs;\n    RETURN v_id_cad_pccs;\n    END','root@localhost','2019-06-13 10:02:47','2019-06-13 10:02:47','NO_AUTO_VALUE_ON_ZERO','','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN\n    DECLARE v_id_cad_pccs INT(11);    \n	SELECT fin_sfuncional.id_cad_pccs\n	FROM fin_sfuncional\n	WHERE fin_sfuncional.dominio = v_dominio AND fin_sfuncional.ano = v_ano \n	AND fin_sfuncional.mes = v_mes AND fin_sfuncional.parcela = v_parcela \n	AND fin_sfuncional.id_cad_servidores = v_id_cad_servidor\n	INTO v_id_cad_pccs;\n    RETURN v_id_cad_pccs;\n    END','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_major','getFinRubricaPrazo','FUNCTION','getFinRubricaPrazo','SQL','CONTAINS_SQL','NO','DEFINER','prazo int, prazot int','int(11)','BEGIN\n	declare prazo_final int(3); -- prazo a retornar\n	if prazot = prazo then\n		set prazo_final = prazo;\n	elseIF prazot > prazo THEN\n		SET prazo_final = prazo + 1;\n	end if;\n	return prazo_final;\n    END','root@localhost','2019-06-13 10:02:47','2019-06-13 10:02:47','NO_AUTO_VALUE_ON_ZERO','Retorna o prazo inicial baseado nos prazos inicial e final passados','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN\n	declare prazo_final int(3); -- prazo a retornar\n	if prazot = prazo then\n		set prazo_final = prazo;\n	elseIF prazot > prazo THEN\n		SET prazo_final = prazo + 1;\n	end if;\n	return prazo_final;\n    END','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_major','getFinRubricaPrazoT','FUNCTION','getFinRubricaPrazoT','SQL','CONTAINS_SQL','NO','DEFINER','prazo int, prazot int','int(11)','BEGIN\n	declare prazo_final int(3); -- prazo a retornar\n	if (prazot = prazo) && ((prazot = \'999\') || (prazot = \'1\')) then\n		set prazo_final = prazot;\n	elseIF prazot > prazo THEN\n		SET prazo_final = prazo + 1;\n	end if;\n	return prazo_final;\n    END','root@localhost','2019-06-13 10:02:47','2019-06-13 10:02:47','NO_AUTO_VALUE_ON_ZERO','Retorna o prazo final baseado nos prazos inicial e final passados','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN\n	declare prazo_final int(3); -- prazo a retornar\n	if (prazot = prazo) && ((prazot = \'999\') || (prazot = \'1\')) then\n		set prazo_final = prazot;\n	elseIF prazot > prazo THEN\n		SET prazo_final = prazo + 1;\n	end if;\n	return prazo_final;\n    END','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_major','getIdVinculo','FUNCTION','getIdVinculo','SQL','CONTAINS_SQL','YES','DEFINER','v_dominio VARCHAR(255),v_id_vinculo INT','int(11)','BEGIN\n	DECLARE r_id_vinculo INT;\n	IF (v_id_vinculo < 4) THEN\n		SET r_id_vinculo = (SELECT id FROM fin_eventos WHERE dominio = v_dominio AND id_evento = \'001\');\n	ELSEIF (v_id_vinculo BETWEEN 4 AND 5) THEN\n		SET r_id_vinculo = (SELECT id FROM fin_eventos WHERE dominio = v_dominio AND id_evento = \'003\');\n	ELSEIF (v_id_vinculo = 6) THEN \n		SET r_id_vinculo = (SELECT id FROM fin_eventos WHERE dominio = v_dominio AND id_evento = \'002\');\n	ELSE \n		SET r_id_vinculo = 0;\n	END IF;\n	RETURN r_id_vinculo;\n    END','root@localhost','2019-06-13 10:02:47','2019-06-13 10:02:47','NO_AUTO_VALUE_ON_ZERO','Retorna o id_fin_eventos baseado em cad_sfuncional.id_vinculo','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN\n	DECLARE r_id_vinculo INT;\n	IF (v_id_vinculo < 4) THEN\n		SET r_id_vinculo = (SELECT id FROM fin_eventos WHERE dominio = v_dominio AND id_evento = \'001\');\n	ELSEIF (v_id_vinculo BETWEEN 4 AND 5) THEN\n		SET r_id_vinculo = (SELECT id FROM fin_eventos WHERE dominio = v_dominio AND id_evento = \'003\');\n	ELSEIF (v_id_vinculo = 6) THEN \n		SET r_id_vinculo = (SELECT id FROM fin_eventos WHERE dominio = v_dominio AND id_evento = \'002\');\n	ELSE \n		SET r_id_vinculo = 0;\n	END IF;\n	RETURN r_id_vinculo;\n    END','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_major','getSFalecimento','FUNCTION','getSFalecimento','SQL','CONTAINS_SQL','NO','DEFINER','v_id_cad_servidores INT','int(11)','BEGIN	\n	declare quant int;\n	SELECT COUNT(*)\n		FROM `cad_smovimentacao` \n		WHERE (`id_cad_servidores`=v_id_cad_servidores) \n		AND ((`codigo_afastamento`=\'S2\') OR (`codigo_afastamento`=\'S3\')) into quant;\n	return quant;\n    END','root@localhost','2019-06-13 10:02:47','2019-06-13 10:02:47','NO_AUTO_VALUE_ON_ZERO','Retorna um model caso o servidor esteja falecido ou null caso não esteja','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN	\n	declare quant int;\n	SELECT COUNT(*)\n		FROM `cad_smovimentacao` \n		WHERE (`id_cad_servidores`=v_id_cad_servidores) \n		AND ((`codigo_afastamento`=\'S2\') OR (`codigo_afastamento`=\'S3\')) into quant;\n	return quant;\n    END','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_major','getCodAfastamento','FUNCTION','getCodAfastamento','SQL','CONTAINS_SQL','YES','DEFINER','v VARCHAR(2)','varchar(500) CHARSET latin1','BEGIN\n	DECLARE RETORNO VARCHAR(500);\n	SET RETORNO = CASE v\n		WHEN \'Q1\' THEN \'Q1 - AFASTAMENTO TEMPORÁRIO POR MOTIVO DE LICENÇA-MATERNIDADE (120 DIAS)\'\n		WHEN \'X\' THEN \'X - LICENÇA SEM VENCIMENTOS\'\n		WHEN \'P1\' THEN \'P1 - AFASTAMENTO TEMPORÁRIO POR MOTIVO DE DOENÇA, POR PERÍODO SUPERIOR A 15 DIAS\'\n		WHEN \'H\' THEN \'H  - RESCISÃO, COM JUSTA CAUSA, POR INICIATIVA DO EMPREGADOR\'\n		WHEN \'I1\' THEN \'I1 - RESCISÃO SEM JUSTA CAUSA, POR INICIATIVA DO EMPREGADOR, INCLUSIVE RESCISÃO ANTECIPADA DO CONTRATO A TERMO\'\n		WHEN \'I2\' THEN \'I2 - RESCISÃO POR CULPA RECÍPROCA OU FORÇA MAIOR\'\n		WHEN \'I3\' THEN \'I3 - RESCISÃO POR TÉRMINO DO CONTRATO A TERMO\'\n		WHEN \'I4\' THEN \'I4 - RESCISÃO SEM JUSTA CAUSA DO CONTRATO DE TRABALHO DO EMPREGADO DOMÉSTICO, POR INICIATIVA DO EMPREGADOR\'\n		WHEN \'J\' THEN \'J  - RESCISÃO DO CONTRATO DE TRABALHO POR INICIATIVA DO EMPREGADO\'\n		WHEN \'K\' THEN \'K  - RESCISÃO A PEDIDO DO EMPREGADO OU POR INICIATIVA DO EMPREGADOR, COM JUSTA CAUSA, NO CASO DE EMPREGADO NÃO OPTANTE, COM MENOS DE UM ANO DE SERVIÇO\'\n		WHEN \'L\' THEN \'L  - OUTROS MOTIVOS DE RESCISÃO DO CONTRATO DE TRABALHO\'\n		WHEN \'S2\' THEN \'S2 - FALECIMENTO\'\n		WHEN \'S3\' THEN \'S3 - FALECIMENTO MOTIVADO POR ACIDENTE DE TRABALHO\'\n		WHEN \'U1\' THEN \'U1 - APOSENTADORIA\'\n		WHEN \'U3\' THEN \'U3 - APOSENTADORIA POR INVALIDEZ\' \n		ELSE NULL END;\n	RETURN RETORNO;\n    END','root@localhost','2019-06-13 10:02:47','2019-06-13 10:02:47','NO_AUTO_VALUE_ON_ZERO','','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN\n	DECLARE RETORNO VARCHAR(500);\n	SET RETORNO = CASE v\n		WHEN \'Q1\' THEN \'Q1 - AFASTAMENTO TEMPORÁRIO POR MOTIVO DE LICENÇA-MATERNIDADE (120 DIAS)\'\n		WHEN \'X\' THEN \'X - LICENÇA SEM VENCIMENTOS\'\n		WHEN \'P1\' THEN \'P1 - AFASTAMENTO TEMPORÁRIO POR MOTIVO DE DOENÇA, POR PERÍODO SUPERIOR A 15 DIAS\'\n		WHEN \'H\' THEN \'H  - RESCISÃO, COM JUSTA CAUSA, POR INICIATIVA DO EMPREGADOR\'\n		WHEN \'I1\' THEN \'I1 - RESCISÃO SEM JUSTA CAUSA, POR INICIATIVA DO EMPREGADOR, INCLUSIVE RESCISÃO ANTECIPADA DO CONTRATO A TERMO\'\n		WHEN \'I2\' THEN \'I2 - RESCISÃO POR CULPA RECÍPROCA OU FORÇA MAIOR\'\n		WHEN \'I3\' THEN \'I3 - RESCISÃO POR TÉRMINO DO CONTRATO A TERMO\'\n		WHEN \'I4\' THEN \'I4 - RESCISÃO SEM JUSTA CAUSA DO CONTRATO DE TRABALHO DO EMPREGADO DOMÉSTICO, POR INICIATIVA DO EMPREGADOR\'\n		WHEN \'J\' THEN \'J  - RESCISÃO DO CONTRATO DE TRABALHO POR INICIATIVA DO EMPREGADO\'\n		WHEN \'K\' THEN \'K  - RESCISÃO A PEDIDO DO EMPREGADO OU POR INICIATIVA DO EMPREGADOR, COM JUSTA CAUSA, NO CASO DE EMPREGADO NÃO OPTANTE, COM MENOS DE UM ANO DE SERVIÇO\'\n		WHEN \'L\' THEN \'L  - OUTROS MOTIVOS DE RESCISÃO DO CONTRATO DE TRABALHO\'\n		WHEN \'S2\' THEN \'S2 - FALECIMENTO\'\n		WHEN \'S3\' THEN \'S3 - FALECIMENTO MOTIVADO POR ACIDENTE DE TRABALHO\'\n		WHEN \'U1\' THEN \'U1 - APOSENTADORIA\'\n		WHEN \'U3\' THEN \'U3 - APOSENTADORIA POR INVALIDEZ\' \n		ELSE NULL END;\n	RETURN RETORNO;\n    END','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_desenvolvimento','get_eventos_base','PROCEDURE','get_eventos_base','SQL','CONTAINS_SQL','NO','DEFINER','v_dominio varchar(255), v_id_fin_evento int, out r_id_fin_eventosbase int','','BEGIN\n	select fin_eventosbase.`id_fin_eventosbase` into r_id_fin_eventosbase from fin_eventosbase where fin_eventosbase.`id_fin_eventos` order by fin_eventosbase.`id_fin_eventosbase`;\n    END','root@localhost','2019-06-19 16:52:06','2019-06-19 16:52:06','NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION','Retorna a base de calculo de um evento','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN\n	select fin_eventosbase.`id_fin_eventosbase` into r_id_fin_eventosbase from fin_eventosbase where fin_eventosbase.`id_fin_eventos` order by fin_eventosbase.`id_fin_eventosbase`;\n    END','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_desenvolvimento','getFinEventosPercentual','FUNCTION','getFinEventosPercentual','SQL','CONTAINS_SQL','NO','DEFINER','v_dominio varchar(255), v_id_fin_eventos int','decimal(11,2)','BEGIN\n	declare r_percentual decimal(11,2);\n	SELECT fin_eventospercentual.percentual\n		into r_percentual FROM fin_eventospercentual \n		WHERE fin_eventospercentual.id_fin_eventos = v_id_fin_eventos\n		AND fin_eventospercentual.dominio = v_dominio \n		ORDER BY STR_TO_DATE(fin_eventospercentual.data, \'%d/%m/%Y\') DESC LIMIT 1;\n	RETURN r_percentual;\n    END','root@localhost','2019-06-19 17:24:46','2019-06-19 17:24:46','NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION','Retorna o percentual do evento','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN\n	declare r_percentual decimal(11,2);\n	SELECT fin_eventospercentual.percentual\n		into r_percentual FROM fin_eventospercentual \n		WHERE fin_eventospercentual.id_fin_eventos = v_id_fin_eventos\n		AND fin_eventospercentual.dominio = v_dominio \n		ORDER BY STR_TO_DATE(fin_eventospercentual.data, \'%d/%m/%Y\') DESC LIMIT 1;\n	RETURN r_percentual;\n    END','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_desenvolvimento','getFinRubricasEvtValor','FUNCTION','getFinRubricasEvtValor','SQL','CONTAINS_SQL','NO','DEFINER','v_dominio VARCHAR(255),v_ano VARCHAR(4),v_mes VARCHAR(2),v_parcela VARCHAR(3),v_id_fin_eventos INT,v_id_cad_servidores INT','decimal(11,2)','BEGIN\n	declare r_valor decimal(11,2);\n	SELECT fin_rubricas.valor into r_valor FROM fin_rubricas WHERE fin_rubricas.dominio = v_dominio AND \n		fin_rubricas.ano = v_ano AND fin_rubricas.mes = v_mes \n		AND fin_rubricas.parcela = v_parcela AND fin_rubricas.id_fin_eventos = v_id_fin_eventos\n		AND fin_rubricas.id_cad_servidores = v_id_cad_servidores;\n	if (NOT r_valor > 0) or (r_valor is null) then\n		set r_valor = 0;\n	end if;\n	return r_valor;\n    END','root@localhost','2019-06-20 10:53:48','2019-06-20 10:53:48','NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION','Retorna o valor da rúbrica de um servidor, evento e folha','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN\n	declare r_valor decimal(11,2);\n	SELECT fin_rubricas.valor into r_valor FROM fin_rubricas WHERE fin_rubricas.dominio = v_dominio AND \n		fin_rubricas.ano = v_ano AND fin_rubricas.mes = v_mes \n		AND fin_rubricas.parcela = v_parcela AND fin_rubricas.id_fin_eventos = v_id_fin_eventos\n		AND fin_rubricas.id_cad_servidores = v_id_cad_servidores;\n	if (NOT r_valor > 0) or (r_valor is null) then\n		set r_valor = 0;\n	end if;\n	return r_valor;\n    END','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_desenvolvimento','fin_folha_eventos_consignados','PROCEDURE','fin_folha_eventos_consignados','SQL','CONTAINS_SQL','NO','DEFINER','v_id_user INT(11),v_dominio VARCHAR(255),v_ano VARCHAR(4),v_mes VARCHAR(2),v_parcela VARCHAR(3), v_id_cad_servidores INT','','BEGIN\n	DECLARE done INT DEFAULT FALSE;\n	DECLARE r_id_fin_rubricas,r_id_cad_servidores,r_id_fin_eventos,r_prazo,r_prazot,r_id_evento INT(11);\n	DECLARE r_slug,r_referencia,r_valor_base,r_valor,r_valor_patronal,\n			r_valor_maternidade,r_desconto,r_percentual VARCHAR(255);	 \n	-- obter referências\n	DECLARE cur1Referencias CURSOR FOR  \n		SELECT fin_rubricas.id_cad_servidores,fin_rubricas.id_fin_eventos,\n			fin_rubricas.referencia,fin_rubricas.valor_base,fin_rubricas.valor,fin_rubricas.valor_patronal,\n			fin_rubricas.valor_maternidade,fin_rubricas.desconto,fin_rubricas.percentual,\n			fin_rubricas.prazo + 1,fin_rubricas.prazot \n			FROM fin_rubricas\n			/*buscar a folha de informação*/\n			JOIN fin_parametros ON fin_parametros.ano_informacao = fin_rubricas.ano\n			AND fin_parametros.mes_informacao = fin_rubricas.mes AND fin_parametros.parcela_informacao = fin_rubricas.parcela\n			AND fin_parametros.dominio = fin_rubricas.dominio\n			JOIN fin_eventos ON fin_eventos.id = fin_rubricas.id_fin_eventos\n			JOIN fin_sfuncional ON fin_parametros.ano_informacao = fin_sfuncional.ano\n			AND fin_parametros.mes_informacao = fin_sfuncional.mes AND fin_parametros.parcela_informacao = fin_sfuncional.parcela\n			AND fin_rubricas.dominio = fin_sfuncional.dominio and fin_sfuncional.id_cad_servidores = fin_rubricas.id_cad_servidores\n			WHERE fin_rubricas.dominio = v_dominio AND fin_parametros.ano = v_ano \n			AND fin_parametros.mes = v_mes AND fin_parametros.parcela = v_parcela\n			AND fin_rubricas.prazot > fin_rubricas.prazo AND fin_eventos.consignado = 1 AND fin_rubricas.valor > 0\n			AND fin_sfuncional.situacao = 1 AND fin_sfuncional.situacaofuncional >= 1\n			AND IF (v_id_cad_servidores > 0, fin_sfuncional.id_cad_servidores = v_id_cad_servidores, 1=1)\n			GROUP BY fin_rubricas.id_cad_servidores,fin_rubricas.id_fin_eventos,fin_parametros.ano,fin_parametros.mes,fin_parametros.parcela\n			ORDER BY fin_rubricas.id_cad_servidores,fin_eventos.tipo,fin_eventos.id_evento;\n	DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;\n	-- Retorna e armazena o último id da tabela fiin_rubricas\n	SET r_id_fin_rubricas = (SELECT MAX(id) FROM fin_rubricas);	\n	\n	-- Varre as referencias para localizar a correta e registrar o valor\n	OPEN cur1Referencias;\n	read_loop: LOOP\n		FETCH cur1Referencias INTO r_id_cad_servidores,r_id_fin_eventos,r_referencia,\n			r_valor_base,r_valor,r_valor_patronal,r_valor_maternidade,r_desconto,\n			r_percentual,r_prazo,r_prazot;\n		IF done THEN\n			LEAVE read_loop;\n		END IF;	\n		/*primeiro verifica se o servidor é falecido. 0 quer dizer que não foi encontrado afastamento S2 ou S3 para o servidor*/\n		if (SELECT getSFalecimento(r_id_cad_servidores) = 0) then\n			/*gera um slug*/\n			SET r_slug = SHA(CONCAT(UNIX_TIMESTAMP(NOW()),r_id_fin_rubricas));\n			/*depois seta o novo r_id_fin_rubricas*/\n			SET r_id_fin_rubricas = r_id_fin_rubricas + 1;	\n			/*para garantir a integridade da chave primária, efetua uma segunda verificação e geração de r_id_fin_rubricas, se necessário*/	\n			IF (SELECT id FROM fin_rubricas WHERE id = r_id_fin_rubricas) IS NOT NULL THEN\n				SET r_id_fin_rubricas = r_id_fin_rubricas + 1;\n			END IF;\n			SET r_id_evento = getEventoSistema(v_dominio,CONCAT(\'Inclusão da rúbrica parcelada id: \', r_id_fin_eventos),\'actionC\', \'fin_rubricas\', r_id_fin_rubricas, v_id_user);\n			IF (v_id_cad_servidores > 0) THEN		\n				DELETE FROM fin_rubricas WHERE dominio = v_dominio \n					AND ano = v_ano AND mes = v_mes AND parcela = v_parcela \n					AND id_fin_eventos = r_id_fin_eventos\n					AND id_cad_servidores = r_id_cad_servidores; \n			END IF;\n			INSERT INTO fin_rubricas(\n				id,slug,status,dominio,evento,created_at,updated_at,\n				id_cad_servidores,id_fin_eventos,ano,mes,parcela,\n				referencia,valor_base,valor,valor_patronal,\n				valor_maternidade,prazo,prazot,desconto,percentual\n			) VALUES (\n				r_id_fin_rubricas,r_slug,10,v_dominio,r_id_evento,UNIX_TIMESTAMP(NOW()),UNIX_TIMESTAMP(NOW()),\n				r_id_cad_servidores,r_id_fin_eventos,v_ano,v_mes,v_parcela,\n				r_referencia,r_valor_base,r_valor,r_valor_patronal,\n				r_valor_maternidade,r_prazo,r_prazot,r_desconto,r_percentual\n			);\n		end if;\n	END LOOP;\n	CLOSE cur1Referencias;\nEND','root@localhost','2019-06-20 11:35:34','2019-06-20 11:35:34','NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION','','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN\n	DECLARE done INT DEFAULT FALSE;\n	DECLARE r_id_fin_rubricas,r_id_cad_servidores,r_id_fin_eventos,r_prazo,r_prazot,r_id_evento INT(11);\n	DECLARE r_slug,r_referencia,r_valor_base,r_valor,r_valor_patronal,\n			r_valor_maternidade,r_desconto,r_percentual VARCHAR(255);	 \n	-- obter referências\n	DECLARE cur1Referencias CURSOR FOR  \n		SELECT fin_rubricas.id_cad_servidores,fin_rubricas.id_fin_eventos,\n			fin_rubricas.referencia,fin_rubricas.valor_base,fin_rubricas.valor,fin_rubricas.valor_patronal,\n			fin_rubricas.valor_maternidade,fin_rubricas.desconto,fin_rubricas.percentual,\n			fin_rubricas.prazo + 1,fin_rubricas.prazot \n			FROM fin_rubricas\n			/*buscar a folha de informação*/\n			JOIN fin_parametros ON fin_parametros.ano_informacao = fin_rubricas.ano\n			AND fin_parametros.mes_informacao = fin_rubricas.mes AND fin_parametros.parcela_informacao = fin_rubricas.parcela\n			AND fin_parametros.dominio = fin_rubricas.dominio\n			JOIN fin_eventos ON fin_eventos.id = fin_rubricas.id_fin_eventos\n			JOIN fin_sfuncional ON fin_parametros.ano_informacao = fin_sfuncional.ano\n			AND fin_parametros.mes_informacao = fin_sfuncional.mes AND fin_parametros.parcela_informacao = fin_sfuncional.parcela\n			AND fin_rubricas.dominio = fin_sfuncional.dominio and fin_sfuncional.id_cad_servidores = fin_rubricas.id_cad_servidores\n			WHERE fin_rubricas.dominio = v_dominio AND fin_parametros.ano = v_ano \n			AND fin_parametros.mes = v_mes AND fin_parametros.parcela = v_parcela\n			AND fin_rubricas.prazot > fin_rubricas.prazo AND fin_eventos.consignado = 1 AND fin_rubricas.valor > 0\n			AND fin_sfuncional.situacao = 1 AND fin_sfuncional.situacaofuncional >= 1\n			AND IF (v_id_cad_servidores > 0, fin_sfuncional.id_cad_servidores = v_id_cad_servidores, 1=1)\n			GROUP BY fin_rubricas.id_cad_servidores,fin_rubricas.id_fin_eventos,fin_parametros.ano,fin_parametros.mes,fin_parametros.parcela\n			ORDER BY fin_rubricas.id_cad_servidores,fin_eventos.tipo,fin_eventos.id_evento;\n	DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;\n	-- Retorna e armazena o último id da tabela fiin_rubricas\n	SET r_id_fin_rubricas = (SELECT MAX(id) FROM fin_rubricas);	\n	\n	-- Varre as referencias para localizar a correta e registrar o valor\n	OPEN cur1Referencias;\n	read_loop: LOOP\n		FETCH cur1Referencias INTO r_id_cad_servidores,r_id_fin_eventos,r_referencia,\n			r_valor_base,r_valor,r_valor_patronal,r_valor_maternidade,r_desconto,\n			r_percentual,r_prazo,r_prazot;\n		IF done THEN\n			LEAVE read_loop;\n		END IF;	\n		/*primeiro verifica se o servidor é falecido. 0 quer dizer que não foi encontrado afastamento S2 ou S3 para o servidor*/\n		if (SELECT getSFalecimento(r_id_cad_servidores) = 0) then\n			/*gera um slug*/\n			SET r_slug = SHA(CONCAT(UNIX_TIMESTAMP(NOW()),r_id_fin_rubricas));\n			/*depois seta o novo r_id_fin_rubricas*/\n			SET r_id_fin_rubricas = r_id_fin_rubricas + 1;	\n			/*para garantir a integridade da chave primária, efetua uma segunda verificação e geração de r_id_fin_rubricas, se necessário*/	\n			IF (SELECT id FROM fin_rubricas WHERE id = r_id_fin_rubricas) IS NOT NULL THEN\n				SET r_id_fin_rubricas = r_id_fin_rubricas + 1;\n			END IF;\n			SET r_id_evento = getEventoSistema(v_dominio,CONCAT(\'Inclusão da rúbrica parcelada id: \', r_id_fin_eventos),\'actionC\', \'fin_rubricas\', r_id_fin_rubricas, v_id_user);\n			IF (v_id_cad_servidores > 0) THEN		\n				DELETE FROM fin_rubricas WHERE dominio = v_dominio \n					AND ano = v_ano AND mes = v_mes AND parcela = v_parcela \n					AND id_fin_eventos = r_id_fin_eventos\n					AND id_cad_servidores = r_id_cad_servidores; \n			END IF;\n			INSERT INTO fin_rubricas(\n				id,slug,status,dominio,evento,created_at,updated_at,\n				id_cad_servidores,id_fin_eventos,ano,mes,parcela,\n				referencia,valor_base,valor,valor_patronal,\n				valor_maternidade,prazo,prazot,desconto,percentual\n			) VALUES (\n				r_id_fin_rubricas,r_slug,10,v_dominio,r_id_evento,UNIX_TIMESTAMP(NOW()),UNIX_TIMESTAMP(NOW()),\n				r_id_cad_servidores,r_id_fin_eventos,v_ano,v_mes,v_parcela,\n				r_referencia,r_valor_base,r_valor,r_valor_patronal,\n				r_valor_maternidade,r_prazo,r_prazot,r_desconto,r_percentual\n			);\n		end if;\n	END LOOP;\n	CLOSE cur1Referencias;\nEND','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_desenvolvimento','fin_folha_eventos_recorrentes','PROCEDURE','fin_folha_eventos_recorrentes','SQL','CONTAINS_SQL','NO','DEFINER','v_id_user INT(11),v_dominio VARCHAR(255),v_ano VARCHAR(4),v_mes VARCHAR(2),v_parcela VARCHAR(3), v_id_cad_servidores INT','','BEGIN\n	DECLARE done INT DEFAULT FALSE;\n	DECLARE r_id_fin_rubricas,r_id_cad_servidores,r_id_fin_eventos,r_prazo,r_prazot,r_id_evento INT(11);\n	DECLARE r_slug,r_referencia,r_valor_base,r_valor,r_valor_patronal,\n			r_valor_maternidade,r_desconto,r_percentual VARCHAR(255);	 \n	-- obter referências\n	DECLARE cur1Referencias CURSOR FOR  \n		SELECT fin_rubricas.id_cad_servidores,fin_rubricas.id_fin_eventos,\n			fin_rubricas.referencia,fin_rubricas.valor_base,fin_rubricas.valor,fin_rubricas.valor_patronal,\n			fin_rubricas.valor_maternidade,fin_rubricas.desconto,fin_rubricas.percentual \n			FROM fin_rubricas\n			/*buscar a folha de informação*/\n			JOIN fin_parametros ON fin_parametros.ano_informacao = fin_rubricas.ano\n			AND fin_parametros.mes_informacao = fin_rubricas.mes AND fin_parametros.parcela_informacao = fin_rubricas.parcela\n			AND fin_parametros.dominio = fin_rubricas.dominio\n			JOIN fin_eventos ON fin_eventos.id = fin_rubricas.id_fin_eventos\n			JOIN fin_sfuncional ON fin_parametros.ano_informacao = fin_sfuncional.ano\n			AND fin_parametros.mes_informacao = fin_sfuncional.mes AND fin_parametros.parcela_informacao = fin_sfuncional.parcela\n			AND fin_rubricas.dominio = fin_sfuncional.dominio AND fin_sfuncional.id_cad_servidores = fin_rubricas.id_cad_servidores\n			WHERE fin_rubricas.dominio = v_dominio AND fin_parametros.ano = v_ano \n			AND fin_parametros.mes = v_mes AND fin_parametros.parcela = v_parcela			\n			AND fin_eventos.ev_root != 1 AND fin_eventos.fixo = 1 AND fin_rubricas.prazot = fin_rubricas.prazo \n			AND fin_rubricas.prazot IN (1,999) and fin_rubricas.valor > 0 \n			AND fin_sfuncional.situacao = 1 AND fin_sfuncional.situacaofuncional >= 1\n			AND IF (v_id_cad_servidores > 0, fin_sfuncional.id_cad_servidores = v_id_cad_servidores, 1=1)\n			GROUP BY fin_rubricas.id_cad_servidores,fin_rubricas.id_fin_eventos,fin_parametros.ano,fin_parametros.mes,fin_parametros.parcela\n			ORDER BY fin_rubricas.id_cad_servidores,fin_eventos.tipo,fin_eventos.id_evento;\n	DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;\n	-- Retorna e armazena o último id da tabela fiin_rubricas\n	SET r_id_fin_rubricas = (SELECT MAX(id) FROM fin_rubricas);	\n	\n	-- Varre as referencias para localizar a correta e registrar o valor\n	OPEN cur1Referencias;\n	read_loop: LOOP\n		FETCH cur1Referencias INTO r_id_cad_servidores,r_id_fin_eventos,r_referencia,\n			r_valor_base,r_valor,r_valor_patronal,r_valor_maternidade,r_desconto,r_percentual;\n		IF done THEN\n			LEAVE read_loop;\n		END IF;	\n		/*primeiro gera um slug*/\n		SET r_slug = SHA(CONCAT(UNIX_TIMESTAMP(NOW()),r_id_fin_rubricas));\n		/*depois seta o novo r_id_fin_rubricas*/\n		SET r_id_fin_rubricas = r_id_fin_rubricas + 1;	\n		/*para garantir a integridade da chave primária, efetua uma segunda verificação e geração de r_id_fin_rubricas, se necessário*/	\n		IF (SELECT id FROM fin_rubricas WHERE id = r_id_fin_rubricas) IS NOT NULL THEN\n			SET r_id_fin_rubricas = r_id_fin_rubricas + 1;\n		END IF;\n		SET r_id_evento = getEventoSistema(v_dominio,CONCAT(\'Inclusão da rúbrica recorrente id: \', r_id_fin_eventos),\'actionC\', \'fin_rubricas\', r_id_fin_rubricas, v_id_user);\n		SET r_valor_base = 0, r_valor = 0, r_valor_patronal = 0, r_valor_maternidade = 0, r_desconto = 0, r_prazo = 1, r_prazot = 1;\n		IF (v_id_cad_servidores > 0) THEN		\n			DELETE FROM fin_rubricas WHERE dominio = v_dominio \n				AND ano = v_ano AND mes = v_mes AND parcela = v_parcela \n				and id_fin_eventos = r_id_fin_eventos\n				and id_cad_servidores = r_id_cad_servidores; \n		END IF;\n		INSERT INTO fin_rubricas(\n			id,slug,`status`,dominio,evento,created_at,updated_at,\n			id_cad_servidores,id_fin_eventos,ano,mes,parcela,\n			referencia,valor_base,valor,valor_patronal,\n			valor_maternidade,prazo,prazot,desconto,percentual\n		) VALUES (\n			r_id_fin_rubricas,r_slug,10,v_dominio,r_id_evento,UNIX_TIMESTAMP(NOW()),UNIX_TIMESTAMP(NOW()),\n			r_id_cad_servidores,r_id_fin_eventos,v_ano,v_mes,v_parcela,\n			r_referencia,r_valor_base,r_valor,r_valor_patronal,\n			r_valor_maternidade,r_prazo,r_prazot,r_desconto,r_percentual\n		);\n	END LOOP;\n	CLOSE cur1Referencias;\nEND','root@localhost','2019-06-20 11:34:56','2019-06-20 11:34:56','NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION','','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN\n	DECLARE done INT DEFAULT FALSE;\n	DECLARE r_id_fin_rubricas,r_id_cad_servidores,r_id_fin_eventos,r_prazo,r_prazot,r_id_evento INT(11);\n	DECLARE r_slug,r_referencia,r_valor_base,r_valor,r_valor_patronal,\n			r_valor_maternidade,r_desconto,r_percentual VARCHAR(255);	 \n	-- obter referências\n	DECLARE cur1Referencias CURSOR FOR  \n		SELECT fin_rubricas.id_cad_servidores,fin_rubricas.id_fin_eventos,\n			fin_rubricas.referencia,fin_rubricas.valor_base,fin_rubricas.valor,fin_rubricas.valor_patronal,\n			fin_rubricas.valor_maternidade,fin_rubricas.desconto,fin_rubricas.percentual \n			FROM fin_rubricas\n			/*buscar a folha de informação*/\n			JOIN fin_parametros ON fin_parametros.ano_informacao = fin_rubricas.ano\n			AND fin_parametros.mes_informacao = fin_rubricas.mes AND fin_parametros.parcela_informacao = fin_rubricas.parcela\n			AND fin_parametros.dominio = fin_rubricas.dominio\n			JOIN fin_eventos ON fin_eventos.id = fin_rubricas.id_fin_eventos\n			JOIN fin_sfuncional ON fin_parametros.ano_informacao = fin_sfuncional.ano\n			AND fin_parametros.mes_informacao = fin_sfuncional.mes AND fin_parametros.parcela_informacao = fin_sfuncional.parcela\n			AND fin_rubricas.dominio = fin_sfuncional.dominio AND fin_sfuncional.id_cad_servidores = fin_rubricas.id_cad_servidores\n			WHERE fin_rubricas.dominio = v_dominio AND fin_parametros.ano = v_ano \n			AND fin_parametros.mes = v_mes AND fin_parametros.parcela = v_parcela			\n			AND fin_eventos.ev_root != 1 AND fin_eventos.fixo = 1 AND fin_rubricas.prazot = fin_rubricas.prazo \n			AND fin_rubricas.prazot IN (1,999) and fin_rubricas.valor > 0 \n			AND fin_sfuncional.situacao = 1 AND fin_sfuncional.situacaofuncional >= 1\n			AND IF (v_id_cad_servidores > 0, fin_sfuncional.id_cad_servidores = v_id_cad_servidores, 1=1)\n			GROUP BY fin_rubricas.id_cad_servidores,fin_rubricas.id_fin_eventos,fin_parametros.ano,fin_parametros.mes,fin_parametros.parcela\n			ORDER BY fin_rubricas.id_cad_servidores,fin_eventos.tipo,fin_eventos.id_evento;\n	DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;\n	-- Retorna e armazena o último id da tabela fiin_rubricas\n	SET r_id_fin_rubricas = (SELECT MAX(id) FROM fin_rubricas);	\n	\n	-- Varre as referencias para localizar a correta e registrar o valor\n	OPEN cur1Referencias;\n	read_loop: LOOP\n		FETCH cur1Referencias INTO r_id_cad_servidores,r_id_fin_eventos,r_referencia,\n			r_valor_base,r_valor,r_valor_patronal,r_valor_maternidade,r_desconto,r_percentual;\n		IF done THEN\n			LEAVE read_loop;\n		END IF;	\n		/*primeiro gera um slug*/\n		SET r_slug = SHA(CONCAT(UNIX_TIMESTAMP(NOW()),r_id_fin_rubricas));\n		/*depois seta o novo r_id_fin_rubricas*/\n		SET r_id_fin_rubricas = r_id_fin_rubricas + 1;	\n		/*para garantir a integridade da chave primária, efetua uma segunda verificação e geração de r_id_fin_rubricas, se necessário*/	\n		IF (SELECT id FROM fin_rubricas WHERE id = r_id_fin_rubricas) IS NOT NULL THEN\n			SET r_id_fin_rubricas = r_id_fin_rubricas + 1;\n		END IF;\n		SET r_id_evento = getEventoSistema(v_dominio,CONCAT(\'Inclusão da rúbrica recorrente id: \', r_id_fin_eventos),\'actionC\', \'fin_rubricas\', r_id_fin_rubricas, v_id_user);\n		SET r_valor_base = 0, r_valor = 0, r_valor_patronal = 0, r_valor_maternidade = 0, r_desconto = 0, r_prazo = 1, r_prazot = 1;\n		IF (v_id_cad_servidores > 0) THEN		\n			DELETE FROM fin_rubricas WHERE dominio = v_dominio \n				AND ano = v_ano AND mes = v_mes AND parcela = v_parcela \n				and id_fin_eventos = r_id_fin_eventos\n				and id_cad_servidores = r_id_cad_servidores; \n		END IF;\n		INSERT INTO fin_rubricas(\n			id,slug,`status`,dominio,evento,created_at,updated_at,\n			id_cad_servidores,id_fin_eventos,ano,mes,parcela,\n			referencia,valor_base,valor,valor_patronal,\n			valor_maternidade,prazo,prazot,desconto,percentual\n		) VALUES (\n			r_id_fin_rubricas,r_slug,10,v_dominio,r_id_evento,UNIX_TIMESTAMP(NOW()),UNIX_TIMESTAMP(NOW()),\n			r_id_cad_servidores,r_id_fin_eventos,v_ano,v_mes,v_parcela,\n			r_referencia,r_valor_base,r_valor,r_valor_patronal,\n			r_valor_maternidade,r_prazo,r_prazot,r_desconto,r_percentual\n		);\n	END LOOP;\n	CLOSE cur1Referencias;\nEND','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_desenvolvimento','fin_folha_eventos_enios','PROCEDURE','fin_folha_eventos_enios','SQL','CONTAINS_SQL','NO','DEFINER','v_id_user INT(11),v_dominio VARCHAR(255),v_ano VARCHAR(4),v_mes VARCHAR(2),v_parcela VARCHAR(3), v_id_cad_servidores int','','BEGIN\n	DECLARE r_id_fin_rubricas,r_id_cad_servidores,r_id_fin_eventos,r_prazo,r_prazot,\n		r_anos, r_meses, r_dias, r_enio, r_enios, r_id_evento, contator INT;\n	DECLARE r_slug,r_referencia VARCHAR(255);	\n	DECLARE r_valor_base,r_valor,r_valor_patronal,\n			r_valor_maternidade,r_desconto,r_percentual,\n			r_base_percentual decimal(11,2);\n	-- obter servidores\n	DECLARE curlServidores CURSOR FOR  \n		SELECT fin_sfuncional.id_cad_servidores FROM fin_sfuncional\n			WHERE fin_sfuncional.enio > 0 AND fin_sfuncional.dominio = v_dominio AND fin_sfuncional.ano = v_ano \n			AND fin_sfuncional.mes = v_mes AND fin_sfuncional.parcela = v_parcela\n			AND fin_sfuncional.situacao = 1 AND fin_sfuncional.situacaofuncional >= 1 \n			AND if (v_id_cad_servidores > 0, fin_sfuncional.id_cad_servidores = v_id_cad_servidores, 1=1)\n			GROUP BY fin_sfuncional.id_cad_servidores\n			ORDER BY fin_sfuncional.id_cad_servidores;\n	-- obter base\n	DECLARE curlBase CURSOR FOR  \n		SELECT fin_eventosbase.id_fin_eventosbase\n			FROM fin_eventosbase \n			WHERE fin_eventosbase.id_fin_eventos = r_id_fin_eventos  AND fin_eventosbase.dominio = v_dominio \n			ORDER BY fin_eventosbase.id_fin_eventosbase;	\n	-- seta o contator\n	set contator = 1;\n	-- Retorna e armazena o último id da tabela fiin_rubricas\n	SET r_id_fin_rubricas = (SELECT MAX(id) FROM fin_rubricas);\n	-- Varre os servidores\n	OPEN curlServidores;\n	BEGIN\n		DECLARE exit_flag INT DEFAULT 0;\n		DECLARE CONTINUE HANDLER FOR SQLSTATE \'02000\' SET exit_flag = 1;\n		servidoresLoop: LOOP\n			FETCH curlServidores INTO r_id_cad_servidores;\n			IF exit_flag THEN LEAVE servidoresLoop; END IF;\n			-- gera um slug\n			SET r_slug = SHA(CONCAT(UNIX_TIMESTAMP(NOW()),contator, r_id_cad_servidores));\n			set contator = contator + 1;\n			-- Retorna e armazena os dados do tempo de carteira\n			CALL get_tempo_carteira(v_dominio,v_ano,v_mes,v_parcela,r_id_cad_servidores, \n				r_anos, r_meses, r_dias, r_enio, r_enios, r_id_fin_eventos);\n			OPEN curlBase;\n			BEGIN\n				DECLARE exit_flag_base INT DEFAULT 0;	\n				DECLARE id_fin_eventobase INT DEFAULT 0; \n				DECLARE CONTINUE HANDLER FOR SQLSTATE \'02000\' SET exit_flag_base = 1;\n				SET r_valor = 0;\n				baseLoop: LOOP\n					FETCH curlBase INTO id_fin_eventobase;\n					IF exit_flag_base THEN LEAVE baseLoop; END IF;\n					SET r_valor = r_valor + getFinRubricasEvtValor(v_dominio,v_ano,v_mes,v_parcela,id_fin_eventobase,r_id_cad_servidores);\n					set r_valor = r_valor * (r_enio * 0.01) * r_enios;\n				END LOOP;\n			end;\n			CLOSE curlBase;			\n			set r_referencia = lpad(r_enios, 2, \'0\');\n			/*para garantir a integridade da chave primária, efetua uma segunda verificação e geração de r_id_fin_rubricas, se necessário*/	\n			IF (SELECT id FROM fin_rubricas WHERE id = r_id_fin_rubricas) IS NOT NULL THEN\n				SET r_id_fin_rubricas = r_id_fin_rubricas + 1;\n			END IF;\n			-- gera um evento\n			SET r_id_evento = getEventoSistema(v_dominio,CONCAT(\'Inclusão da rúbrica de enio id: \', r_id_fin_eventos),\'actionC\', \'fin_rubricas\', r_id_fin_rubricas, v_id_user);\n			SET r_valor_base = 0, r_valor_patronal = 0, r_valor_maternidade = 0, r_desconto = 0, r_percentual = 0, r_prazo = 1, r_prazot = 1;			\n			IF (v_id_cad_servidores > 0) THEN		\n				DELETE FROM fin_rubricas WHERE dominio = v_dominio \n					AND ano = v_ano AND mes = v_mes AND parcela = v_parcela \n					AND id_fin_eventos = r_id_fin_eventos\n					AND id_cad_servidores = r_id_cad_servidores; \n			END IF;\n			INSERT INTO fin_rubricas(\n				id,slug,STATUS,dominio,evento,created_at,updated_at,\n				id_cad_servidores,id_fin_eventos,ano,mes,parcela,\n				referencia,valor_base,valor,valor_patronal,\n				valor_maternidade,prazo,prazot,desconto,percentual\n			) VALUES (\n				r_id_fin_rubricas,r_slug,10,v_dominio,r_id_evento,UNIX_TIMESTAMP(NOW()),UNIX_TIMESTAMP(NOW()),\n				r_id_cad_servidores,r_id_fin_eventos,v_ano,v_mes,v_parcela,\n				r_referencia,r_valor_base,r_valor,r_valor_patronal,\n				r_valor_maternidade,r_prazo,r_prazot,r_desconto,r_percentual\n			);\n			/*select r_id_fin_rubricas,r_slug,10,v_dominio,r_id_evento,UNIX_TIMESTAMP(NOW()),UNIX_TIMESTAMP(NOW()),\n				r_id_cad_servidores,r_id_fin_eventos,v_ano,v_mes,v_parcela,\n				r_referencia,r_valor_base,r_valor,r_valor_patronal,\n				r_valor_maternidade,r_prazo,r_prazot,r_desconto,r_percentual;*/\n		END LOOP;\n	end;\n	CLOSE curlServidores;\n    END','root@localhost','2019-06-20 12:33:29','2019-06-20 12:33:29','NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION','Lança os ênios dos servidores','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN\n	DECLARE r_id_fin_rubricas,r_id_cad_servidores,r_id_fin_eventos,r_prazo,r_prazot,\n		r_anos, r_meses, r_dias, r_enio, r_enios, r_id_evento, contator INT;\n	DECLARE r_slug,r_referencia VARCHAR(255);	\n	DECLARE r_valor_base,r_valor,r_valor_patronal,\n			r_valor_maternidade,r_desconto,r_percentual,\n			r_base_percentual decimal(11,2);\n	-- obter servidores\n	DECLARE curlServidores CURSOR FOR  \n		SELECT fin_sfuncional.id_cad_servidores FROM fin_sfuncional\n			WHERE fin_sfuncional.enio > 0 AND fin_sfuncional.dominio = v_dominio AND fin_sfuncional.ano = v_ano \n			AND fin_sfuncional.mes = v_mes AND fin_sfuncional.parcela = v_parcela\n			AND fin_sfuncional.situacao = 1 AND fin_sfuncional.situacaofuncional >= 1 \n			AND if (v_id_cad_servidores > 0, fin_sfuncional.id_cad_servidores = v_id_cad_servidores, 1=1)\n			GROUP BY fin_sfuncional.id_cad_servidores\n			ORDER BY fin_sfuncional.id_cad_servidores;\n	-- obter base\n	DECLARE curlBase CURSOR FOR  \n		SELECT fin_eventosbase.id_fin_eventosbase\n			FROM fin_eventosbase \n			WHERE fin_eventosbase.id_fin_eventos = r_id_fin_eventos  AND fin_eventosbase.dominio = v_dominio \n			ORDER BY fin_eventosbase.id_fin_eventosbase;	\n	-- seta o contator\n	set contator = 1;\n	-- Retorna e armazena o último id da tabela fiin_rubricas\n	SET r_id_fin_rubricas = (SELECT MAX(id) FROM fin_rubricas);\n	-- Varre os servidores\n	OPEN curlServidores;\n	BEGIN\n		DECLARE exit_flag INT DEFAULT 0;\n		DECLARE CONTINUE HANDLER FOR SQLSTATE \'02000\' SET exit_flag = 1;\n		servidoresLoop: LOOP\n			FETCH curlServidores INTO r_id_cad_servidores;\n			IF exit_flag THEN LEAVE servidoresLoop; END IF;\n			-- gera um slug\n			SET r_slug = SHA(CONCAT(UNIX_TIMESTAMP(NOW()),contator, r_id_cad_servidores));\n			set contator = contator + 1;\n			-- Retorna e armazena os dados do tempo de carteira\n			CALL get_tempo_carteira(v_dominio,v_ano,v_mes,v_parcela,r_id_cad_servidores, \n				r_anos, r_meses, r_dias, r_enio, r_enios, r_id_fin_eventos);\n			OPEN curlBase;\n			BEGIN\n				DECLARE exit_flag_base INT DEFAULT 0;	\n				DECLARE id_fin_eventobase INT DEFAULT 0; \n				DECLARE CONTINUE HANDLER FOR SQLSTATE \'02000\' SET exit_flag_base = 1;\n				SET r_valor = 0;\n				baseLoop: LOOP\n					FETCH curlBase INTO id_fin_eventobase;\n					IF exit_flag_base THEN LEAVE baseLoop; END IF;\n					SET r_valor = r_valor + getFinRubricasEvtValor(v_dominio,v_ano,v_mes,v_parcela,id_fin_eventobase,r_id_cad_servidores);\n					set r_valor = r_valor * (r_enio * 0.01) * r_enios;\n				END LOOP;\n			end;\n			CLOSE curlBase;			\n			set r_referencia = lpad(r_enios, 2, \'0\');\n			/*para garantir a integridade da chave primária, efetua uma segunda verificação e geração de r_id_fin_rubricas, se necessário*/	\n			IF (SELECT id FROM fin_rubricas WHERE id = r_id_fin_rubricas) IS NOT NULL THEN\n				SET r_id_fin_rubricas = r_id_fin_rubricas + 1;\n			END IF;\n			-- gera um evento\n			SET r_id_evento = getEventoSistema(v_dominio,CONCAT(\'Inclusão da rúbrica de enio id: \', r_id_fin_eventos),\'actionC\', \'fin_rubricas\', r_id_fin_rubricas, v_id_user);\n			SET r_valor_base = 0, r_valor_patronal = 0, r_valor_maternidade = 0, r_desconto = 0, r_percentual = 0, r_prazo = 1, r_prazot = 1;			\n			IF (v_id_cad_servidores > 0) THEN		\n				DELETE FROM fin_rubricas WHERE dominio = v_dominio \n					AND ano = v_ano AND mes = v_mes AND parcela = v_parcela \n					AND id_fin_eventos = r_id_fin_eventos\n					AND id_cad_servidores = r_id_cad_servidores; \n			END IF;\n			INSERT INTO fin_rubricas(\n				id,slug,STATUS,dominio,evento,created_at,updated_at,\n				id_cad_servidores,id_fin_eventos,ano,mes,parcela,\n				referencia,valor_base,valor,valor_patronal,\n				valor_maternidade,prazo,prazot,desconto,percentual\n			) VALUES (\n				r_id_fin_rubricas,r_slug,10,v_dominio,r_id_evento,UNIX_TIMESTAMP(NOW()),UNIX_TIMESTAMP(NOW()),\n				r_id_cad_servidores,r_id_fin_eventos,v_ano,v_mes,v_parcela,\n				r_referencia,r_valor_base,r_valor,r_valor_patronal,\n				r_valor_maternidade,r_prazo,r_prazot,r_desconto,r_percentual\n			);\n			/*select r_id_fin_rubricas,r_slug,10,v_dominio,r_id_evento,UNIX_TIMESTAMP(NOW()),UNIX_TIMESTAMP(NOW()),\n				r_id_cad_servidores,r_id_fin_eventos,v_ano,v_mes,v_parcela,\n				r_referencia,r_valor_base,r_valor,r_valor_patronal,\n				r_valor_maternidade,r_prazo,r_prazot,r_desconto,r_percentual;*/\n		END LOOP;\n	end;\n	CLOSE curlServidores;\n    END','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_desenvolvimento','fin_folha_eventos_parcelados','PROCEDURE','fin_folha_eventos_parcelados','SQL','CONTAINS_SQL','NO','DEFINER','v_id_user INT(11),v_dominio VARCHAR(255),v_ano VARCHAR(4),v_mes VARCHAR(2),v_parcela VARCHAR(3), v_id_cad_servidores INT','','BEGIN\n	DECLARE done INT DEFAULT FALSE;\n	DECLARE r_id_fin_rubricas,r_id_cad_servidores,r_id_fin_eventos,r_prazo,r_prazot,r_id_evento INT(11);\n	DECLARE r_slug,r_referencia,r_valor_base,r_valor,r_valor_patronal,\n			r_valor_maternidade,r_desconto,r_percentual VARCHAR(255);	 \n	-- obter referências\n	DECLARE cur1Referencias CURSOR FOR  \n		SELECT fin_rubricas.id_cad_servidores,fin_rubricas.id_fin_eventos,\n			fin_rubricas.referencia,fin_rubricas.valor_base,fin_rubricas.valor,fin_rubricas.valor_patronal,\n			fin_rubricas.valor_maternidade,fin_rubricas.desconto,fin_rubricas.percentual,\n			fin_rubricas.prazo + 1,fin_rubricas.prazot \n			FROM fin_rubricas\n			/*buscar a folha de informação*/\n			JOIN fin_parametros ON fin_parametros.ano_informacao = fin_rubricas.ano\n			AND fin_parametros.mes_informacao = fin_rubricas.mes AND fin_parametros.parcela_informacao = fin_rubricas.parcela\n			AND fin_parametros.dominio = fin_rubricas.dominio\n			JOIN fin_eventos ON fin_eventos.id = fin_rubricas.id_fin_eventos\n			JOIN fin_sfuncional ON fin_parametros.ano_informacao = fin_sfuncional.ano\n			AND fin_parametros.mes_informacao = fin_sfuncional.mes AND fin_parametros.parcela_informacao = fin_sfuncional.parcela\n			AND fin_rubricas.dominio = fin_sfuncional.dominio AND fin_sfuncional.id_cad_servidores = fin_rubricas.id_cad_servidores\n			WHERE fin_rubricas.dominio = v_dominio AND fin_parametros.ano = v_ano \n			AND fin_parametros.mes = v_mes AND fin_parametros.parcela = v_parcela\n			AND fin_rubricas.prazot > fin_rubricas.prazo AND fin_eventos.consignado = 0 AND fin_rubricas.valor > 0\n			AND fin_sfuncional.situacao = 1 AND fin_sfuncional.situacaofuncional >= 1\n			AND if (v_id_cad_servidores > 0, fin_sfuncional.id_cad_servidores = v_id_cad_servidores, 1=1)\n			GROUP BY fin_rubricas.id_cad_servidores,fin_rubricas.id_fin_eventos,fin_parametros.ano,fin_parametros.mes,fin_parametros.parcela\n			ORDER BY fin_rubricas.id_cad_servidores,fin_eventos.tipo,fin_eventos.id_evento;\n	DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;\n	-- Retorna e armazena o último id da tabela fiin_rubricas\n	SET r_id_fin_rubricas = (SELECT MAX(id) FROM fin_rubricas);	\n	\n	-- Varre as referencias para localizar a correta e registrar o valor\n	OPEN cur1Referencias;\n	read_loop: LOOP\n		FETCH cur1Referencias INTO r_id_cad_servidores,r_id_fin_eventos,r_referencia,\n			r_valor_base,r_valor,r_valor_patronal,r_valor_maternidade,r_desconto,\n			r_percentual,r_prazo,r_prazot;\n		IF done THEN\n			LEAVE read_loop;\n		END IF;	\n		/*primeiro gera um slug*/\n		SET r_slug = SHA(CONCAT(UNIX_TIMESTAMP(NOW()),r_id_fin_rubricas));\n		/*depois seta o novo r_id_fin_rubricas*/\n		SET r_id_fin_rubricas = r_id_fin_rubricas + 1;	\n		/*para garantir a integridade da chave primária, efetua uma segunda verificação e geração de r_id_fin_rubricas, se necessário*/	\n		IF (SELECT id FROM fin_rubricas WHERE id = r_id_fin_rubricas) IS NOT NULL THEN\n			SET r_id_fin_rubricas = r_id_fin_rubricas + 1;\n		END IF;\n		SET r_id_evento = getEventoSistema(v_dominio,CONCAT(\'Inclusão da rúbrica parcelada id: \', r_id_fin_eventos),\'actionC\', \'fin_rubricas\', r_id_fin_rubricas, v_id_user);\n		IF (v_id_cad_servidores > 0) THEN		\n			DELETE FROM fin_rubricas WHERE dominio = v_dominio \n				AND ano = v_ano AND mes = v_mes AND parcela = v_parcela \n				AND id_fin_eventos = r_id_fin_eventos\n				AND id_cad_servidores = r_id_cad_servidores; \n		END IF;\n		INSERT INTO fin_rubricas(\n			id,slug,`status`,dominio,evento,created_at,updated_at,\n			id_cad_servidores,id_fin_eventos,ano,mes,parcela,\n			referencia,valor_base,valor,valor_patronal,\n			valor_maternidade,prazo,prazot,desconto,percentual\n		) VALUES (\n			r_id_fin_rubricas,r_slug,10,v_dominio,r_id_evento,UNIX_TIMESTAMP(NOW()),UNIX_TIMESTAMP(NOW()),\n			r_id_cad_servidores,r_id_fin_eventos,v_ano,v_mes,v_parcela,\n			r_referencia,r_valor_base,r_valor,r_valor_patronal,\n			r_valor_maternidade,r_prazo,r_prazot,r_desconto,r_percentual\n		);\n	END LOOP;\n	CLOSE cur1Referencias;\nEND','root@localhost','2019-06-20 11:35:16','2019-06-20 11:35:16','NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION','','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN\n	DECLARE done INT DEFAULT FALSE;\n	DECLARE r_id_fin_rubricas,r_id_cad_servidores,r_id_fin_eventos,r_prazo,r_prazot,r_id_evento INT(11);\n	DECLARE r_slug,r_referencia,r_valor_base,r_valor,r_valor_patronal,\n			r_valor_maternidade,r_desconto,r_percentual VARCHAR(255);	 \n	-- obter referências\n	DECLARE cur1Referencias CURSOR FOR  \n		SELECT fin_rubricas.id_cad_servidores,fin_rubricas.id_fin_eventos,\n			fin_rubricas.referencia,fin_rubricas.valor_base,fin_rubricas.valor,fin_rubricas.valor_patronal,\n			fin_rubricas.valor_maternidade,fin_rubricas.desconto,fin_rubricas.percentual,\n			fin_rubricas.prazo + 1,fin_rubricas.prazot \n			FROM fin_rubricas\n			/*buscar a folha de informação*/\n			JOIN fin_parametros ON fin_parametros.ano_informacao = fin_rubricas.ano\n			AND fin_parametros.mes_informacao = fin_rubricas.mes AND fin_parametros.parcela_informacao = fin_rubricas.parcela\n			AND fin_parametros.dominio = fin_rubricas.dominio\n			JOIN fin_eventos ON fin_eventos.id = fin_rubricas.id_fin_eventos\n			JOIN fin_sfuncional ON fin_parametros.ano_informacao = fin_sfuncional.ano\n			AND fin_parametros.mes_informacao = fin_sfuncional.mes AND fin_parametros.parcela_informacao = fin_sfuncional.parcela\n			AND fin_rubricas.dominio = fin_sfuncional.dominio AND fin_sfuncional.id_cad_servidores = fin_rubricas.id_cad_servidores\n			WHERE fin_rubricas.dominio = v_dominio AND fin_parametros.ano = v_ano \n			AND fin_parametros.mes = v_mes AND fin_parametros.parcela = v_parcela\n			AND fin_rubricas.prazot > fin_rubricas.prazo AND fin_eventos.consignado = 0 AND fin_rubricas.valor > 0\n			AND fin_sfuncional.situacao = 1 AND fin_sfuncional.situacaofuncional >= 1\n			AND if (v_id_cad_servidores > 0, fin_sfuncional.id_cad_servidores = v_id_cad_servidores, 1=1)\n			GROUP BY fin_rubricas.id_cad_servidores,fin_rubricas.id_fin_eventos,fin_parametros.ano,fin_parametros.mes,fin_parametros.parcela\n			ORDER BY fin_rubricas.id_cad_servidores,fin_eventos.tipo,fin_eventos.id_evento;\n	DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;\n	-- Retorna e armazena o último id da tabela fiin_rubricas\n	SET r_id_fin_rubricas = (SELECT MAX(id) FROM fin_rubricas);	\n	\n	-- Varre as referencias para localizar a correta e registrar o valor\n	OPEN cur1Referencias;\n	read_loop: LOOP\n		FETCH cur1Referencias INTO r_id_cad_servidores,r_id_fin_eventos,r_referencia,\n			r_valor_base,r_valor,r_valor_patronal,r_valor_maternidade,r_desconto,\n			r_percentual,r_prazo,r_prazot;\n		IF done THEN\n			LEAVE read_loop;\n		END IF;	\n		/*primeiro gera um slug*/\n		SET r_slug = SHA(CONCAT(UNIX_TIMESTAMP(NOW()),r_id_fin_rubricas));\n		/*depois seta o novo r_id_fin_rubricas*/\n		SET r_id_fin_rubricas = r_id_fin_rubricas + 1;	\n		/*para garantir a integridade da chave primária, efetua uma segunda verificação e geração de r_id_fin_rubricas, se necessário*/	\n		IF (SELECT id FROM fin_rubricas WHERE id = r_id_fin_rubricas) IS NOT NULL THEN\n			SET r_id_fin_rubricas = r_id_fin_rubricas + 1;\n		END IF;\n		SET r_id_evento = getEventoSistema(v_dominio,CONCAT(\'Inclusão da rúbrica parcelada id: \', r_id_fin_eventos),\'actionC\', \'fin_rubricas\', r_id_fin_rubricas, v_id_user);\n		IF (v_id_cad_servidores > 0) THEN		\n			DELETE FROM fin_rubricas WHERE dominio = v_dominio \n				AND ano = v_ano AND mes = v_mes AND parcela = v_parcela \n				AND id_fin_eventos = r_id_fin_eventos\n				AND id_cad_servidores = r_id_cad_servidores; \n		END IF;\n		INSERT INTO fin_rubricas(\n			id,slug,`status`,dominio,evento,created_at,updated_at,\n			id_cad_servidores,id_fin_eventos,ano,mes,parcela,\n			referencia,valor_base,valor,valor_patronal,\n			valor_maternidade,prazo,prazot,desconto,percentual\n		) VALUES (\n			r_id_fin_rubricas,r_slug,10,v_dominio,r_id_evento,UNIX_TIMESTAMP(NOW()),UNIX_TIMESTAMP(NOW()),\n			r_id_cad_servidores,r_id_fin_eventos,v_ano,v_mes,v_parcela,\n			r_referencia,r_valor_base,r_valor,r_valor_patronal,\n			r_valor_maternidade,r_prazo,r_prazot,r_desconto,r_percentual\n		);\n	END LOOP;\n	CLOSE cur1Referencias;\nEND','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_desenvolvimento','getEventoSistema','FUNCTION','getEventoSistema','SQL','CONTAINS_SQL','NO','DEFINER','v_dominio VARCHAR(255),v_evento TEXT, \n	v_classevento VARCHAR(255), v_tabela_bd VARCHAR(255), v_id_registro INT(11), v_id_user INT(11)','int(11)','BEGIN\n		DECLARE id_evento INT(11);\n		DECLARE ip, geo_td, geo_ln VARCHAR(255);\n		SELECT er.ip,er.geo_lt,er.geo_ln INTO ip, geo_td, geo_ln FROM eventos er WHERE er.id_user = v_id_user ORDER BY er.id DESC LIMIT 1;\n		-- SET id_evento = (SELECT MAX(id) FROM eventos);\n		INSERT INTO eventos (\n			id,slug,STATUS,dominio,evento,classevento,tabela_bd,id_registro,\n			ip,geo_lt,geo_ln,id_user,username,data_registro,created_at,updated_at\n		) VALUES (\n			null,SHA(CONCAT(UNIX_TIMESTAMP(NOW()),v_dominio,v_evento,v_classevento)),10,v_dominio,v_evento,v_classevento,v_tabela_bd,v_id_registro,\n			ip, geo_td, geo_ln,\n			v_id_user,(SELECT username FROM mgfolha_folha.user WHERE id = v_id_user),FROM_UNIXTIME(NOW()),UNIX_TIMESTAMP(NOW()),UNIX_TIMESTAMP(NOW())\n		);\n		return (SELECT MAX(id) FROM eventos);\n	END','root@localhost','2019-06-18 08:06:09','2019-06-18 08:06:09','NO_AUTO_VALUE_ON_ZERO','Auxilia no registro de um evento de sistema','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN\n		DECLARE id_evento INT(11);\n		DECLARE ip, geo_td, geo_ln VARCHAR(255);\n		SELECT er.ip,er.geo_lt,er.geo_ln INTO ip, geo_td, geo_ln FROM eventos er WHERE er.id_user = v_id_user ORDER BY er.id DESC LIMIT 1;\n		-- SET id_evento = (SELECT MAX(id) FROM eventos);\n		INSERT INTO eventos (\n			id,slug,STATUS,dominio,evento,classevento,tabela_bd,id_registro,\n			ip,geo_lt,geo_ln,id_user,username,data_registro,created_at,updated_at\n		) VALUES (\n			null,SHA(CONCAT(UNIX_TIMESTAMP(NOW()),v_dominio,v_evento,v_classevento)),10,v_dominio,v_evento,v_classevento,v_tabela_bd,v_id_registro,\n			ip, geo_td, geo_ln,\n			v_id_user,(SELECT username FROM mgfolha_folha.user WHERE id = v_id_user),FROM_UNIXTIME(NOW()),UNIX_TIMESTAMP(NOW()),UNIX_TIMESTAMP(NOW())\n		);\n		return (SELECT MAX(id) FROM eventos);\n	END','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_desenvolvimento','getUseOfIdEvento','FUNCTION','getUseOfIdEvento','SQL','CONTAINS_SQL','NO','DEFINER','v_dominio varchar(255), v_id_fin_eventos char(4)','int(11)','BEGIN\n	declare r_quant int;\n	select count(id) into r_quant from fin_rubricas where dominio = v_dominio and id_fin_eventos = v_id_fin_eventos;\n	return r_quant;\n    END','root@localhost','2019-06-19 14:43:59','2019-06-19 14:43:59','NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION','Retorna o id_fin_evento','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN\n	declare r_quant int;\n	select count(id) into r_quant from fin_rubricas where dominio = v_dominio and id_fin_eventos = v_id_fin_eventos;\n	return r_quant;\n    END','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_desenvolvimento','get_tempo_carteira','PROCEDURE','get_tempo_carteira','SQL','CONTAINS_SQL','NO','DEFINER','in v_dominio VARCHAR(255),IN v_ano VARCHAR(4),IN v_mes VARCHAR(2),IN v_parcela VARCHAR(3),IN v_id_cad_servidor INT,\nout r_anos int, OUT r_meses INT, OUT r_dias INT, OUT r_enio INT, OUT r_enios INT, OUT r_id_fin_evento INT','','BEGIN\n	SELECT TIMESTAMPDIFF(YEAR, STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\'), LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) AS anos,\n		TIMESTAMPDIFF(MONTH, STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\') + INTERVAL TIMESTAMPDIFF(YEAR,  STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\'), LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) YEAR , LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) AS meses,\n		TIMESTAMPDIFF(DAY, STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\') + INTERVAL TIMESTAMPDIFF(MONTH,  STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\'), LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) MONTH , LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) + 1 AS dias,\n		fin_sfuncional.enio\n		into r_anos, r_meses, r_dias, r_enio\n		FROM cad_servidores \n		JOIN fin_sfuncional ON cad_servidores.id = fin_sfuncional.id_cad_servidores and \n			cad_servidores.dominio = fin_sfuncional.dominio\n		WHERE fin_sfuncional.dominio = v_dominio AND fin_sfuncional.ano = v_ano \n		AND fin_sfuncional.mes = v_mes AND fin_sfuncional.parcela = v_parcela \n		AND fin_sfuncional.id_cad_servidores = v_id_cad_servidor;\n	set r_id_fin_evento = CASE\n		WHEN r_enio = 1 THEN getIdEvento(v_dominio, 191)\n		WHEN r_enio = 3 THEN getIdEvento(v_dominio, 192)\n		WHEN r_enio = 5 THEN getIdEvento(v_dominio, 193)\n		WHEN r_enio = 10 THEN getIdEvento(v_dominio, 194)\n		else r_enio\n	END;\n	set r_enios = r_anos div r_enio;\n	-- SELECT r_anos anos, r_meses meses, r_dias dias, r_enio enio, r_enios enios, r_id_fin_evento id_evento;\n    END','root@localhost','2019-06-20 10:53:43','2019-06-20 10:53:43','NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION','Retona o tempo de carteira o enio, os enios e o id_fin_evento','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN\n	SELECT TIMESTAMPDIFF(YEAR, STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\'), LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) AS anos,\n		TIMESTAMPDIFF(MONTH, STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\') + INTERVAL TIMESTAMPDIFF(YEAR,  STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\'), LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) YEAR , LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) AS meses,\n		TIMESTAMPDIFF(DAY, STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\') + INTERVAL TIMESTAMPDIFF(MONTH,  STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\'), LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) MONTH , LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) + 1 AS dias,\n		fin_sfuncional.enio\n		into r_anos, r_meses, r_dias, r_enio\n		FROM cad_servidores \n		JOIN fin_sfuncional ON cad_servidores.id = fin_sfuncional.id_cad_servidores and \n			cad_servidores.dominio = fin_sfuncional.dominio\n		WHERE fin_sfuncional.dominio = v_dominio AND fin_sfuncional.ano = v_ano \n		AND fin_sfuncional.mes = v_mes AND fin_sfuncional.parcela = v_parcela \n		AND fin_sfuncional.id_cad_servidores = v_id_cad_servidor;\n	set r_id_fin_evento = CASE\n		WHEN r_enio = 1 THEN getIdEvento(v_dominio, 191)\n		WHEN r_enio = 3 THEN getIdEvento(v_dominio, 192)\n		WHEN r_enio = 5 THEN getIdEvento(v_dominio, 193)\n		WHEN r_enio = 10 THEN getIdEvento(v_dominio, 194)\n		else r_enio\n	END;\n	set r_enios = r_anos div r_enio;\n	-- SELECT r_anos anos, r_meses meses, r_dias dias, r_enio enio, r_enios enios, r_id_fin_evento id_evento;\n    END','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_desenvolvimento','getIdEvento','FUNCTION','getIdEvento','SQL','CONTAINS_SQL','NO','DEFINER','v_dominio varchar(255), v_id_evento char(4)','int(11)','BEGIN\n	declare r_id_fin_eventos int;\n	select id into r_id_fin_eventos from fin_eventos where dominio = v_dominio and id_evento = v_id_evento;\n	return r_id_fin_eventos;\n    END','root@localhost','2019-06-19 14:35:00','2019-06-19 14:35:00','NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION','Retorna o id_fin_evento','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN\n	declare r_id_fin_eventos int;\n	select id into r_id_fin_eventos from fin_eventos where dominio = v_dominio and id_evento = v_id_evento;\n	return r_id_fin_eventos;\n    END','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_major','getDiasPagarVctoBasico','FUNCTION','getDiasPagarVctoBasico','SQL','CONTAINS_SQL','YES','DEFINER','ics INT(11),ano_f CHAR(4),mes_f CHAR(2)','varchar(255) CHARSET latin1','BEGIN\n    DECLARE dias/*dias do período de cálculo*/\n    , dias_p/*CONSTANTE: dias antes de ir para previdência*/ INT(2);\n    DECLARE d_afastamento, d_limite/*data limite antes de ir para previdência*/\n    , d_admissao/*data de admissao*/\n    , d_retorno/*data do retorno*/\n    , udm0 /*último dia do mês anterior*/\n    , udm1 /*último dia do mês atual*/ DATE;\n    DECLARE codigo_afastamento VARCHAR(2);\n    DECLARE r VARCHAR(255);\n    -- dias de afastamento em que a autarquia paga antes de ir para previdência\n    SET dias_p = 15;\n    -- último dia do mês anterior\n    SET udm0 = LAST_DAY(DATE_SUB(CAST(CONCAT(ano_f,\'-\',mes_f,\'-01\') AS DATE), INTERVAL 1 MONTH));\n    -- último dia do mês atual\n    SET udm1 = LAST_DAY(CAST(CONCAT(ano_f,\'-\',mes_f,\'-01\') AS DATE));\n	SELECT STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\') AS d_admissao,	\n		STR_TO_DATE(cad_smovimentacao.d_afastamento, \'%d/%m/%Y\') AS d_afastamento,\n		STR_TO_DATE(cad_smovimentacao.d_retorno, \'%d/%m/%Y\') AS d_retorno,\n		cad_smovimentacao.codigo_afastamento AS codigo_afastamento\n		FROM cad_servidores\n		LEFT JOIN cad_smovimentacao ON cad_servidores.id = cad_smovimentacao.id_cad_servidores \n			AND cad_servidores.dominio = cad_smovimentacao.dominio\n		WHERE cad_servidores.id = ics\n		ORDER BY STR_TO_DATE(cad_smovimentacao.d_afastamento, \'%d/%m/%Y\') DESC\n		LIMIT 1 \n		INTO d_admissao, d_afastamento, d_retorno, codigo_afastamento;\n	IF codigo_afastamento = \'P1\' /*calculo dos dias em caso de afastamento temporário\n		por motivo de doença, por período superior à variável dias_p*/ THEN		\n		SET dias = DAY(d_afastamento) + dias_p;\n		SET d_limite = DATE_ADD(d_afastamento, INTERVAL dias_p DAY);\n		/*Se a data limite(afastamento) for posterior ou igual ao último dia do mês atual*/\n		IF d_limite >= udm1 THEN\n			/*dias a pagar é igual ao total de dias do mês atual pois \n			ou estourou o mês ou o final do prazo acaba no último dia*/\n			SET dias = DAY(udm1);\n			SET r = \'0\';\n		/*Se a data limite for anterior ao último dia do mês atual e o periodo for o mesmo*/\n		ELSEIF d_limite < udm1 AND \n		CONCAT(YEAR(d_limite),MONTH(d_limite)) = CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = DAY(d_limite);\n			SET r = \'1\';\n		/*Se a data limite for anterior ao último dia do mês atual e o periodo for outro*/\n		ELSEIF d_limite < udm1 AND \n		CONCAT(YEAR(d_limite),MONTH(d_limite)) != CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = 0;\n			SET r = \'2\';\n		END IF;\n		/*Adicionar os dias após o retorno à variável dias acima*/\n		/*Se a data de retorno for registrada e for no mês corrente(atual)*/\n		IF d_retorno IS NOT NULL \n		AND CONCAT(YEAR(d_retorno),MONTH(d_retorno)) = CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = dias + DATEDIFF(udm1,d_retorno);\n			SET r = \'3\';\n		ELSEIF d_retorno IS NOT NULL AND d_retorno < udm1 THEN\n			SET dias = DAY(udm1);\n			SET r = \'4\';\n		END IF;\n	ELSEIF codigo_afastamento = \'X\' /*calculo dos dias em caso de licença sem vencimento*/ THEN		\n		SET dias = DAY(d_afastamento);\n		SET d_limite = d_afastamento;\n		/*Se a data limite(afastamento) for posterior ou igual ao último dia do mês atual*/\n		IF d_limite >= udm1 THEN\n			/*dias a pagar é igual ao total de dias do mês atual pois \n			ou estourou o mês ou o final do prazo acaba no último dia*/\n			SET dias = DAY(udm1);\n			SET r = \'5\';\n		/*Se a data limite for anterior ao último dia do mês atual e o periodo for o mesmo*/\n		ELSEIF d_limite < udm1 AND \n		CONCAT(YEAR(d_limite),MONTH(d_limite)) = CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = DAY(d_limite);\n			SET r = \'6\';\n		/*Se a data limite for anterior ao último dia do mês atual e o periodo for outro*/\n		ELSEIF d_limite < udm1 AND \n		CONCAT(YEAR(d_limite),MONTH(d_limite)) != CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = 0;\n			SET r = \'7\';\n		END IF;\n		SET d_retorno = DATE_SUB(d_retorno, INTERVAL 1 DAY);\n		/*Adicionar os dias após o retorno à variável dias acima*/\n		/*Se a data de retorno for registrada e for no mês corrente(atual)*/\n		IF d_retorno IS NOT NULL \n		AND CONCAT(YEAR(d_retorno),MONTH(d_retorno)) = CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = dias + DATEDIFF(udm1,d_retorno);\n			SET r = \'8\';\n		ELSEIF d_retorno IS NOT NULL AND d_retorno < udm1 THEN\n			SET dias = DAY(udm1);\n			SET r = \'9\';\n		END IF;\n	ELSEIF codigo_afastamento = \'Q1\' /*calculo dos dias em caso de licença maternidade*/ THEN		\n		SET dias = DAY(d_afastamento);\n		SET d_limite = d_afastamento;\n		/*Se a data limite(afastamento) for posterior ao último dia do mês atual*/\n		IF d_limite > udm1 THEN\n			/*dias a pagar é igual ao total de dias do mês atual pois \n			a servidora ainda não saiu de licença*/\n			SET dias = DAY(udm1);\n			SET r = \'Q1:0\';\n		/*Se a data limite for anterior ao último dia do mês atual e o periodo for o mesmo*/\n		ELSEIF d_limite < udm1 AND \n		CONCAT(YEAR(d_limite),MONTH(d_limite)) = CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = DAY(d_limite) - 1;\n			SET r = \'Q1:1\';\n		/*Se a data limite for anterior ao último dia do mês atual e o periodo for outro*/\n		ELSEIF d_limite < udm1 AND \n		CONCAT(YEAR(d_limite),MONTH(d_limite)) != CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = 0;\n			SET r = \'Q1:2\';\n		END IF;\n		/*Adicionar os dias após o retorno à variável dias acima*/\n		/*Se a data de retorno for registrada e for no mês corrente(atual)*/\n		IF d_retorno IS NOT NULL \n		AND CONCAT(YEAR(d_retorno),MONTH(d_retorno)) = CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = dias + DATEDIFF(udm1,d_retorno);\n			SET r = \'Q1:3\';\n		/*Se a data de retorno é anterior ao primeiro dia do mês */\n		ELSEIF d_retorno IS NOT NULL AND d_retorno < ADDDATE(LAST_DAY(DATE_SUB(udm1, INTERVAL 1 MONTH)),1) THEN\n			SET dias = DAY(udm1);\n			SET r = \'Q1:4\';\n		END IF;\n	ELSEIF codigo_afastamento IS NOT NULL && codigo_afastamento != \'P1\'\n	 && codigo_afastamento != \'Q1\' && codigo_afastamento != \'X\' /*calculo dos dias em caso de demissão*/ THEN		\n		SET dias = DAY(d_afastamento);\n		SET d_limite = d_afastamento;\n		/*Se a data limite(afastamento) for posterior ou igual ao último dia do mês atual*/\n		IF d_limite > udm1 THEN\n			/*dias a pagar é igual ao total de dias do mês atual pois \n			pertence a outro período*/\n			SET dias = DAY(udm1);\n			SET r = \'Demiss0\';\n		/*Se a data limite for anterior ou igual ao último dia do mês atual e o periodo for o mesmo*/\n		ELSEIF d_limite <= udm1 AND \n		CONCAT(YEAR(d_limite),MONTH(d_limite)) = CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = DAY(d_limite);\n			SET r = \'Demiss1\';\n		/*Se a data limite for anterior ao último dia do mês atual e o periodo for outro*/\n		ELSEIF d_limite < udm1 AND \n		CONCAT(YEAR(d_limite),MONTH(d_limite)) != CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = 0;\n			SET r = \'Demiss2\';\n		END IF;\n	ELSEIF LAST_DAY(d_admissao) = udm1 THEN\n	/*calculo dos dias em caso de admissão no periodo informado*/\n		SET dias = DAY(udm1) - DAY(d_admissao) + 1;\n		SET r = \'10\';\n	ELSE\n	/*caso não atenda nenhuma das situações acima*/\n		SET dias = DAY(udm1);\n		SET r = \'11\';\n	END IF;\n	\nRETURN dias;-- concat(\'da: \',d_afastamento,\' > ca: \',codigo_afastamento,\' > dl: \',d_limite,\' > pos: \',r,\' > dias: \',dias);\nEND','root@localhost','2019-06-13 10:02:47','2019-06-13 10:02:47','NO_AUTO_VALUE_ON_ZERO','','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN\n    DECLARE dias/*dias do período de cálculo*/\n    , dias_p/*CONSTANTE: dias antes de ir para previdência*/ INT(2);\n    DECLARE d_afastamento, d_limite/*data limite antes de ir para previdência*/\n    , d_admissao/*data de admissao*/\n    , d_retorno/*data do retorno*/\n    , udm0 /*último dia do mês anterior*/\n    , udm1 /*último dia do mês atual*/ DATE;\n    DECLARE codigo_afastamento VARCHAR(2);\n    DECLARE r VARCHAR(255);\n    -- dias de afastamento em que a autarquia paga antes de ir para previdência\n    SET dias_p = 15;\n    -- último dia do mês anterior\n    SET udm0 = LAST_DAY(DATE_SUB(CAST(CONCAT(ano_f,\'-\',mes_f,\'-01\') AS DATE), INTERVAL 1 MONTH));\n    -- último dia do mês atual\n    SET udm1 = LAST_DAY(CAST(CONCAT(ano_f,\'-\',mes_f,\'-01\') AS DATE));\n	SELECT STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\') AS d_admissao,	\n		STR_TO_DATE(cad_smovimentacao.d_afastamento, \'%d/%m/%Y\') AS d_afastamento,\n		STR_TO_DATE(cad_smovimentacao.d_retorno, \'%d/%m/%Y\') AS d_retorno,\n		cad_smovimentacao.codigo_afastamento AS codigo_afastamento\n		FROM cad_servidores\n		LEFT JOIN cad_smovimentacao ON cad_servidores.id = cad_smovimentacao.id_cad_servidores \n			AND cad_servidores.dominio = cad_smovimentacao.dominio\n		WHERE cad_servidores.id = ics\n		ORDER BY STR_TO_DATE(cad_smovimentacao.d_afastamento, \'%d/%m/%Y\') DESC\n		LIMIT 1 \n		INTO d_admissao, d_afastamento, d_retorno, codigo_afastamento;\n	IF codigo_afastamento = \'P1\' /*calculo dos dias em caso de afastamento temporário\n		por motivo de doença, por período superior à variável dias_p*/ THEN		\n		SET dias = DAY(d_afastamento) + dias_p;\n		SET d_limite = DATE_ADD(d_afastamento, INTERVAL dias_p DAY);\n		/*Se a data limite(afastamento) for posterior ou igual ao último dia do mês atual*/\n		IF d_limite >= udm1 THEN\n			/*dias a pagar é igual ao total de dias do mês atual pois \n			ou estourou o mês ou o final do prazo acaba no último dia*/\n			SET dias = DAY(udm1);\n			SET r = \'0\';\n		/*Se a data limite for anterior ao último dia do mês atual e o periodo for o mesmo*/\n		ELSEIF d_limite < udm1 AND \n		CONCAT(YEAR(d_limite),MONTH(d_limite)) = CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = DAY(d_limite);\n			SET r = \'1\';\n		/*Se a data limite for anterior ao último dia do mês atual e o periodo for outro*/\n		ELSEIF d_limite < udm1 AND \n		CONCAT(YEAR(d_limite),MONTH(d_limite)) != CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = 0;\n			SET r = \'2\';\n		END IF;\n		/*Adicionar os dias após o retorno à variável dias acima*/\n		/*Se a data de retorno for registrada e for no mês corrente(atual)*/\n		IF d_retorno IS NOT NULL \n		AND CONCAT(YEAR(d_retorno),MONTH(d_retorno)) = CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = dias + DATEDIFF(udm1,d_retorno);\n			SET r = \'3\';\n		ELSEIF d_retorno IS NOT NULL AND d_retorno < udm1 THEN\n			SET dias = DAY(udm1);\n			SET r = \'4\';\n		END IF;\n	ELSEIF codigo_afastamento = \'X\' /*calculo dos dias em caso de licença sem vencimento*/ THEN		\n		SET dias = DAY(d_afastamento);\n		SET d_limite = d_afastamento;\n		/*Se a data limite(afastamento) for posterior ou igual ao último dia do mês atual*/\n		IF d_limite >= udm1 THEN\n			/*dias a pagar é igual ao total de dias do mês atual pois \n			ou estourou o mês ou o final do prazo acaba no último dia*/\n			SET dias = DAY(udm1);\n			SET r = \'5\';\n		/*Se a data limite for anterior ao último dia do mês atual e o periodo for o mesmo*/\n		ELSEIF d_limite < udm1 AND \n		CONCAT(YEAR(d_limite),MONTH(d_limite)) = CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = DAY(d_limite);\n			SET r = \'6\';\n		/*Se a data limite for anterior ao último dia do mês atual e o periodo for outro*/\n		ELSEIF d_limite < udm1 AND \n		CONCAT(YEAR(d_limite),MONTH(d_limite)) != CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = 0;\n			SET r = \'7\';\n		END IF;\n		SET d_retorno = DATE_SUB(d_retorno, INTERVAL 1 DAY);\n		/*Adicionar os dias após o retorno à variável dias acima*/\n		/*Se a data de retorno for registrada e for no mês corrente(atual)*/\n		IF d_retorno IS NOT NULL \n		AND CONCAT(YEAR(d_retorno),MONTH(d_retorno)) = CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = dias + DATEDIFF(udm1,d_retorno);\n			SET r = \'8\';\n		ELSEIF d_retorno IS NOT NULL AND d_retorno < udm1 THEN\n			SET dias = DAY(udm1);\n			SET r = \'9\';\n		END IF;\n	ELSEIF codigo_afastamento = \'Q1\' /*calculo dos dias em caso de licença maternidade*/ THEN		\n		SET dias = DAY(d_afastamento);\n		SET d_limite = d_afastamento;\n		/*Se a data limite(afastamento) for posterior ao último dia do mês atual*/\n		IF d_limite > udm1 THEN\n			/*dias a pagar é igual ao total de dias do mês atual pois \n			a servidora ainda não saiu de licença*/\n			SET dias = DAY(udm1);\n			SET r = \'Q1:0\';\n		/*Se a data limite for anterior ao último dia do mês atual e o periodo for o mesmo*/\n		ELSEIF d_limite < udm1 AND \n		CONCAT(YEAR(d_limite),MONTH(d_limite)) = CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = DAY(d_limite) - 1;\n			SET r = \'Q1:1\';\n		/*Se a data limite for anterior ao último dia do mês atual e o periodo for outro*/\n		ELSEIF d_limite < udm1 AND \n		CONCAT(YEAR(d_limite),MONTH(d_limite)) != CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = 0;\n			SET r = \'Q1:2\';\n		END IF;\n		/*Adicionar os dias após o retorno à variável dias acima*/\n		/*Se a data de retorno for registrada e for no mês corrente(atual)*/\n		IF d_retorno IS NOT NULL \n		AND CONCAT(YEAR(d_retorno),MONTH(d_retorno)) = CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = dias + DATEDIFF(udm1,d_retorno);\n			SET r = \'Q1:3\';\n		/*Se a data de retorno é anterior ao primeiro dia do mês */\n		ELSEIF d_retorno IS NOT NULL AND d_retorno < ADDDATE(LAST_DAY(DATE_SUB(udm1, INTERVAL 1 MONTH)),1) THEN\n			SET dias = DAY(udm1);\n			SET r = \'Q1:4\';\n		END IF;\n	ELSEIF codigo_afastamento IS NOT NULL && codigo_afastamento != \'P1\'\n	 && codigo_afastamento != \'Q1\' && codigo_afastamento != \'X\' /*calculo dos dias em caso de demissão*/ THEN		\n		SET dias = DAY(d_afastamento);\n		SET d_limite = d_afastamento;\n		/*Se a data limite(afastamento) for posterior ou igual ao último dia do mês atual*/\n		IF d_limite > udm1 THEN\n			/*dias a pagar é igual ao total de dias do mês atual pois \n			pertence a outro período*/\n			SET dias = DAY(udm1);\n			SET r = \'Demiss0\';\n		/*Se a data limite for anterior ou igual ao último dia do mês atual e o periodo for o mesmo*/\n		ELSEIF d_limite <= udm1 AND \n		CONCAT(YEAR(d_limite),MONTH(d_limite)) = CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = DAY(d_limite);\n			SET r = \'Demiss1\';\n		/*Se a data limite for anterior ao último dia do mês atual e o periodo for outro*/\n		ELSEIF d_limite < udm1 AND \n		CONCAT(YEAR(d_limite),MONTH(d_limite)) != CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = 0;\n			SET r = \'Demiss2\';\n		END IF;\n	ELSEIF LAST_DAY(d_admissao) = udm1 THEN\n	/*calculo dos dias em caso de admissão no periodo informado*/\n		SET dias = DAY(udm1) - DAY(d_admissao) + 1;\n		SET r = \'10\';\n	ELSE\n	/*caso não atenda nenhuma das situações acima*/\n		SET dias = DAY(udm1);\n		SET r = \'11\';\n	END IF;\n	\nRETURN dias;-- concat(\'da: \',d_afastamento,\' > ca: \',codigo_afastamento,\' > dl: \',d_limite,\' > pos: \',r,\' > dias: \',dias);\nEND','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_major','get_eventos_percentual','PROCEDURE','get_eventos_percentual','SQL','CONTAINS_SQL','NO','DEFINER','v_dominio VARCHAR(255),v_id_eventos INT','','BEGIN\n	SELECT id, slug, id_eventos_percentual, percentual, `data` FROM fin_eventospercentual WHERE id_fin_eventos = v_id_eventos AND dominio = v_dominio;\n    END','root@localhost','2019-06-13 10:02:47','2019-06-13 10:02:47','NO_AUTO_VALUE_ON_ZERO','','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN\n	SELECT id, slug, id_eventos_percentual, percentual, `data` FROM fin_eventospercentual WHERE id_fin_eventos = v_id_eventos AND dominio = v_dominio;\n    END','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_major','fin_folha_eventos','PROCEDURE','fin_folha_eventos','SQL','CONTAINS_SQL','NO','DEFINER','v_id_user INT(11), v_dominio VARCHAR(255),v_ano VARCHAR(4),v_mes VARCHAR(2),v_parcela VARCHAR(3)','','BEGIN \nDECLARE done INT DEFAULT FALSE; \nDECLARE v_id_cad_servidor INT; \nDECLARE cur1 CURSOR FOR \nSELECT fin_sfuncional.id_cad_servidores \n	FROM fin_sfuncional \n	JOIN cad_servidores ON cad_servidores.id = fin_sfuncional.id_cad_servidores \n	WHERE fin_sfuncional.dominio = v_dominio AND fin_sfuncional.ano = v_ano \n	AND fin_sfuncional.mes = v_mes AND fin_sfuncional.parcela = v_parcela AND fin_sfuncional.situacao = 1 \n	AND fin_sfuncional.situacaofuncional >= 1 AND (fin_sfuncional.id_pccs IS NOT NULL AND fin_sfuncional.id_pccs > 0) \n	AND fin_sfuncional.lanca_salario = 1\n	ORDER BY cad_servidores.id; \nDECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE; \nDELETE FROM fin_rubricas WHERE dominio = v_dominio \n	AND ano = v_ano AND mes = v_mes AND parcela = v_parcela; \nOPEN cur1; \nread_loop: LOOP FETCH cur1 INTO v_id_cad_servidor; \n	IF done THEN \n		LEAVE read_loop; \n	END IF; \n	-- Geração dos eventos básicos 2,3 e 40 (001,002,003) da folha\n	CALL fin_folha_ev_basico(v_id_user,v_dominio,v_ano,v_mes,v_parcela,v_id_cad_servidor); \nEND LOOP; \nCLOSE cur1; \n/**\nAs operações abaixo foram deslocadas para suas próprias chamadas dentro de main.php\nCALL fin_folha_eventos_recorrentes(v_id_user,v_dominio,v_ano,v_mes,v_parcela); \nCALL fin_folha_eventos_parcelados(v_id_user,v_dominio,v_ano,v_mes,v_parcela); \n*/\nEND','root@localhost','2019-06-13 10:02:47','2019-06-13 10:02:47','NO_AUTO_VALUE_ON_ZERO','','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN \nDECLARE done INT DEFAULT FALSE; \nDECLARE v_id_cad_servidor INT; \nDECLARE cur1 CURSOR FOR \nSELECT fin_sfuncional.id_cad_servidores \n	FROM fin_sfuncional \n	JOIN cad_servidores ON cad_servidores.id = fin_sfuncional.id_cad_servidores \n	WHERE fin_sfuncional.dominio = v_dominio AND fin_sfuncional.ano = v_ano \n	AND fin_sfuncional.mes = v_mes AND fin_sfuncional.parcela = v_parcela AND fin_sfuncional.situacao = 1 \n	AND fin_sfuncional.situacaofuncional >= 1 AND (fin_sfuncional.id_pccs IS NOT NULL AND fin_sfuncional.id_pccs > 0) \n	AND fin_sfuncional.lanca_salario = 1\n	ORDER BY cad_servidores.id; \nDECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE; \nDELETE FROM fin_rubricas WHERE dominio = v_dominio \n	AND ano = v_ano AND mes = v_mes AND parcela = v_parcela; \nOPEN cur1; \nread_loop: LOOP FETCH cur1 INTO v_id_cad_servidor; \n	IF done THEN \n		LEAVE read_loop; \n	END IF; \n	-- Geração dos eventos básicos 2,3 e 40 (001,002,003) da folha\n	CALL fin_folha_ev_basico(v_id_user,v_dominio,v_ano,v_mes,v_parcela,v_id_cad_servidor); \nEND LOOP; \nCLOSE cur1; \n/**\nAs operações abaixo foram deslocadas para suas próprias chamadas dentro de main.php\nCALL fin_folha_eventos_recorrentes(v_id_user,v_dominio,v_ano,v_mes,v_parcela); \nCALL fin_folha_eventos_parcelados(v_id_user,v_dominio,v_ano,v_mes,v_parcela); \n*/\nEND','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_major','fin_folha_eventos_consignados','PROCEDURE','fin_folha_eventos_consignados','SQL','CONTAINS_SQL','NO','DEFINER','\nv_id_user INT(11),v_dominio VARCHAR(255),v_ano VARCHAR(4),v_mes VARCHAR(2),v_parcela VARCHAR(3)','','BEGIN\n	DECLARE done INT DEFAULT FALSE;\n	DECLARE r_id_fin_rubricas,r_id_cad_servidores,r_id_fin_eventos,r_prazo,r_prazot,r_id_evento INT(11);\n	DECLARE r_slug,r_referencia,r_valor_base,r_valor,r_valor_patronal,\n			r_valor_maternidade,r_desconto,r_percentual VARCHAR(255);	 \n	-- obter referências\n	DECLARE cur1Referencias CURSOR FOR  \n		SELECT fin_rubricas.id_cad_servidores,fin_rubricas.id_fin_eventos,\n			fin_rubricas.referencia,fin_rubricas.valor_base,fin_rubricas.valor,fin_rubricas.valor_patronal,\n			fin_rubricas.valor_maternidade,fin_rubricas.desconto,fin_rubricas.percentual,\n			fin_rubricas.prazo + 1,fin_rubricas.prazot \n			FROM fin_rubricas\n			/*buscar a folha de informação*/\n			JOIN fin_parametros ON fin_parametros.ano_informacao = fin_rubricas.ano\n			AND fin_parametros.mes_informacao = fin_rubricas.mes AND fin_parametros.parcela_informacao = fin_rubricas.parcela\n			AND fin_parametros.dominio = fin_rubricas.dominio\n			JOIN fin_eventos ON fin_eventos.id = fin_rubricas.id_fin_eventos\n			JOIN fin_sfuncional ON fin_parametros.ano_informacao = fin_sfuncional.ano\n			AND fin_parametros.mes_informacao = fin_sfuncional.mes AND fin_parametros.parcela_informacao = fin_sfuncional.parcela\n			AND fin_rubricas.dominio = fin_sfuncional.dominio and fin_sfuncional.id_cad_servidores = fin_rubricas.id_cad_servidores\n			WHERE fin_rubricas.dominio = v_dominio AND fin_parametros.ano = v_ano \n			AND fin_parametros.mes = v_mes AND fin_parametros.parcela = v_parcela\n			AND fin_rubricas.prazot > fin_rubricas.prazo AND fin_eventos.consignado = 1 AND fin_rubricas.valor > 0\n			AND fin_sfuncional.situacao = 1 AND fin_sfuncional.situacaofuncional >= 1\n			GROUP BY fin_rubricas.id_cad_servidores,fin_rubricas.id_fin_eventos,fin_parametros.ano,fin_parametros.mes,fin_parametros.parcela\n			ORDER BY fin_rubricas.id_cad_servidores,fin_eventos.tipo,fin_eventos.id_evento;\n	DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;\n	-- Retorna e armazena o último id da tabela fiin_rubricas\n	SET r_id_fin_rubricas = (SELECT MAX(id) FROM fin_rubricas);	\n	\n	-- Varre as referencias para localizar a correta e registrar o valor\n	OPEN cur1Referencias;\n	read_loop: LOOP\n		FETCH cur1Referencias INTO r_id_cad_servidores,r_id_fin_eventos,r_referencia,\n			r_valor_base,r_valor,r_valor_patronal,r_valor_maternidade,r_desconto,\n			r_percentual,r_prazo,r_prazot;\n		IF done THEN\n			LEAVE read_loop;\n		END IF;	\n		/*primeiro verifica se o servidor é falecido. 0 quer dizer que não foi encontrado afastamento S2 ou S3 para o servidor*/\n		if (SELECT getSFalecimento(r_id_cad_servidores) = 0) then\n			/*gera um slug*/\n			SET r_slug = SHA(CONCAT(UNIX_TIMESTAMP(NOW()),r_id_fin_rubricas));\n			/*depois seta o novo r_id_fin_rubricas*/\n			SET r_id_fin_rubricas = r_id_fin_rubricas + 1;	\n			/*para garantir a integridade da chave primária, efetua uma segunda verificação e geração de r_id_fin_rubricas, se necessário*/	\n			IF (SELECT id FROM fin_rubricas WHERE id = r_id_fin_rubricas) IS NOT NULL THEN\n				SET r_id_fin_rubricas = r_id_fin_rubricas + 1;\n			END IF;\n			SET r_id_evento = getEventoSistema(v_dominio,CONCAT(\'Inclusão da rúbrica parcelada id: \', r_id_fin_eventos),\'actionC\', \'fin_rubricas\', r_id_fin_rubricas, v_id_user);\n			INSERT INTO fin_rubricas(\n				id,slug,status,dominio,evento,created_at,updated_at,\n				id_cad_servidores,id_fin_eventos,ano,mes,parcela,\n				referencia,valor_base,valor,valor_patronal,\n				valor_maternidade,prazo,prazot,desconto,percentual\n			) VALUES (\n				r_id_fin_rubricas,r_slug,10,v_dominio,r_id_evento,UNIX_TIMESTAMP(NOW()),UNIX_TIMESTAMP(NOW()),\n				r_id_cad_servidores,r_id_fin_eventos,v_ano,v_mes,v_parcela,\n				r_referencia,r_valor_base,r_valor,r_valor_patronal,\n				r_valor_maternidade,r_prazo,r_prazot,r_desconto,r_percentual\n			);\n		end if;\n	END LOOP;\n	CLOSE cur1Referencias;\nEND','root@localhost','2019-06-13 10:02:47','2019-06-13 10:02:47','NO_AUTO_VALUE_ON_ZERO','','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN\n	DECLARE done INT DEFAULT FALSE;\n	DECLARE r_id_fin_rubricas,r_id_cad_servidores,r_id_fin_eventos,r_prazo,r_prazot,r_id_evento INT(11);\n	DECLARE r_slug,r_referencia,r_valor_base,r_valor,r_valor_patronal,\n			r_valor_maternidade,r_desconto,r_percentual VARCHAR(255);	 \n	-- obter referências\n	DECLARE cur1Referencias CURSOR FOR  \n		SELECT fin_rubricas.id_cad_servidores,fin_rubricas.id_fin_eventos,\n			fin_rubricas.referencia,fin_rubricas.valor_base,fin_rubricas.valor,fin_rubricas.valor_patronal,\n			fin_rubricas.valor_maternidade,fin_rubricas.desconto,fin_rubricas.percentual,\n			fin_rubricas.prazo + 1,fin_rubricas.prazot \n			FROM fin_rubricas\n			/*buscar a folha de informação*/\n			JOIN fin_parametros ON fin_parametros.ano_informacao = fin_rubricas.ano\n			AND fin_parametros.mes_informacao = fin_rubricas.mes AND fin_parametros.parcela_informacao = fin_rubricas.parcela\n			AND fin_parametros.dominio = fin_rubricas.dominio\n			JOIN fin_eventos ON fin_eventos.id = fin_rubricas.id_fin_eventos\n			JOIN fin_sfuncional ON fin_parametros.ano_informacao = fin_sfuncional.ano\n			AND fin_parametros.mes_informacao = fin_sfuncional.mes AND fin_parametros.parcela_informacao = fin_sfuncional.parcela\n			AND fin_rubricas.dominio = fin_sfuncional.dominio and fin_sfuncional.id_cad_servidores = fin_rubricas.id_cad_servidores\n			WHERE fin_rubricas.dominio = v_dominio AND fin_parametros.ano = v_ano \n			AND fin_parametros.mes = v_mes AND fin_parametros.parcela = v_parcela\n			AND fin_rubricas.prazot > fin_rubricas.prazo AND fin_eventos.consignado = 1 AND fin_rubricas.valor > 0\n			AND fin_sfuncional.situacao = 1 AND fin_sfuncional.situacaofuncional >= 1\n			GROUP BY fin_rubricas.id_cad_servidores,fin_rubricas.id_fin_eventos,fin_parametros.ano,fin_parametros.mes,fin_parametros.parcela\n			ORDER BY fin_rubricas.id_cad_servidores,fin_eventos.tipo,fin_eventos.id_evento;\n	DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;\n	-- Retorna e armazena o último id da tabela fiin_rubricas\n	SET r_id_fin_rubricas = (SELECT MAX(id) FROM fin_rubricas);	\n	\n	-- Varre as referencias para localizar a correta e registrar o valor\n	OPEN cur1Referencias;\n	read_loop: LOOP\n		FETCH cur1Referencias INTO r_id_cad_servidores,r_id_fin_eventos,r_referencia,\n			r_valor_base,r_valor,r_valor_patronal,r_valor_maternidade,r_desconto,\n			r_percentual,r_prazo,r_prazot;\n		IF done THEN\n			LEAVE read_loop;\n		END IF;	\n		/*primeiro verifica se o servidor é falecido. 0 quer dizer que não foi encontrado afastamento S2 ou S3 para o servidor*/\n		if (SELECT getSFalecimento(r_id_cad_servidores) = 0) then\n			/*gera um slug*/\n			SET r_slug = SHA(CONCAT(UNIX_TIMESTAMP(NOW()),r_id_fin_rubricas));\n			/*depois seta o novo r_id_fin_rubricas*/\n			SET r_id_fin_rubricas = r_id_fin_rubricas + 1;	\n			/*para garantir a integridade da chave primária, efetua uma segunda verificação e geração de r_id_fin_rubricas, se necessário*/	\n			IF (SELECT id FROM fin_rubricas WHERE id = r_id_fin_rubricas) IS NOT NULL THEN\n				SET r_id_fin_rubricas = r_id_fin_rubricas + 1;\n			END IF;\n			SET r_id_evento = getEventoSistema(v_dominio,CONCAT(\'Inclusão da rúbrica parcelada id: \', r_id_fin_eventos),\'actionC\', \'fin_rubricas\', r_id_fin_rubricas, v_id_user);\n			INSERT INTO fin_rubricas(\n				id,slug,status,dominio,evento,created_at,updated_at,\n				id_cad_servidores,id_fin_eventos,ano,mes,parcela,\n				referencia,valor_base,valor,valor_patronal,\n				valor_maternidade,prazo,prazot,desconto,percentual\n			) VALUES (\n				r_id_fin_rubricas,r_slug,10,v_dominio,r_id_evento,UNIX_TIMESTAMP(NOW()),UNIX_TIMESTAMP(NOW()),\n				r_id_cad_servidores,r_id_fin_eventos,v_ano,v_mes,v_parcela,\n				r_referencia,r_valor_base,r_valor,r_valor_patronal,\n				r_valor_maternidade,r_prazo,r_prazot,r_desconto,r_percentual\n			);\n		end if;\n	END LOOP;\n	CLOSE cur1Referencias;\nEND','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_major','fin_folha_eventos_unique','PROCEDURE','fin_folha_eventos_unique','SQL','CONTAINS_SQL','NO','DEFINER','v_dominio VARCHAR(255),v_ano VARCHAR(4),v_mes VARCHAR(2),v_parcela VARCHAR(3),v_id_cad_servidor INT','','BEGIN \nDECLARE done INT DEFAULT FALSE; \nDECLARE cur1 CURSOR FOR \nSELECT fin_sfuncional.id_cad_servidores \n	FROM fin_sfuncional \n	JOIN cad_servidores ON cad_servidores.id = fin_sfuncional.id_cad_servidores \n	WHERE fin_sfuncional.dominio = v_dominio AND fin_sfuncional.ano = v_ano \n	AND fin_sfuncional.mes = v_mes AND fin_sfuncional.parcela = v_parcela -- AND fin_sfuncional.situacao = 1 \n	AND fin_sfuncional.situacaofuncional > 0 AND (fin_sfuncional.id_pccs IS NOT NULL AND fin_sfuncional.id_pccs > 0) \n	AND fin_sfuncional.id_cad_servidores = CAST(v_id_cad_servidor AS UNSIGNED)\n	AND fin_sfuncional.lanca_salario = 1\n	ORDER BY cad_servidores.id; \nDECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE; \nDELETE FROM fin_rubricas WHERE dominio = v_dominio \n	AND ano = v_ano AND mes = v_mes AND parcela = v_parcela\n	AND fin_rubricas.id_cad_servidores = CAST(v_id_cad_servidor AS UNSIGNED); \nOPEN cur1; \nread_loop: LOOP FETCH cur1 INTO v_id_cad_servidor; \n	IF done THEN \n		LEAVE read_loop; \n	END IF; \n	CALL fin_folha_ev_basico(v_dominio,v_ano,v_mes,v_parcela,v_id_cad_servidor); \nEND LOOP; \nCLOSE cur1; \nEND','root@localhost','2019-06-13 10:02:47','2019-06-13 10:02:47','NO_AUTO_VALUE_ON_ZERO','','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN \nDECLARE done INT DEFAULT FALSE; \nDECLARE cur1 CURSOR FOR \nSELECT fin_sfuncional.id_cad_servidores \n	FROM fin_sfuncional \n	JOIN cad_servidores ON cad_servidores.id = fin_sfuncional.id_cad_servidores \n	WHERE fin_sfuncional.dominio = v_dominio AND fin_sfuncional.ano = v_ano \n	AND fin_sfuncional.mes = v_mes AND fin_sfuncional.parcela = v_parcela -- AND fin_sfuncional.situacao = 1 \n	AND fin_sfuncional.situacaofuncional > 0 AND (fin_sfuncional.id_pccs IS NOT NULL AND fin_sfuncional.id_pccs > 0) \n	AND fin_sfuncional.id_cad_servidores = CAST(v_id_cad_servidor AS UNSIGNED)\n	AND fin_sfuncional.lanca_salario = 1\n	ORDER BY cad_servidores.id; \nDECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE; \nDELETE FROM fin_rubricas WHERE dominio = v_dominio \n	AND ano = v_ano AND mes = v_mes AND parcela = v_parcela\n	AND fin_rubricas.id_cad_servidores = CAST(v_id_cad_servidor AS UNSIGNED); \nOPEN cur1; \nread_loop: LOOP FETCH cur1 INTO v_id_cad_servidor; \n	IF done THEN \n		LEAVE read_loop; \n	END IF; \n	CALL fin_folha_ev_basico(v_dominio,v_ano,v_mes,v_parcela,v_id_cad_servidor); \nEND LOOP; \nCLOSE cur1; \nEND','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_major','fin_folha_eventos_parcelados','PROCEDURE','fin_folha_eventos_parcelados','SQL','CONTAINS_SQL','NO','DEFINER','\nv_id_user INT(11),v_dominio VARCHAR(255),v_ano VARCHAR(4),v_mes VARCHAR(2),v_parcela VARCHAR(3)','','BEGIN\n	DECLARE done INT DEFAULT FALSE;\n	DECLARE r_id_fin_rubricas,r_id_cad_servidores,r_id_fin_eventos,r_prazo,r_prazot,r_id_evento INT(11);\n	DECLARE r_slug,r_referencia,r_valor_base,r_valor,r_valor_patronal,\n			r_valor_maternidade,r_desconto,r_percentual VARCHAR(255);	 \n	-- obter referências\n	DECLARE cur1Referencias CURSOR FOR  \n		SELECT fin_rubricas.id_cad_servidores,fin_rubricas.id_fin_eventos,\n			fin_rubricas.referencia,fin_rubricas.valor_base,fin_rubricas.valor,fin_rubricas.valor_patronal,\n			fin_rubricas.valor_maternidade,fin_rubricas.desconto,fin_rubricas.percentual,\n			fin_rubricas.prazo + 1,fin_rubricas.prazot \n			FROM fin_rubricas\n			/*buscar a folha de informação*/\n			JOIN fin_parametros ON fin_parametros.ano_informacao = fin_rubricas.ano\n			AND fin_parametros.mes_informacao = fin_rubricas.mes AND fin_parametros.parcela_informacao = fin_rubricas.parcela\n			AND fin_parametros.dominio = fin_rubricas.dominio\n			JOIN fin_eventos ON fin_eventos.id = fin_rubricas.id_fin_eventos\n			JOIN fin_sfuncional ON fin_parametros.ano_informacao = fin_sfuncional.ano\n			AND fin_parametros.mes_informacao = fin_sfuncional.mes AND fin_parametros.parcela_informacao = fin_sfuncional.parcela\n			AND fin_rubricas.dominio = fin_sfuncional.dominio AND fin_sfuncional.id_cad_servidores = fin_rubricas.id_cad_servidores\n			WHERE fin_rubricas.dominio = v_dominio AND fin_parametros.ano = v_ano \n			AND fin_parametros.mes = v_mes AND fin_parametros.parcela = v_parcela\n			AND fin_rubricas.prazot > fin_rubricas.prazo AND fin_eventos.consignado = 0 AND fin_rubricas.valor > 0\n			AND fin_sfuncional.situacao = 1 AND fin_sfuncional.situacaofuncional >= 1\n			GROUP BY fin_rubricas.id_cad_servidores,fin_rubricas.id_fin_eventos,fin_parametros.ano,fin_parametros.mes,fin_parametros.parcela\n			ORDER BY fin_rubricas.id_cad_servidores,fin_eventos.tipo,fin_eventos.id_evento;\n	DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;\n	-- Retorna e armazena o último id da tabela fiin_rubricas\n	SET r_id_fin_rubricas = (SELECT MAX(id) FROM fin_rubricas);	\n	\n	-- Varre as referencias para localizar a correta e registrar o valor\n	OPEN cur1Referencias;\n	read_loop: LOOP\n		FETCH cur1Referencias INTO r_id_cad_servidores,r_id_fin_eventos,r_referencia,\n			r_valor_base,r_valor,r_valor_patronal,r_valor_maternidade,r_desconto,\n			r_percentual,r_prazo,r_prazot;\n		IF done THEN\n			LEAVE read_loop;\n		END IF;	\n		/*primeiro gera um slug*/\n		SET r_slug = SHA(CONCAT(UNIX_TIMESTAMP(NOW()),r_id_fin_rubricas));\n		/*depois seta o novo r_id_fin_rubricas*/\n		SET r_id_fin_rubricas = r_id_fin_rubricas + 1;	\n		/*para garantir a integridade da chave primária, efetua uma segunda verificação e geração de r_id_fin_rubricas, se necessário*/	\n		IF (SELECT id FROM fin_rubricas WHERE id = r_id_fin_rubricas) IS NOT NULL THEN\n			SET r_id_fin_rubricas = r_id_fin_rubricas + 1;\n		END IF;\n		SET r_id_evento = getEventoSistema(v_dominio,CONCAT(\'Inclusão da rúbrica parcelada id: \', r_id_fin_eventos),\'actionC\', \'fin_rubricas\', r_id_fin_rubricas, v_id_user);\n		INSERT INTO fin_rubricas(\n			id,slug,`status`,dominio,evento,created_at,updated_at,\n			id_cad_servidores,id_fin_eventos,ano,mes,parcela,\n			referencia,valor_base,valor,valor_patronal,\n			valor_maternidade,prazo,prazot,desconto,percentual\n		) VALUES (\n			r_id_fin_rubricas,r_slug,10,v_dominio,r_id_evento,UNIX_TIMESTAMP(NOW()),UNIX_TIMESTAMP(NOW()),\n			r_id_cad_servidores,r_id_fin_eventos,v_ano,v_mes,v_parcela,\n			r_referencia,r_valor_base,r_valor,r_valor_patronal,\n			r_valor_maternidade,r_prazo,r_prazot,r_desconto,r_percentual\n		);\n	END LOOP;\n	CLOSE cur1Referencias;\nEND','root@localhost','2019-06-13 10:02:47','2019-06-13 10:02:47','NO_AUTO_VALUE_ON_ZERO','','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN\n	DECLARE done INT DEFAULT FALSE;\n	DECLARE r_id_fin_rubricas,r_id_cad_servidores,r_id_fin_eventos,r_prazo,r_prazot,r_id_evento INT(11);\n	DECLARE r_slug,r_referencia,r_valor_base,r_valor,r_valor_patronal,\n			r_valor_maternidade,r_desconto,r_percentual VARCHAR(255);	 \n	-- obter referências\n	DECLARE cur1Referencias CURSOR FOR  \n		SELECT fin_rubricas.id_cad_servidores,fin_rubricas.id_fin_eventos,\n			fin_rubricas.referencia,fin_rubricas.valor_base,fin_rubricas.valor,fin_rubricas.valor_patronal,\n			fin_rubricas.valor_maternidade,fin_rubricas.desconto,fin_rubricas.percentual,\n			fin_rubricas.prazo + 1,fin_rubricas.prazot \n			FROM fin_rubricas\n			/*buscar a folha de informação*/\n			JOIN fin_parametros ON fin_parametros.ano_informacao = fin_rubricas.ano\n			AND fin_parametros.mes_informacao = fin_rubricas.mes AND fin_parametros.parcela_informacao = fin_rubricas.parcela\n			AND fin_parametros.dominio = fin_rubricas.dominio\n			JOIN fin_eventos ON fin_eventos.id = fin_rubricas.id_fin_eventos\n			JOIN fin_sfuncional ON fin_parametros.ano_informacao = fin_sfuncional.ano\n			AND fin_parametros.mes_informacao = fin_sfuncional.mes AND fin_parametros.parcela_informacao = fin_sfuncional.parcela\n			AND fin_rubricas.dominio = fin_sfuncional.dominio AND fin_sfuncional.id_cad_servidores = fin_rubricas.id_cad_servidores\n			WHERE fin_rubricas.dominio = v_dominio AND fin_parametros.ano = v_ano \n			AND fin_parametros.mes = v_mes AND fin_parametros.parcela = v_parcela\n			AND fin_rubricas.prazot > fin_rubricas.prazo AND fin_eventos.consignado = 0 AND fin_rubricas.valor > 0\n			AND fin_sfuncional.situacao = 1 AND fin_sfuncional.situacaofuncional >= 1\n			GROUP BY fin_rubricas.id_cad_servidores,fin_rubricas.id_fin_eventos,fin_parametros.ano,fin_parametros.mes,fin_parametros.parcela\n			ORDER BY fin_rubricas.id_cad_servidores,fin_eventos.tipo,fin_eventos.id_evento;\n	DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;\n	-- Retorna e armazena o último id da tabela fiin_rubricas\n	SET r_id_fin_rubricas = (SELECT MAX(id) FROM fin_rubricas);	\n	\n	-- Varre as referencias para localizar a correta e registrar o valor\n	OPEN cur1Referencias;\n	read_loop: LOOP\n		FETCH cur1Referencias INTO r_id_cad_servidores,r_id_fin_eventos,r_referencia,\n			r_valor_base,r_valor,r_valor_patronal,r_valor_maternidade,r_desconto,\n			r_percentual,r_prazo,r_prazot;\n		IF done THEN\n			LEAVE read_loop;\n		END IF;	\n		/*primeiro gera um slug*/\n		SET r_slug = SHA(CONCAT(UNIX_TIMESTAMP(NOW()),r_id_fin_rubricas));\n		/*depois seta o novo r_id_fin_rubricas*/\n		SET r_id_fin_rubricas = r_id_fin_rubricas + 1;	\n		/*para garantir a integridade da chave primária, efetua uma segunda verificação e geração de r_id_fin_rubricas, se necessário*/	\n		IF (SELECT id FROM fin_rubricas WHERE id = r_id_fin_rubricas) IS NOT NULL THEN\n			SET r_id_fin_rubricas = r_id_fin_rubricas + 1;\n		END IF;\n		SET r_id_evento = getEventoSistema(v_dominio,CONCAT(\'Inclusão da rúbrica parcelada id: \', r_id_fin_eventos),\'actionC\', \'fin_rubricas\', r_id_fin_rubricas, v_id_user);\n		INSERT INTO fin_rubricas(\n			id,slug,`status`,dominio,evento,created_at,updated_at,\n			id_cad_servidores,id_fin_eventos,ano,mes,parcela,\n			referencia,valor_base,valor,valor_patronal,\n			valor_maternidade,prazo,prazot,desconto,percentual\n		) VALUES (\n			r_id_fin_rubricas,r_slug,10,v_dominio,r_id_evento,UNIX_TIMESTAMP(NOW()),UNIX_TIMESTAMP(NOW()),\n			r_id_cad_servidores,r_id_fin_eventos,v_ano,v_mes,v_parcela,\n			r_referencia,r_valor_base,r_valor,r_valor_patronal,\n			r_valor_maternidade,r_prazo,r_prazot,r_desconto,r_percentual\n		);\n	END LOOP;\n	CLOSE cur1Referencias;\nEND','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_major','fin_folha_eventos_recorrentes','PROCEDURE','fin_folha_eventos_recorrentes','SQL','CONTAINS_SQL','NO','DEFINER','\nv_id_user INT(11),v_dominio VARCHAR(255),v_ano VARCHAR(4),v_mes VARCHAR(2),v_parcela VARCHAR(3)','','BEGIN\n	DECLARE done INT DEFAULT FALSE;\n	DECLARE r_id_fin_rubricas,r_id_cad_servidores,r_id_fin_eventos,r_prazo,r_prazot,r_id_evento INT(11);\n	DECLARE r_slug,r_referencia,r_valor_base,r_valor,r_valor_patronal,\n			r_valor_maternidade,r_desconto,r_percentual VARCHAR(255);	 \n	-- obter referências\n	DECLARE cur1Referencias CURSOR FOR  \n		SELECT fin_rubricas.id_cad_servidores,fin_rubricas.id_fin_eventos,\n			fin_rubricas.referencia,fin_rubricas.valor_base,fin_rubricas.valor,fin_rubricas.valor_patronal,\n			fin_rubricas.valor_maternidade,fin_rubricas.desconto,fin_rubricas.percentual \n			FROM fin_rubricas\n			/*buscar a folha de informação*/\n			JOIN fin_parametros ON fin_parametros.ano_informacao = fin_rubricas.ano\n			AND fin_parametros.mes_informacao = fin_rubricas.mes AND fin_parametros.parcela_informacao = fin_rubricas.parcela\n			AND fin_parametros.dominio = fin_rubricas.dominio\n			JOIN fin_eventos ON fin_eventos.id = fin_rubricas.id_fin_eventos\n			JOIN fin_sfuncional ON fin_parametros.ano_informacao = fin_sfuncional.ano\n			AND fin_parametros.mes_informacao = fin_sfuncional.mes AND fin_parametros.parcela_informacao = fin_sfuncional.parcela\n			AND fin_rubricas.dominio = fin_sfuncional.dominio AND fin_sfuncional.id_cad_servidores = fin_rubricas.id_cad_servidores\n			WHERE fin_rubricas.dominio = v_dominio AND fin_parametros.ano = v_ano \n			AND fin_parametros.mes = v_mes AND fin_parametros.parcela = v_parcela			\n			AND fin_eventos.ev_root != 1 AND fin_eventos.fixo = 1 AND fin_rubricas.prazot = fin_rubricas.prazo \n			AND fin_rubricas.prazot IN (1,999) and fin_rubricas.valor > 0 \n			AND fin_sfuncional.situacao = 1 AND fin_sfuncional.situacaofuncional >= 1\n			GROUP BY fin_rubricas.id_cad_servidores,fin_rubricas.id_fin_eventos,fin_parametros.ano,fin_parametros.mes,fin_parametros.parcela\n			ORDER BY fin_rubricas.id_cad_servidores,fin_eventos.tipo,fin_eventos.id_evento;\n	DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;\n	-- Retorna e armazena o último id da tabela fiin_rubricas\n	SET r_id_fin_rubricas = (SELECT MAX(id) FROM fin_rubricas);	\n	\n	-- Varre as referencias para localizar a correta e registrar o valor\n	OPEN cur1Referencias;\n	read_loop: LOOP\n		FETCH cur1Referencias INTO r_id_cad_servidores,r_id_fin_eventos,r_referencia,\n			r_valor_base,r_valor,r_valor_patronal,r_valor_maternidade,r_desconto,r_percentual;\n		IF done THEN\n			LEAVE read_loop;\n		END IF;	\n		/*primeiro gera um slug*/\n		SET r_slug = SHA(CONCAT(UNIX_TIMESTAMP(NOW()),r_id_fin_rubricas));\n		/*depois seta o novo r_id_fin_rubricas*/\n		SET r_id_fin_rubricas = r_id_fin_rubricas + 1;	\n		/*para garantir a integridade da chave primária, efetua uma segunda verificação e geração de r_id_fin_rubricas, se necessário*/	\n		IF (SELECT id FROM fin_rubricas WHERE id = r_id_fin_rubricas) IS NOT NULL THEN\n			SET r_id_fin_rubricas = r_id_fin_rubricas + 1;\n		END IF;\n		SET r_id_evento = getEventoSistema(v_dominio,CONCAT(\'Inclusão da rúbrica recorrente id: \', r_id_fin_eventos),\'actionC\', \'fin_rubricas\', r_id_fin_rubricas, v_id_user);\n		SET r_valor_base = 0, r_valor = 0, r_valor_patronal = 0, r_valor_maternidade = 0, r_desconto = 0, r_prazo = 1, r_prazot = 1;\n		INSERT INTO fin_rubricas(\n			id,slug,`status`,dominio,evento,created_at,updated_at,\n			id_cad_servidores,id_fin_eventos,ano,mes,parcela,\n			referencia,valor_base,valor,valor_patronal,\n			valor_maternidade,prazo,prazot,desconto,percentual\n		) VALUES (\n			r_id_fin_rubricas,r_slug,10,v_dominio,r_id_evento,UNIX_TIMESTAMP(NOW()),UNIX_TIMESTAMP(NOW()),\n			r_id_cad_servidores,r_id_fin_eventos,v_ano,v_mes,v_parcela,\n			r_referencia,r_valor_base,r_valor,r_valor_patronal,\n			r_valor_maternidade,r_prazo,r_prazot,r_desconto,r_percentual\n		);\n	END LOOP;\n	CLOSE cur1Referencias;\nEND','root@localhost','2019-06-13 10:02:47','2019-06-13 10:02:47','NO_AUTO_VALUE_ON_ZERO','','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN\n	DECLARE done INT DEFAULT FALSE;\n	DECLARE r_id_fin_rubricas,r_id_cad_servidores,r_id_fin_eventos,r_prazo,r_prazot,r_id_evento INT(11);\n	DECLARE r_slug,r_referencia,r_valor_base,r_valor,r_valor_patronal,\n			r_valor_maternidade,r_desconto,r_percentual VARCHAR(255);	 \n	-- obter referências\n	DECLARE cur1Referencias CURSOR FOR  \n		SELECT fin_rubricas.id_cad_servidores,fin_rubricas.id_fin_eventos,\n			fin_rubricas.referencia,fin_rubricas.valor_base,fin_rubricas.valor,fin_rubricas.valor_patronal,\n			fin_rubricas.valor_maternidade,fin_rubricas.desconto,fin_rubricas.percentual \n			FROM fin_rubricas\n			/*buscar a folha de informação*/\n			JOIN fin_parametros ON fin_parametros.ano_informacao = fin_rubricas.ano\n			AND fin_parametros.mes_informacao = fin_rubricas.mes AND fin_parametros.parcela_informacao = fin_rubricas.parcela\n			AND fin_parametros.dominio = fin_rubricas.dominio\n			JOIN fin_eventos ON fin_eventos.id = fin_rubricas.id_fin_eventos\n			JOIN fin_sfuncional ON fin_parametros.ano_informacao = fin_sfuncional.ano\n			AND fin_parametros.mes_informacao = fin_sfuncional.mes AND fin_parametros.parcela_informacao = fin_sfuncional.parcela\n			AND fin_rubricas.dominio = fin_sfuncional.dominio AND fin_sfuncional.id_cad_servidores = fin_rubricas.id_cad_servidores\n			WHERE fin_rubricas.dominio = v_dominio AND fin_parametros.ano = v_ano \n			AND fin_parametros.mes = v_mes AND fin_parametros.parcela = v_parcela			\n			AND fin_eventos.ev_root != 1 AND fin_eventos.fixo = 1 AND fin_rubricas.prazot = fin_rubricas.prazo \n			AND fin_rubricas.prazot IN (1,999) and fin_rubricas.valor > 0 \n			AND fin_sfuncional.situacao = 1 AND fin_sfuncional.situacaofuncional >= 1\n			GROUP BY fin_rubricas.id_cad_servidores,fin_rubricas.id_fin_eventos,fin_parametros.ano,fin_parametros.mes,fin_parametros.parcela\n			ORDER BY fin_rubricas.id_cad_servidores,fin_eventos.tipo,fin_eventos.id_evento;\n	DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;\n	-- Retorna e armazena o último id da tabela fiin_rubricas\n	SET r_id_fin_rubricas = (SELECT MAX(id) FROM fin_rubricas);	\n	\n	-- Varre as referencias para localizar a correta e registrar o valor\n	OPEN cur1Referencias;\n	read_loop: LOOP\n		FETCH cur1Referencias INTO r_id_cad_servidores,r_id_fin_eventos,r_referencia,\n			r_valor_base,r_valor,r_valor_patronal,r_valor_maternidade,r_desconto,r_percentual;\n		IF done THEN\n			LEAVE read_loop;\n		END IF;	\n		/*primeiro gera um slug*/\n		SET r_slug = SHA(CONCAT(UNIX_TIMESTAMP(NOW()),r_id_fin_rubricas));\n		/*depois seta o novo r_id_fin_rubricas*/\n		SET r_id_fin_rubricas = r_id_fin_rubricas + 1;	\n		/*para garantir a integridade da chave primária, efetua uma segunda verificação e geração de r_id_fin_rubricas, se necessário*/	\n		IF (SELECT id FROM fin_rubricas WHERE id = r_id_fin_rubricas) IS NOT NULL THEN\n			SET r_id_fin_rubricas = r_id_fin_rubricas + 1;\n		END IF;\n		SET r_id_evento = getEventoSistema(v_dominio,CONCAT(\'Inclusão da rúbrica recorrente id: \', r_id_fin_eventos),\'actionC\', \'fin_rubricas\', r_id_fin_rubricas, v_id_user);\n		SET r_valor_base = 0, r_valor = 0, r_valor_patronal = 0, r_valor_maternidade = 0, r_desconto = 0, r_prazo = 1, r_prazot = 1;\n		INSERT INTO fin_rubricas(\n			id,slug,`status`,dominio,evento,created_at,updated_at,\n			id_cad_servidores,id_fin_eventos,ano,mes,parcela,\n			referencia,valor_base,valor,valor_patronal,\n			valor_maternidade,prazo,prazot,desconto,percentual\n		) VALUES (\n			r_id_fin_rubricas,r_slug,10,v_dominio,r_id_evento,UNIX_TIMESTAMP(NOW()),UNIX_TIMESTAMP(NOW()),\n			r_id_cad_servidores,r_id_fin_eventos,v_ano,v_mes,v_parcela,\n			r_referencia,r_valor_base,r_valor,r_valor_patronal,\n			r_valor_maternidade,r_prazo,r_prazot,r_desconto,r_percentual\n		);\n	END LOOP;\n	CLOSE cur1Referencias;\nEND','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_major','fin_folha_ev_basico','PROCEDURE','fin_folha_ev_basico','SQL','CONTAINS_SQL','NO','DEFINER','v_id_user VARCHAR(255),v_dominio VARCHAR(255),v_ano VARCHAR(4),v_mes VARCHAR(2),\nv_parcela VARCHAR(3),v_id_cad_servidor VARCHAR(255)','','BEGIN\n DECLARE r_valor, v_valor DECIMAL(11,2);\n DECLARE v_referencia, v_anos, v_meses, v_dias CHAR(2);\n DECLARE v_i_ano_inicial, v_i_ano_final CHAR(3);\n DECLARE v_id_pccs, v_id_vinculo, v_dias_mes, v_dias_trabalhados, r_id_evento, r_id_fin_eventos, r_id_fin_rubricas INT;\n DECLARE v_d_admissao DATE; \n DECLARE done INT DEFAULT FALSE; \n DECLARE exec INT DEFAULT TRUE;  \n -- obter referências\n DECLARE cur1Referencias CURSOR FOR  \n	SELECT fin_referencias.valor, cad_classes.i_ano_inicial, cad_classes.i_ano_final \n		FROM fin_referencias \n		JOIN cad_pccs ON cad_pccs.dominio = fin_referencias.dominio \n			AND cad_pccs.id_pccs = fin_referencias.id_pccs \n		JOIN cad_classes ON cad_classes.dominio = fin_referencias.dominio \n			AND cad_classes.id_pccs = cad_pccs.id_pccs \n			AND cad_classes.id_classe = fin_referencias.id_classe \n		WHERE (cad_pccs.dominio=v_dominio) AND (fin_referencias.id_pccs=v_id_pccs) \n			AND (STR_TO_DATE(fin_referencias.data, \'%d/%m/%Y\') <= LAST_DAY(CONCAT(v_ano, \'-\', v_mes, \'-1\'))) \n			AND CAST(v_anos AS UNSIGNED) BETWEEN CAST(cad_classes.i_ano_inicial AS UNSIGNED) AND CAST(cad_classes.i_ano_final AS UNSIGNED)\n		ORDER BY fin_referencias.id_classe DESC, fin_referencias.referencia DESC\n		LIMIT 100000;\n DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;\n \n SET v_dias_mes = DATE_FORMAT(LAST_DAY(CONCAT(v_ano, \'-\', v_mes, \'-1\')), \'%d\');\n SET v_dias_trabalhados = getDiasPagarVctoBasico(v_id_cad_servidor,v_ano,v_mes);\n SET v_referencia = v_dias_trabalhados;\n SET r_valor = 0;\n -- Registra valor para: v_id_pccs, v_d_admissao, v_anos, v_meses, v_dias \n SELECT fin_sfuncional.id_pccs,cad_sfuncional.id_vinculo,\n	/*CONCAT(SUBSTR(cad_servidores.d_admissao, 7),\'-\',SUBSTR(cad_servidores.d_admissao, 4,2),\'-\',SUBSTR(cad_servidores.d_admissao, 1,2))*/\n	STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\')data_adm,\n	TIMESTAMPDIFF(YEAR, STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\'), LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) AS anos,\n	TIMESTAMPDIFF(MONTH, STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\') + INTERVAL TIMESTAMPDIFF(YEAR,  STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\'), LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) YEAR , LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) AS meses,\n	TIMESTAMPDIFF(DAY, STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\') + INTERVAL TIMESTAMPDIFF(MONTH,  STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\'), LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) MONTH , LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) + 1 AS dias\n	INTO v_id_pccs, v_id_vinculo, v_d_admissao, v_anos, v_meses, v_dias\n	FROM cad_sfuncional\n	JOIN cad_servidores ON cad_sfuncional.id_cad_servidores = cad_servidores.id\n	JOIN fin_sfuncional ON cad_sfuncional.id_cad_servidores = fin_sfuncional.id_cad_servidores AND \n	cad_sfuncional.ano = fin_sfuncional.ano AND cad_sfuncional.mes = fin_sfuncional.mes AND\n	cad_sfuncional.parcela = fin_sfuncional.parcela\n	WHERE fin_sfuncional.ano = v_ano AND fin_sfuncional.mes = v_mes AND fin_sfuncional.parcela = v_parcela \n	AND fin_sfuncional.id_cad_servidores = v_id_cad_servidor;\n	-- Varre as referencias para localizar a correta e registrar o valor\n	OPEN cur1Referencias;\n	read_loop: LOOP\n		FETCH cur1Referencias INTO v_valor, v_i_ano_inicial, v_i_ano_final;\n		IF done THEN\n			LEAVE read_loop;\n		END IF;\n		IF !(v_anos = v_i_ano_final && (v_meses != 0 || v_dias != 0)) THEN\n			SET r_valor = ((v_valor / v_dias_mes) * v_dias_trabalhados);\n			IF v_i_ano_final != 0 AND v_i_ano_inicial != 99 THEN\n				SET done = TRUE;\n			ELSE \n				SET done = FALSE;\n			END IF;\n		END IF;\n	END LOOP;\n	CLOSE cur1Referencias;\n	\n SET r_id_fin_eventos = getidvinculo(v_dominio,v_id_vinculo);\n \n IF v_dias_trabalhados > 0 THEN\n	SET exec = TRUE;\n ELSE\n	SET exec = FALSE;\n END IF;\n \nIF exec = TRUE THEN\n	-- Retorna e armazena o último id da tabela fiin_rubricas\n	SET r_id_fin_rubricas = (SELECT MAX(id) FROM fin_rubricas) + 1;\n	/*para garantir a integridade da chave primária, efetua uma segunda verificação e geração de r_id_fin_rubricas, se necessário*/	\n	IF (SELECT id FROM fin_rubricas WHERE id = r_id_fin_rubricas) IS NOT NULL THEN\n		SET r_id_fin_rubricas = r_id_fin_rubricas + 1;\n	END IF;	\n	SET r_id_evento = getEventoSistema(v_dominio,CONCAT(\'Inclusão da rúbrica id: \', r_id_fin_eventos),\'actionC\', \'fin_rubricas\', r_id_fin_rubricas, v_id_user);\n	-- Insere a rúbrica\n	INSERT INTO fin_rubricas (id,slug,STATUS,dominio,evento,created_at,updated_at,\n		id_cad_servidores,id_fin_eventos,\n		ano,mes,parcela,referencia,valor_base,valor,valor_patronal,valor_maternidade,prazo,prazot,desconto,percentual) \n	VALUES(\n		r_id_fin_rubricas,SHA(CONCAT(NOW(),v_dominio,v_id_cad_servidor)),10,v_dominio,r_id_evento,UNIX_TIMESTAMP(NOW()),UNIX_TIMESTAMP(NOW()),\n		v_id_cad_servidor,r_id_fin_eventos,\n		v_ano,v_mes,v_parcela,v_referencia,0.00,r_valor,0.00,0.00,1,1,0.00,100.00\n	);\n END IF; \n /*\nSELECT v_dias_trabalhados, v_id_pccs, r_id_fin_eventos, v_d_admissao, v_anos, v_meses, v_dias, r_valor, exec, v_dias_mes;\n */\nEND','root@localhost','2019-06-13 10:02:47','2019-06-13 10:02:47','NO_AUTO_VALUE_ON_ZERO','','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN\n DECLARE r_valor, v_valor DECIMAL(11,2);\n DECLARE v_referencia, v_anos, v_meses, v_dias CHAR(2);\n DECLARE v_i_ano_inicial, v_i_ano_final CHAR(3);\n DECLARE v_id_pccs, v_id_vinculo, v_dias_mes, v_dias_trabalhados, r_id_evento, r_id_fin_eventos, r_id_fin_rubricas INT;\n DECLARE v_d_admissao DATE; \n DECLARE done INT DEFAULT FALSE; \n DECLARE exec INT DEFAULT TRUE;  \n -- obter referências\n DECLARE cur1Referencias CURSOR FOR  \n	SELECT fin_referencias.valor, cad_classes.i_ano_inicial, cad_classes.i_ano_final \n		FROM fin_referencias \n		JOIN cad_pccs ON cad_pccs.dominio = fin_referencias.dominio \n			AND cad_pccs.id_pccs = fin_referencias.id_pccs \n		JOIN cad_classes ON cad_classes.dominio = fin_referencias.dominio \n			AND cad_classes.id_pccs = cad_pccs.id_pccs \n			AND cad_classes.id_classe = fin_referencias.id_classe \n		WHERE (cad_pccs.dominio=v_dominio) AND (fin_referencias.id_pccs=v_id_pccs) \n			AND (STR_TO_DATE(fin_referencias.data, \'%d/%m/%Y\') <= LAST_DAY(CONCAT(v_ano, \'-\', v_mes, \'-1\'))) \n			AND CAST(v_anos AS UNSIGNED) BETWEEN CAST(cad_classes.i_ano_inicial AS UNSIGNED) AND CAST(cad_classes.i_ano_final AS UNSIGNED)\n		ORDER BY fin_referencias.id_classe DESC, fin_referencias.referencia DESC\n		LIMIT 100000;\n DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;\n \n SET v_dias_mes = DATE_FORMAT(LAST_DAY(CONCAT(v_ano, \'-\', v_mes, \'-1\')), \'%d\');\n SET v_dias_trabalhados = getDiasPagarVctoBasico(v_id_cad_servidor,v_ano,v_mes);\n SET v_referencia = v_dias_trabalhados;\n SET r_valor = 0;\n -- Registra valor para: v_id_pccs, v_d_admissao, v_anos, v_meses, v_dias \n SELECT fin_sfuncional.id_pccs,cad_sfuncional.id_vinculo,\n	/*CONCAT(SUBSTR(cad_servidores.d_admissao, 7),\'-\',SUBSTR(cad_servidores.d_admissao, 4,2),\'-\',SUBSTR(cad_servidores.d_admissao, 1,2))*/\n	STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\')data_adm,\n	TIMESTAMPDIFF(YEAR, STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\'), LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) AS anos,\n	TIMESTAMPDIFF(MONTH, STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\') + INTERVAL TIMESTAMPDIFF(YEAR,  STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\'), LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) YEAR , LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) AS meses,\n	TIMESTAMPDIFF(DAY, STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\') + INTERVAL TIMESTAMPDIFF(MONTH,  STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\'), LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) MONTH , LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) + 1 AS dias\n	INTO v_id_pccs, v_id_vinculo, v_d_admissao, v_anos, v_meses, v_dias\n	FROM cad_sfuncional\n	JOIN cad_servidores ON cad_sfuncional.id_cad_servidores = cad_servidores.id\n	JOIN fin_sfuncional ON cad_sfuncional.id_cad_servidores = fin_sfuncional.id_cad_servidores AND \n	cad_sfuncional.ano = fin_sfuncional.ano AND cad_sfuncional.mes = fin_sfuncional.mes AND\n	cad_sfuncional.parcela = fin_sfuncional.parcela\n	WHERE fin_sfuncional.ano = v_ano AND fin_sfuncional.mes = v_mes AND fin_sfuncional.parcela = v_parcela \n	AND fin_sfuncional.id_cad_servidores = v_id_cad_servidor;\n	-- Varre as referencias para localizar a correta e registrar o valor\n	OPEN cur1Referencias;\n	read_loop: LOOP\n		FETCH cur1Referencias INTO v_valor, v_i_ano_inicial, v_i_ano_final;\n		IF done THEN\n			LEAVE read_loop;\n		END IF;\n		IF !(v_anos = v_i_ano_final && (v_meses != 0 || v_dias != 0)) THEN\n			SET r_valor = ((v_valor / v_dias_mes) * v_dias_trabalhados);\n			IF v_i_ano_final != 0 AND v_i_ano_inicial != 99 THEN\n				SET done = TRUE;\n			ELSE \n				SET done = FALSE;\n			END IF;\n		END IF;\n	END LOOP;\n	CLOSE cur1Referencias;\n	\n SET r_id_fin_eventos = getidvinculo(v_dominio,v_id_vinculo);\n \n IF v_dias_trabalhados > 0 THEN\n	SET exec = TRUE;\n ELSE\n	SET exec = FALSE;\n END IF;\n \nIF exec = TRUE THEN\n	-- Retorna e armazena o último id da tabela fiin_rubricas\n	SET r_id_fin_rubricas = (SELECT MAX(id) FROM fin_rubricas) + 1;\n	/*para garantir a integridade da chave primária, efetua uma segunda verificação e geração de r_id_fin_rubricas, se necessário*/	\n	IF (SELECT id FROM fin_rubricas WHERE id = r_id_fin_rubricas) IS NOT NULL THEN\n		SET r_id_fin_rubricas = r_id_fin_rubricas + 1;\n	END IF;	\n	SET r_id_evento = getEventoSistema(v_dominio,CONCAT(\'Inclusão da rúbrica id: \', r_id_fin_eventos),\'actionC\', \'fin_rubricas\', r_id_fin_rubricas, v_id_user);\n	-- Insere a rúbrica\n	INSERT INTO fin_rubricas (id,slug,STATUS,dominio,evento,created_at,updated_at,\n		id_cad_servidores,id_fin_eventos,\n		ano,mes,parcela,referencia,valor_base,valor,valor_patronal,valor_maternidade,prazo,prazot,desconto,percentual) \n	VALUES(\n		r_id_fin_rubricas,SHA(CONCAT(NOW(),v_dominio,v_id_cad_servidor)),10,v_dominio,r_id_evento,UNIX_TIMESTAMP(NOW()),UNIX_TIMESTAMP(NOW()),\n		v_id_cad_servidor,r_id_fin_eventos,\n		v_ano,v_mes,v_parcela,v_referencia,0.00,r_valor,0.00,0.00,1,1,0.00,100.00\n	);\n END IF; \n /*\nSELECT v_dias_trabalhados, v_id_pccs, r_id_fin_eventos, v_d_admissao, v_anos, v_meses, v_dias, r_valor, exec, v_dias_mes;\n */\nEND','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_major','get_vcto_basico','PROCEDURE','get_vcto_basico','SQL','CONTAINS_SQL','NO','DEFINER','v_dominio VARCHAR(255),v_ano VARCHAR(4),v_mes VARCHAR(2),\nv_parcela VARCHAR(3),v_id_cad_servidor VARCHAR(255)','','BEGIN\n	DECLARE r_valor, v_valor DECIMAL(11,2);\n	DECLARE v_referencia, v_anos, v_meses, v_dias, v_i_ano_inicial, v_i_ano_final CHAR(2);\n	DECLARE v_id_referencia, v_id_pccs, v_id_vinculo, v_dias_mes, v_dias_trabalhados INT;\n	DECLARE v_d_admissao DATE; \n	DECLARE done INT DEFAULT FALSE; \n	DECLARE exec INT DEFAULT TRUE;  \n	-- obter referências\n	DECLARE cur1Referencias CURSOR FOR  \n	SELECT fin_referencias.id,/*MAX*/(fin_referencias.valor)valor, cad_classes.i_ano_inicial, cad_classes.i_ano_final \n		FROM fin_referencias \n		JOIN cad_pccs ON cad_pccs.dominio = fin_referencias.dominio \n			AND cad_pccs.id_pccs = fin_referencias.id_pccs \n		JOIN cad_classes ON cad_classes.dominio = fin_referencias.dominio \n			AND cad_classes.id_pccs = cad_pccs.id_pccs \n			AND cad_classes.id_classe = fin_referencias.id_classe \n		WHERE (cad_pccs.dominio=v_dominio) AND (fin_referencias.id_pccs=v_id_pccs) \n			AND (STR_TO_DATE(fin_referencias.data, \'%d/%m/%Y\') <= LAST_DAY(CONCAT(v_ano, \'-\', v_mes, \'-1\'))) \n			AND v_anos BETWEEN CAST(cad_classes.i_ano_inicial AS UNSIGNED) AND CAST(cad_classes.i_ano_final AS UNSIGNED)\n		-- GROUP BY cad_classes.i_ano_inicial, cad_classes.i_ano_final\n		ORDER BY fin_referencias.id_classe DESC, fin_referencias.referencia DESC\n		LIMIT 100000;\n	DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;\n	SET v_dias_mes = DATE_FORMAT(LAST_DAY(CONCAT(v_ano, \'-\', v_mes, \'-1\')), \'%d\');\n	SET v_dias_trabalhados = getDiasPagarVctoBasico(v_id_cad_servidor,v_ano,v_mes);\n	SET v_referencia = v_dias_trabalhados;\n	SET r_valor = 0;\n	-- Registra valor para: v_id_pccs, v_d_admissao, v_anos, v_meses, v_dias \n	SELECT fin_sfuncional.id_pccs,cad_sfuncional.id_vinculo,\n		/*CONCAT(SUBSTR(cad_servidores.d_admissao, 7),\'-\',SUBSTR(cad_servidores.d_admissao, 4,2),\'-\',SUBSTR(cad_servidores.d_admissao, 1,2))*/\n		STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\')data_adm,\n		TIMESTAMPDIFF(YEAR, STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\'), LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) AS anos,\n		TIMESTAMPDIFF(MONTH, STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\') + INTERVAL TIMESTAMPDIFF(YEAR,  STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\'), LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) YEAR , LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) AS meses,\n		TIMESTAMPDIFF(DAY, STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\') + INTERVAL TIMESTAMPDIFF(MONTH,  STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\'), LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) MONTH , LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) + 1 AS dias\n		INTO v_id_pccs, v_id_vinculo, v_d_admissao, v_anos, v_meses, v_dias\n		FROM cad_sfuncional\n		JOIN cad_servidores ON cad_sfuncional.id_cad_servidores = cad_servidores.id\n		JOIN fin_sfuncional ON cad_sfuncional.id_cad_servidores = fin_sfuncional.id_cad_servidores AND \n		cad_sfuncional.ano = fin_sfuncional.ano AND cad_sfuncional.mes = fin_sfuncional.mes AND\n		cad_sfuncional.parcela = fin_sfuncional.parcela\n		WHERE fin_sfuncional.ano = v_ano AND fin_sfuncional.mes = v_mes AND fin_sfuncional.parcela = v_parcela \n		AND fin_sfuncional.id_cad_servidores = v_id_cad_servidor;\n	-- Varre as referencias para localizar a correta e registrar o valor\n	OPEN cur1Referencias;\n	read_loop: LOOP\n		FETCH cur1Referencias INTO v_id_referencia, v_valor, v_i_ano_inicial, v_i_ano_final;\n		IF done THEN\n			LEAVE read_loop;\n		END IF;\n		IF !(v_anos = v_i_ano_final && (v_meses != 0 || v_dias != 0)) THEN\n			SET r_valor = ((v_valor / v_dias_mes) * v_dias_trabalhados);\n			IF v_i_ano_final != 0 AND v_i_ano_inicial != 99 THEN\n				SET done = TRUE;\n			ELSE \n				SET done = FALSE;\n			END IF;\n		END IF;\n	END LOOP;\n	CLOSE cur1Referencias;\n	-- armazena o id_fin_eventos baseado em cad_sfuncional.id_vinculo\n	IF (v_id_vinculo < 4) THEN\n		SET v_id_vinculo = (SELECT id FROM fin_eventos WHERE dominio = v_dominio AND id_evento = \'001\');\n	ELSEIF (v_id_vinculo BETWEEN 4 AND 5) THEN\n		SET v_id_vinculo = (SELECT id FROM fin_eventos WHERE dominio = v_dominio AND id_evento = \'003\');\n	ELSEIF (v_id_vinculo = 6) THEN \n		SET v_id_vinculo = (SELECT id FROM fin_eventos WHERE dominio = v_dominio AND id_evento = \'002\');\n	END IF;\n	SELECT v_id_referencia, v_dias_trabalhados, v_id_pccs, v_id_vinculo, v_d_admissao, v_anos, v_meses, v_dias, r_valor, exec, v_dias_mes;\nEND','root@localhost','2019-06-13 10:02:47','2019-06-13 10:02:47','NO_AUTO_VALUE_ON_ZERO','','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN\n	DECLARE r_valor, v_valor DECIMAL(11,2);\n	DECLARE v_referencia, v_anos, v_meses, v_dias, v_i_ano_inicial, v_i_ano_final CHAR(2);\n	DECLARE v_id_referencia, v_id_pccs, v_id_vinculo, v_dias_mes, v_dias_trabalhados INT;\n	DECLARE v_d_admissao DATE; \n	DECLARE done INT DEFAULT FALSE; \n	DECLARE exec INT DEFAULT TRUE;  \n	-- obter referências\n	DECLARE cur1Referencias CURSOR FOR  \n	SELECT fin_referencias.id,/*MAX*/(fin_referencias.valor)valor, cad_classes.i_ano_inicial, cad_classes.i_ano_final \n		FROM fin_referencias \n		JOIN cad_pccs ON cad_pccs.dominio = fin_referencias.dominio \n			AND cad_pccs.id_pccs = fin_referencias.id_pccs \n		JOIN cad_classes ON cad_classes.dominio = fin_referencias.dominio \n			AND cad_classes.id_pccs = cad_pccs.id_pccs \n			AND cad_classes.id_classe = fin_referencias.id_classe \n		WHERE (cad_pccs.dominio=v_dominio) AND (fin_referencias.id_pccs=v_id_pccs) \n			AND (STR_TO_DATE(fin_referencias.data, \'%d/%m/%Y\') <= LAST_DAY(CONCAT(v_ano, \'-\', v_mes, \'-1\'))) \n			AND v_anos BETWEEN CAST(cad_classes.i_ano_inicial AS UNSIGNED) AND CAST(cad_classes.i_ano_final AS UNSIGNED)\n		-- GROUP BY cad_classes.i_ano_inicial, cad_classes.i_ano_final\n		ORDER BY fin_referencias.id_classe DESC, fin_referencias.referencia DESC\n		LIMIT 100000;\n	DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;\n	SET v_dias_mes = DATE_FORMAT(LAST_DAY(CONCAT(v_ano, \'-\', v_mes, \'-1\')), \'%d\');\n	SET v_dias_trabalhados = getDiasPagarVctoBasico(v_id_cad_servidor,v_ano,v_mes);\n	SET v_referencia = v_dias_trabalhados;\n	SET r_valor = 0;\n	-- Registra valor para: v_id_pccs, v_d_admissao, v_anos, v_meses, v_dias \n	SELECT fin_sfuncional.id_pccs,cad_sfuncional.id_vinculo,\n		/*CONCAT(SUBSTR(cad_servidores.d_admissao, 7),\'-\',SUBSTR(cad_servidores.d_admissao, 4,2),\'-\',SUBSTR(cad_servidores.d_admissao, 1,2))*/\n		STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\')data_adm,\n		TIMESTAMPDIFF(YEAR, STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\'), LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) AS anos,\n		TIMESTAMPDIFF(MONTH, STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\') + INTERVAL TIMESTAMPDIFF(YEAR,  STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\'), LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) YEAR , LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) AS meses,\n		TIMESTAMPDIFF(DAY, STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\') + INTERVAL TIMESTAMPDIFF(MONTH,  STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\'), LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) MONTH , LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) + 1 AS dias\n		INTO v_id_pccs, v_id_vinculo, v_d_admissao, v_anos, v_meses, v_dias\n		FROM cad_sfuncional\n		JOIN cad_servidores ON cad_sfuncional.id_cad_servidores = cad_servidores.id\n		JOIN fin_sfuncional ON cad_sfuncional.id_cad_servidores = fin_sfuncional.id_cad_servidores AND \n		cad_sfuncional.ano = fin_sfuncional.ano AND cad_sfuncional.mes = fin_sfuncional.mes AND\n		cad_sfuncional.parcela = fin_sfuncional.parcela\n		WHERE fin_sfuncional.ano = v_ano AND fin_sfuncional.mes = v_mes AND fin_sfuncional.parcela = v_parcela \n		AND fin_sfuncional.id_cad_servidores = v_id_cad_servidor;\n	-- Varre as referencias para localizar a correta e registrar o valor\n	OPEN cur1Referencias;\n	read_loop: LOOP\n		FETCH cur1Referencias INTO v_id_referencia, v_valor, v_i_ano_inicial, v_i_ano_final;\n		IF done THEN\n			LEAVE read_loop;\n		END IF;\n		IF !(v_anos = v_i_ano_final && (v_meses != 0 || v_dias != 0)) THEN\n			SET r_valor = ((v_valor / v_dias_mes) * v_dias_trabalhados);\n			IF v_i_ano_final != 0 AND v_i_ano_inicial != 99 THEN\n				SET done = TRUE;\n			ELSE \n				SET done = FALSE;\n			END IF;\n		END IF;\n	END LOOP;\n	CLOSE cur1Referencias;\n	-- armazena o id_fin_eventos baseado em cad_sfuncional.id_vinculo\n	IF (v_id_vinculo < 4) THEN\n		SET v_id_vinculo = (SELECT id FROM fin_eventos WHERE dominio = v_dominio AND id_evento = \'001\');\n	ELSEIF (v_id_vinculo BETWEEN 4 AND 5) THEN\n		SET v_id_vinculo = (SELECT id FROM fin_eventos WHERE dominio = v_dominio AND id_evento = \'003\');\n	ELSEIF (v_id_vinculo = 6) THEN \n		SET v_id_vinculo = (SELECT id FROM fin_eventos WHERE dominio = v_dominio AND id_evento = \'002\');\n	END IF;\n	SELECT v_id_referencia, v_dias_trabalhados, v_id_pccs, v_id_vinculo, v_d_admissao, v_anos, v_meses, v_dias, r_valor, exec, v_dias_mes;\nEND','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_folha','getDFPcc','FUNCTION','getDFPcc','SQL','CONTAINS_SQL','NO','DEFINER','v_dominio VARCHAR(255),v_ano VARCHAR(4),v_mes VARCHAR(2),\n	v_parcela VARCHAR(3),v_id_cad_servidor VARCHAR(255)','int(11)','BEGIN\n    DECLARE v_id_cad_pccs INT(11);    \n	SELECT fin_sfuncional.id_cad_pccs\n	FROM fin_sfuncional\n	WHERE fin_sfuncional.dominio = v_dominio AND fin_sfuncional.ano = v_ano \n	AND fin_sfuncional.mes = v_mes AND fin_sfuncional.parcela = v_parcela \n	AND fin_sfuncional.id_cad_servidores = v_id_cad_servidor\n	INTO v_id_cad_pccs;\n    RETURN v_id_cad_pccs;\n    END','root@localhost','2019-06-13 10:02:41','2019-06-13 10:02:41','NO_AUTO_VALUE_ON_ZERO','','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN\n    DECLARE v_id_cad_pccs INT(11);    \n	SELECT fin_sfuncional.id_cad_pccs\n	FROM fin_sfuncional\n	WHERE fin_sfuncional.dominio = v_dominio AND fin_sfuncional.ano = v_ano \n	AND fin_sfuncional.mes = v_mes AND fin_sfuncional.parcela = v_parcela \n	AND fin_sfuncional.id_cad_servidores = v_id_cad_servidor\n	INTO v_id_cad_pccs;\n    RETURN v_id_cad_pccs;\n    END','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_folha','getFinRubricaPrazo','FUNCTION','getFinRubricaPrazo','SQL','CONTAINS_SQL','NO','DEFINER','prazo int, prazot int','int(11)','BEGIN\n	declare prazo_final int(3); -- prazo a retornar\n	if prazot = prazo then\n		set prazo_final = prazo;\n	elseIF prazot > prazo THEN\n		SET prazo_final = prazo + 1;\n	end if;\n	return prazo_final;\n    END','root@localhost','2019-06-13 10:02:41','2019-06-13 10:02:41','NO_AUTO_VALUE_ON_ZERO','Retorna o prazo inicial baseado nos prazos inicial e final passados','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN\n	declare prazo_final int(3); -- prazo a retornar\n	if prazot = prazo then\n		set prazo_final = prazo;\n	elseIF prazot > prazo THEN\n		SET prazo_final = prazo + 1;\n	end if;\n	return prazo_final;\n    END','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_folha','getFinRubricaPrazoT','FUNCTION','getFinRubricaPrazoT','SQL','CONTAINS_SQL','NO','DEFINER','prazo int, prazot int','int(11)','BEGIN\n	declare prazo_final int(3); -- prazo a retornar\n	if (prazot = prazo) && ((prazot = \'999\') || (prazot = \'1\')) then\n		set prazo_final = prazot;\n	elseIF prazot > prazo THEN\n		SET prazo_final = prazo + 1;\n	end if;\n	return prazo_final;\n    END','root@localhost','2019-06-13 10:02:41','2019-06-13 10:02:41','NO_AUTO_VALUE_ON_ZERO','Retorna o prazo final baseado nos prazos inicial e final passados','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN\n	declare prazo_final int(3); -- prazo a retornar\n	if (prazot = prazo) && ((prazot = \'999\') || (prazot = \'1\')) then\n		set prazo_final = prazot;\n	elseIF prazot > prazo THEN\n		SET prazo_final = prazo + 1;\n	end if;\n	return prazo_final;\n    END','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_folha','getIdVinculo','FUNCTION','getIdVinculo','SQL','CONTAINS_SQL','YES','DEFINER','v_dominio VARCHAR(255),v_id_vinculo INT','int(11)','BEGIN\n	DECLARE r_id_vinculo INT;\n	IF (v_id_vinculo < 4) THEN\n		SET r_id_vinculo = (SELECT id FROM fin_eventos WHERE dominio = v_dominio AND id_evento = \'001\');\n	ELSEIF (v_id_vinculo BETWEEN 4 AND 5) THEN\n		SET r_id_vinculo = (SELECT id FROM fin_eventos WHERE dominio = v_dominio AND id_evento = \'003\');\n	ELSEIF (v_id_vinculo = 6) THEN \n		SET r_id_vinculo = (SELECT id FROM fin_eventos WHERE dominio = v_dominio AND id_evento = \'002\');\n	ELSE \n		SET r_id_vinculo = 0;\n	END IF;\n	RETURN r_id_vinculo;\n    END','root@localhost','2019-06-13 10:02:41','2019-06-13 10:02:41','NO_AUTO_VALUE_ON_ZERO','Retorna o id_fin_eventos baseado em cad_sfuncional.id_vinculo','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN\n	DECLARE r_id_vinculo INT;\n	IF (v_id_vinculo < 4) THEN\n		SET r_id_vinculo = (SELECT id FROM fin_eventos WHERE dominio = v_dominio AND id_evento = \'001\');\n	ELSEIF (v_id_vinculo BETWEEN 4 AND 5) THEN\n		SET r_id_vinculo = (SELECT id FROM fin_eventos WHERE dominio = v_dominio AND id_evento = \'003\');\n	ELSEIF (v_id_vinculo = 6) THEN \n		SET r_id_vinculo = (SELECT id FROM fin_eventos WHERE dominio = v_dominio AND id_evento = \'002\');\n	ELSE \n		SET r_id_vinculo = 0;\n	END IF;\n	RETURN r_id_vinculo;\n    END','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_folha','getSFalecimento','FUNCTION','getSFalecimento','SQL','CONTAINS_SQL','NO','DEFINER','v_id_cad_servidores INT','int(11)','BEGIN	\n	declare quant int;\n	SELECT COUNT(*)\n		FROM `cad_smovimentacao` \n		WHERE (`id_cad_servidores`=v_id_cad_servidores) \n		AND ((`codigo_afastamento`=\'S2\') OR (`codigo_afastamento`=\'S3\')) into quant;\n	return quant;\n    END','root@localhost','2019-06-13 10:02:41','2019-06-13 10:02:41','NO_AUTO_VALUE_ON_ZERO','Retorna um model caso o servidor esteja falecido ou null caso não esteja','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN	\n	declare quant int;\n	SELECT COUNT(*)\n		FROM `cad_smovimentacao` \n		WHERE (`id_cad_servidores`=v_id_cad_servidores) \n		AND ((`codigo_afastamento`=\'S2\') OR (`codigo_afastamento`=\'S3\')) into quant;\n	return quant;\n    END','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_folha','getCodAfastamento','FUNCTION','getCodAfastamento','SQL','CONTAINS_SQL','YES','DEFINER','v VARCHAR(2)','varchar(500) CHARSET latin1','BEGIN\n	DECLARE RETORNO VARCHAR(500);\n	SET RETORNO = CASE v\n		WHEN \'Q1\' THEN \'Q1 - AFASTAMENTO TEMPORÁRIO POR MOTIVO DE LICENÇA-MATERNIDADE (120 DIAS)\'\n		WHEN \'X\' THEN \'X - LICENÇA SEM VENCIMENTOS\'\n		WHEN \'P1\' THEN \'P1 - AFASTAMENTO TEMPORÁRIO POR MOTIVO DE DOENÇA, POR PERÍODO SUPERIOR A 15 DIAS\'\n		WHEN \'H\' THEN \'H  - RESCISÃO, COM JUSTA CAUSA, POR INICIATIVA DO EMPREGADOR\'\n		WHEN \'I1\' THEN \'I1 - RESCISÃO SEM JUSTA CAUSA, POR INICIATIVA DO EMPREGADOR, INCLUSIVE RESCISÃO ANTECIPADA DO CONTRATO A TERMO\'\n		WHEN \'I2\' THEN \'I2 - RESCISÃO POR CULPA RECÍPROCA OU FORÇA MAIOR\'\n		WHEN \'I3\' THEN \'I3 - RESCISÃO POR TÉRMINO DO CONTRATO A TERMO\'\n		WHEN \'I4\' THEN \'I4 - RESCISÃO SEM JUSTA CAUSA DO CONTRATO DE TRABALHO DO EMPREGADO DOMÉSTICO, POR INICIATIVA DO EMPREGADOR\'\n		WHEN \'J\' THEN \'J  - RESCISÃO DO CONTRATO DE TRABALHO POR INICIATIVA DO EMPREGADO\'\n		WHEN \'K\' THEN \'K  - RESCISÃO A PEDIDO DO EMPREGADO OU POR INICIATIVA DO EMPREGADOR, COM JUSTA CAUSA, NO CASO DE EMPREGADO NÃO OPTANTE, COM MENOS DE UM ANO DE SERVIÇO\'\n		WHEN \'L\' THEN \'L  - OUTROS MOTIVOS DE RESCISÃO DO CONTRATO DE TRABALHO\'\n		WHEN \'S2\' THEN \'S2 - FALECIMENTO\'\n		WHEN \'S3\' THEN \'S3 - FALECIMENTO MOTIVADO POR ACIDENTE DE TRABALHO\'\n		WHEN \'U1\' THEN \'U1 - APOSENTADORIA\'\n		WHEN \'U3\' THEN \'U3 - APOSENTADORIA POR INVALIDEZ\' \n		ELSE NULL END;\n	RETURN RETORNO;\n    END','root@localhost','2019-06-13 10:02:41','2019-06-13 10:02:41','NO_AUTO_VALUE_ON_ZERO','','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN\n	DECLARE RETORNO VARCHAR(500);\n	SET RETORNO = CASE v\n		WHEN \'Q1\' THEN \'Q1 - AFASTAMENTO TEMPORÁRIO POR MOTIVO DE LICENÇA-MATERNIDADE (120 DIAS)\'\n		WHEN \'X\' THEN \'X - LICENÇA SEM VENCIMENTOS\'\n		WHEN \'P1\' THEN \'P1 - AFASTAMENTO TEMPORÁRIO POR MOTIVO DE DOENÇA, POR PERÍODO SUPERIOR A 15 DIAS\'\n		WHEN \'H\' THEN \'H  - RESCISÃO, COM JUSTA CAUSA, POR INICIATIVA DO EMPREGADOR\'\n		WHEN \'I1\' THEN \'I1 - RESCISÃO SEM JUSTA CAUSA, POR INICIATIVA DO EMPREGADOR, INCLUSIVE RESCISÃO ANTECIPADA DO CONTRATO A TERMO\'\n		WHEN \'I2\' THEN \'I2 - RESCISÃO POR CULPA RECÍPROCA OU FORÇA MAIOR\'\n		WHEN \'I3\' THEN \'I3 - RESCISÃO POR TÉRMINO DO CONTRATO A TERMO\'\n		WHEN \'I4\' THEN \'I4 - RESCISÃO SEM JUSTA CAUSA DO CONTRATO DE TRABALHO DO EMPREGADO DOMÉSTICO, POR INICIATIVA DO EMPREGADOR\'\n		WHEN \'J\' THEN \'J  - RESCISÃO DO CONTRATO DE TRABALHO POR INICIATIVA DO EMPREGADO\'\n		WHEN \'K\' THEN \'K  - RESCISÃO A PEDIDO DO EMPREGADO OU POR INICIATIVA DO EMPREGADOR, COM JUSTA CAUSA, NO CASO DE EMPREGADO NÃO OPTANTE, COM MENOS DE UM ANO DE SERVIÇO\'\n		WHEN \'L\' THEN \'L  - OUTROS MOTIVOS DE RESCISÃO DO CONTRATO DE TRABALHO\'\n		WHEN \'S2\' THEN \'S2 - FALECIMENTO\'\n		WHEN \'S3\' THEN \'S3 - FALECIMENTO MOTIVADO POR ACIDENTE DE TRABALHO\'\n		WHEN \'U1\' THEN \'U1 - APOSENTADORIA\'\n		WHEN \'U3\' THEN \'U3 - APOSENTADORIA POR INVALIDEZ\' \n		ELSE NULL END;\n	RETURN RETORNO;\n    END','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_folha','getEventoSistema','FUNCTION','getEventoSistema','SQL','CONTAINS_SQL','NO','DEFINER','v_dominio VARCHAR(255),v_evento TEXT, \n	v_classevento VARCHAR(255), v_tabela_bd VARCHAR(255), v_id_registro INT(11), v_id_user INT(11)','int(11)','BEGIN\n		DECLARE id_evento INT(11);\n		DECLARE ip, geo_td, geo_ln VARCHAR(255);\n		SELECT er.ip,er.geo_lt,er.geo_ln INTO ip, geo_td, geo_ln FROM eventos er WHERE er.id_user = v_id_user ORDER BY er.id DESC LIMIT 1;\n		-- SET id_evento = (SELECT MAX(id) FROM eventos);\n		INSERT INTO megasses_folha.eventos (\n			id,slug,STATUS,dominio,evento,classevento,tabela_bd,id_registro,\n			ip,geo_lt,geo_ln,id_user,username,data_registro,created_at,updated_at\n		) VALUES (\n			null,SHA(CONCAT(UNIX_TIMESTAMP(NOW()),v_dominio,v_evento,v_classevento)),10,v_dominio,v_evento,v_classevento,v_tabela_bd,v_id_registro,\n			ip, geo_td, geo_ln,\n			v_id_user,(SELECT username FROM megasses_folha.user WHERE id = v_id_user),FROM_UNIXTIME(NOW()),UNIX_TIMESTAMP(NOW()),UNIX_TIMESTAMP(NOW())\n		);\n		return (SELECT MAX(id) FROM eventos);\n	END','root@localhost','2019-06-13 10:02:41','2019-06-13 10:02:41','NO_AUTO_VALUE_ON_ZERO','Auxilia no registro de um evento de sistema','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN\n		DECLARE id_evento INT(11);\n		DECLARE ip, geo_td, geo_ln VARCHAR(255);\n		SELECT er.ip,er.geo_lt,er.geo_ln INTO ip, geo_td, geo_ln FROM eventos er WHERE er.id_user = v_id_user ORDER BY er.id DESC LIMIT 1;\n		-- SET id_evento = (SELECT MAX(id) FROM eventos);\n		INSERT INTO megasses_folha.eventos (\n			id,slug,STATUS,dominio,evento,classevento,tabela_bd,id_registro,\n			ip,geo_lt,geo_ln,id_user,username,data_registro,created_at,updated_at\n		) VALUES (\n			null,SHA(CONCAT(UNIX_TIMESTAMP(NOW()),v_dominio,v_evento,v_classevento)),10,v_dominio,v_evento,v_classevento,v_tabela_bd,v_id_registro,\n			ip, geo_td, geo_ln,\n			v_id_user,(SELECT username FROM megasses_folha.user WHERE id = v_id_user),FROM_UNIXTIME(NOW()),UNIX_TIMESTAMP(NOW()),UNIX_TIMESTAMP(NOW())\n		);\n		return (SELECT MAX(id) FROM eventos);\n	END','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_folha','getDiasPagarVctoBasico','FUNCTION','getDiasPagarVctoBasico','SQL','CONTAINS_SQL','YES','DEFINER','ics INT(11),ano_f CHAR(4),mes_f CHAR(2)','varchar(255) CHARSET latin1','BEGIN\n    DECLARE dias/*dias do período de cálculo*/\n    , dias_p/*CONSTANTE: dias antes de ir para previdência*/ INT(2);\n    DECLARE d_afastamento, d_limite/*data limite antes de ir para previdência*/\n    , d_admissao/*data de admissao*/\n    , d_retorno/*data do retorno*/\n    , udm0 /*último dia do mês anterior*/\n    , udm1 /*último dia do mês atual*/ DATE;\n    DECLARE codigo_afastamento VARCHAR(2);\n    DECLARE r VARCHAR(255);\n    -- dias de afastamento em que a autarquia paga antes de ir para previdência\n    SET dias_p = 15;\n    -- último dia do mês anterior\n    SET udm0 = LAST_DAY(DATE_SUB(CAST(CONCAT(ano_f,\'-\',mes_f,\'-01\') AS DATE), INTERVAL 1 MONTH));\n    -- último dia do mês atual\n    SET udm1 = LAST_DAY(CAST(CONCAT(ano_f,\'-\',mes_f,\'-01\') AS DATE));\n	SELECT STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\') AS d_admissao,	\n		STR_TO_DATE(cad_smovimentacao.d_afastamento, \'%d/%m/%Y\') AS d_afastamento,\n		STR_TO_DATE(cad_smovimentacao.d_retorno, \'%d/%m/%Y\') AS d_retorno,\n		cad_smovimentacao.codigo_afastamento AS codigo_afastamento\n		FROM cad_servidores\n		LEFT JOIN cad_smovimentacao ON cad_servidores.id = cad_smovimentacao.id_cad_servidores \n			AND cad_servidores.dominio = cad_smovimentacao.dominio\n		WHERE cad_servidores.id = ics\n		ORDER BY STR_TO_DATE(cad_smovimentacao.d_afastamento, \'%d/%m/%Y\') DESC\n		LIMIT 1 \n		INTO d_admissao, d_afastamento, d_retorno, codigo_afastamento;\n	IF codigo_afastamento = \'P1\' /*calculo dos dias em caso de afastamento temporário\n		por motivo de doença, por período superior à variável dias_p*/ THEN		\n		SET dias = DAY(d_afastamento) + dias_p;\n		SET d_limite = DATE_ADD(d_afastamento, INTERVAL dias_p DAY);\n		/*Se a data limite(afastamento) for posterior ou igual ao último dia do mês atual*/\n		IF d_limite >= udm1 THEN\n			/*dias a pagar é igual ao total de dias do mês atual pois \n			ou estourou o mês ou o final do prazo acaba no último dia*/\n			SET dias = DAY(udm1);\n			SET r = \'0\';\n		/*Se a data limite for anterior ao último dia do mês atual e o periodo for o mesmo*/\n		ELSEIF d_limite < udm1 AND \n		CONCAT(YEAR(d_limite),MONTH(d_limite)) = CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = DAY(d_limite);\n			SET r = \'1\';\n		/*Se a data limite for anterior ao último dia do mês atual e o periodo for outro*/\n		ELSEIF d_limite < udm1 AND \n		CONCAT(YEAR(d_limite),MONTH(d_limite)) != CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = 0;\n			SET r = \'2\';\n		END IF;\n		/*Adicionar os dias após o retorno à variável dias acima*/\n		/*Se a data de retorno for registrada e for no mês corrente(atual)*/\n		IF d_retorno IS NOT NULL \n		AND CONCAT(YEAR(d_retorno),MONTH(d_retorno)) = CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = dias + DATEDIFF(udm1,d_retorno);\n			SET r = \'3\';\n		ELSEIF d_retorno IS NOT NULL AND d_retorno < udm1 THEN\n			SET dias = DAY(udm1);\n			SET r = \'4\';\n		END IF;\n	ELSEIF codigo_afastamento = \'X\' /*calculo dos dias em caso de licença sem vencimento*/ THEN		\n		SET dias = DAY(d_afastamento);\n		SET d_limite = d_afastamento;\n		/*Se a data limite(afastamento) for posterior ou igual ao último dia do mês atual*/\n		IF d_limite >= udm1 THEN\n			/*dias a pagar é igual ao total de dias do mês atual pois \n			ou estourou o mês ou o final do prazo acaba no último dia*/\n			SET dias = DAY(udm1);\n			SET r = \'5\';\n		/*Se a data limite for anterior ao último dia do mês atual e o periodo for o mesmo*/\n		ELSEIF d_limite < udm1 AND \n		CONCAT(YEAR(d_limite),MONTH(d_limite)) = CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = DAY(d_limite);\n			SET r = \'6\';\n		/*Se a data limite for anterior ao último dia do mês atual e o periodo for outro*/\n		ELSEIF d_limite < udm1 AND \n		CONCAT(YEAR(d_limite),MONTH(d_limite)) != CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = 0;\n			SET r = \'7\';\n		END IF;\n		SET d_retorno = DATE_SUB(d_retorno, INTERVAL 1 DAY);\n		/*Adicionar os dias após o retorno à variável dias acima*/\n		/*Se a data de retorno for registrada e for no mês corrente(atual)*/\n		IF d_retorno IS NOT NULL \n		AND CONCAT(YEAR(d_retorno),MONTH(d_retorno)) = CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = dias + DATEDIFF(udm1,d_retorno);\n			SET r = \'8\';\n		ELSEIF d_retorno IS NOT NULL AND d_retorno < udm1 THEN\n			SET dias = DAY(udm1);\n			SET r = \'9\';\n		END IF;\n	ELSEIF codigo_afastamento = \'Q1\' /*calculo dos dias em caso de licença maternidade*/ THEN		\n		SET dias = DAY(d_afastamento);\n		SET d_limite = d_afastamento;\n		/*Se a data limite(afastamento) for posterior ao último dia do mês atual*/\n		IF d_limite > udm1 THEN\n			/*dias a pagar é igual ao total de dias do mês atual pois \n			a servidora ainda não saiu de licença*/\n			SET dias = DAY(udm1);\n			SET r = \'Q1:0\';\n		/*Se a data limite for anterior ao último dia do mês atual e o periodo for o mesmo*/\n		ELSEIF d_limite < udm1 AND \n		CONCAT(YEAR(d_limite),MONTH(d_limite)) = CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = DAY(d_limite) - 1;\n			SET r = \'Q1:1\';\n		/*Se a data limite for anterior ao último dia do mês atual e o periodo for outro*/\n		ELSEIF d_limite < udm1 AND \n		CONCAT(YEAR(d_limite),MONTH(d_limite)) != CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = 0;\n			SET r = \'Q1:2\';\n		END IF;\n		/*Adicionar os dias após o retorno à variável dias acima*/\n		/*Se a data de retorno for registrada e for no mês corrente(atual)*/\n		IF d_retorno IS NOT NULL \n		AND CONCAT(YEAR(d_retorno),MONTH(d_retorno)) = CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = dias + DATEDIFF(udm1,d_retorno);\n			SET r = \'Q1:3\';\n		/*Se a data de retorno é anterior ao primeiro dia do mês */\n		ELSEIF d_retorno IS NOT NULL AND d_retorno < ADDDATE(LAST_DAY(DATE_SUB(udm1, INTERVAL 1 MONTH)),1) THEN\n			SET dias = DAY(udm1);\n			SET r = \'Q1:4\';\n		END IF;\n	ELSEIF codigo_afastamento IS NOT NULL && codigo_afastamento != \'P1\'\n	 && codigo_afastamento != \'Q1\' && codigo_afastamento != \'X\' /*calculo dos dias em caso de demissão*/ THEN		\n		SET dias = DAY(d_afastamento);\n		SET d_limite = d_afastamento;\n		/*Se a data limite(afastamento) for posterior ou igual ao último dia do mês atual*/\n		IF d_limite > udm1 THEN\n			/*dias a pagar é igual ao total de dias do mês atual pois \n			pertence a outro período*/\n			SET dias = DAY(udm1);\n			SET r = \'Demiss0\';\n		/*Se a data limite for anterior ou igual ao último dia do mês atual e o periodo for o mesmo*/\n		ELSEIF d_limite <= udm1 AND \n		CONCAT(YEAR(d_limite),MONTH(d_limite)) = CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = DAY(d_limite);\n			SET r = \'Demiss1\';\n		/*Se a data limite for anterior ao último dia do mês atual e o periodo for outro*/\n		ELSEIF d_limite < udm1 AND \n		CONCAT(YEAR(d_limite),MONTH(d_limite)) != CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = 0;\n			SET r = \'Demiss2\';\n		END IF;\n	ELSEIF LAST_DAY(d_admissao) = udm1 THEN\n	/*calculo dos dias em caso de admissão no periodo informado*/\n		SET dias = DAY(udm1) - DAY(d_admissao) + 1;\n		SET r = \'10\';\n	ELSE\n	/*caso não atenda nenhuma das situações acima*/\n		SET dias = DAY(udm1);\n		SET r = \'11\';\n	END IF;\n	\nRETURN dias;-- concat(\'da: \',d_afastamento,\' > ca: \',codigo_afastamento,\' > dl: \',d_limite,\' > pos: \',r,\' > dias: \',dias);\nEND','root@localhost','2019-06-13 10:02:41','2019-06-13 10:02:41','NO_AUTO_VALUE_ON_ZERO','','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN\n    DECLARE dias/*dias do período de cálculo*/\n    , dias_p/*CONSTANTE: dias antes de ir para previdência*/ INT(2);\n    DECLARE d_afastamento, d_limite/*data limite antes de ir para previdência*/\n    , d_admissao/*data de admissao*/\n    , d_retorno/*data do retorno*/\n    , udm0 /*último dia do mês anterior*/\n    , udm1 /*último dia do mês atual*/ DATE;\n    DECLARE codigo_afastamento VARCHAR(2);\n    DECLARE r VARCHAR(255);\n    -- dias de afastamento em que a autarquia paga antes de ir para previdência\n    SET dias_p = 15;\n    -- último dia do mês anterior\n    SET udm0 = LAST_DAY(DATE_SUB(CAST(CONCAT(ano_f,\'-\',mes_f,\'-01\') AS DATE), INTERVAL 1 MONTH));\n    -- último dia do mês atual\n    SET udm1 = LAST_DAY(CAST(CONCAT(ano_f,\'-\',mes_f,\'-01\') AS DATE));\n	SELECT STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\') AS d_admissao,	\n		STR_TO_DATE(cad_smovimentacao.d_afastamento, \'%d/%m/%Y\') AS d_afastamento,\n		STR_TO_DATE(cad_smovimentacao.d_retorno, \'%d/%m/%Y\') AS d_retorno,\n		cad_smovimentacao.codigo_afastamento AS codigo_afastamento\n		FROM cad_servidores\n		LEFT JOIN cad_smovimentacao ON cad_servidores.id = cad_smovimentacao.id_cad_servidores \n			AND cad_servidores.dominio = cad_smovimentacao.dominio\n		WHERE cad_servidores.id = ics\n		ORDER BY STR_TO_DATE(cad_smovimentacao.d_afastamento, \'%d/%m/%Y\') DESC\n		LIMIT 1 \n		INTO d_admissao, d_afastamento, d_retorno, codigo_afastamento;\n	IF codigo_afastamento = \'P1\' /*calculo dos dias em caso de afastamento temporário\n		por motivo de doença, por período superior à variável dias_p*/ THEN		\n		SET dias = DAY(d_afastamento) + dias_p;\n		SET d_limite = DATE_ADD(d_afastamento, INTERVAL dias_p DAY);\n		/*Se a data limite(afastamento) for posterior ou igual ao último dia do mês atual*/\n		IF d_limite >= udm1 THEN\n			/*dias a pagar é igual ao total de dias do mês atual pois \n			ou estourou o mês ou o final do prazo acaba no último dia*/\n			SET dias = DAY(udm1);\n			SET r = \'0\';\n		/*Se a data limite for anterior ao último dia do mês atual e o periodo for o mesmo*/\n		ELSEIF d_limite < udm1 AND \n		CONCAT(YEAR(d_limite),MONTH(d_limite)) = CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = DAY(d_limite);\n			SET r = \'1\';\n		/*Se a data limite for anterior ao último dia do mês atual e o periodo for outro*/\n		ELSEIF d_limite < udm1 AND \n		CONCAT(YEAR(d_limite),MONTH(d_limite)) != CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = 0;\n			SET r = \'2\';\n		END IF;\n		/*Adicionar os dias após o retorno à variável dias acima*/\n		/*Se a data de retorno for registrada e for no mês corrente(atual)*/\n		IF d_retorno IS NOT NULL \n		AND CONCAT(YEAR(d_retorno),MONTH(d_retorno)) = CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = dias + DATEDIFF(udm1,d_retorno);\n			SET r = \'3\';\n		ELSEIF d_retorno IS NOT NULL AND d_retorno < udm1 THEN\n			SET dias = DAY(udm1);\n			SET r = \'4\';\n		END IF;\n	ELSEIF codigo_afastamento = \'X\' /*calculo dos dias em caso de licença sem vencimento*/ THEN		\n		SET dias = DAY(d_afastamento);\n		SET d_limite = d_afastamento;\n		/*Se a data limite(afastamento) for posterior ou igual ao último dia do mês atual*/\n		IF d_limite >= udm1 THEN\n			/*dias a pagar é igual ao total de dias do mês atual pois \n			ou estourou o mês ou o final do prazo acaba no último dia*/\n			SET dias = DAY(udm1);\n			SET r = \'5\';\n		/*Se a data limite for anterior ao último dia do mês atual e o periodo for o mesmo*/\n		ELSEIF d_limite < udm1 AND \n		CONCAT(YEAR(d_limite),MONTH(d_limite)) = CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = DAY(d_limite);\n			SET r = \'6\';\n		/*Se a data limite for anterior ao último dia do mês atual e o periodo for outro*/\n		ELSEIF d_limite < udm1 AND \n		CONCAT(YEAR(d_limite),MONTH(d_limite)) != CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = 0;\n			SET r = \'7\';\n		END IF;\n		SET d_retorno = DATE_SUB(d_retorno, INTERVAL 1 DAY);\n		/*Adicionar os dias após o retorno à variável dias acima*/\n		/*Se a data de retorno for registrada e for no mês corrente(atual)*/\n		IF d_retorno IS NOT NULL \n		AND CONCAT(YEAR(d_retorno),MONTH(d_retorno)) = CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = dias + DATEDIFF(udm1,d_retorno);\n			SET r = \'8\';\n		ELSEIF d_retorno IS NOT NULL AND d_retorno < udm1 THEN\n			SET dias = DAY(udm1);\n			SET r = \'9\';\n		END IF;\n	ELSEIF codigo_afastamento = \'Q1\' /*calculo dos dias em caso de licença maternidade*/ THEN		\n		SET dias = DAY(d_afastamento);\n		SET d_limite = d_afastamento;\n		/*Se a data limite(afastamento) for posterior ao último dia do mês atual*/\n		IF d_limite > udm1 THEN\n			/*dias a pagar é igual ao total de dias do mês atual pois \n			a servidora ainda não saiu de licença*/\n			SET dias = DAY(udm1);\n			SET r = \'Q1:0\';\n		/*Se a data limite for anterior ao último dia do mês atual e o periodo for o mesmo*/\n		ELSEIF d_limite < udm1 AND \n		CONCAT(YEAR(d_limite),MONTH(d_limite)) = CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = DAY(d_limite) - 1;\n			SET r = \'Q1:1\';\n		/*Se a data limite for anterior ao último dia do mês atual e o periodo for outro*/\n		ELSEIF d_limite < udm1 AND \n		CONCAT(YEAR(d_limite),MONTH(d_limite)) != CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = 0;\n			SET r = \'Q1:2\';\n		END IF;\n		/*Adicionar os dias após o retorno à variável dias acima*/\n		/*Se a data de retorno for registrada e for no mês corrente(atual)*/\n		IF d_retorno IS NOT NULL \n		AND CONCAT(YEAR(d_retorno),MONTH(d_retorno)) = CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = dias + DATEDIFF(udm1,d_retorno);\n			SET r = \'Q1:3\';\n		/*Se a data de retorno é anterior ao primeiro dia do mês */\n		ELSEIF d_retorno IS NOT NULL AND d_retorno < ADDDATE(LAST_DAY(DATE_SUB(udm1, INTERVAL 1 MONTH)),1) THEN\n			SET dias = DAY(udm1);\n			SET r = \'Q1:4\';\n		END IF;\n	ELSEIF codigo_afastamento IS NOT NULL && codigo_afastamento != \'P1\'\n	 && codigo_afastamento != \'Q1\' && codigo_afastamento != \'X\' /*calculo dos dias em caso de demissão*/ THEN		\n		SET dias = DAY(d_afastamento);\n		SET d_limite = d_afastamento;\n		/*Se a data limite(afastamento) for posterior ou igual ao último dia do mês atual*/\n		IF d_limite > udm1 THEN\n			/*dias a pagar é igual ao total de dias do mês atual pois \n			pertence a outro período*/\n			SET dias = DAY(udm1);\n			SET r = \'Demiss0\';\n		/*Se a data limite for anterior ou igual ao último dia do mês atual e o periodo for o mesmo*/\n		ELSEIF d_limite <= udm1 AND \n		CONCAT(YEAR(d_limite),MONTH(d_limite)) = CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = DAY(d_limite);\n			SET r = \'Demiss1\';\n		/*Se a data limite for anterior ao último dia do mês atual e o periodo for outro*/\n		ELSEIF d_limite < udm1 AND \n		CONCAT(YEAR(d_limite),MONTH(d_limite)) != CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = 0;\n			SET r = \'Demiss2\';\n		END IF;\n	ELSEIF LAST_DAY(d_admissao) = udm1 THEN\n	/*calculo dos dias em caso de admissão no periodo informado*/\n		SET dias = DAY(udm1) - DAY(d_admissao) + 1;\n		SET r = \'10\';\n	ELSE\n	/*caso não atenda nenhuma das situações acima*/\n		SET dias = DAY(udm1);\n		SET r = \'11\';\n	END IF;\n	\nRETURN dias;-- concat(\'da: \',d_afastamento,\' > ca: \',codigo_afastamento,\' > dl: \',d_limite,\' > pos: \',r,\' > dias: \',dias);\nEND','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_folha','get_eventos_percentual','PROCEDURE','get_eventos_percentual','SQL','CONTAINS_SQL','NO','DEFINER','v_dominio VARCHAR(255),v_id_eventos INT','','BEGIN\n	SELECT id, slug, id_eventos_percentual, percentual, `data` FROM fin_eventospercentual WHERE id_fin_eventos = v_id_eventos AND dominio = v_dominio;\n    END','root@localhost','2019-06-13 10:02:41','2019-06-13 10:02:41','NO_AUTO_VALUE_ON_ZERO','','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN\n	SELECT id, slug, id_eventos_percentual, percentual, `data` FROM fin_eventospercentual WHERE id_fin_eventos = v_id_eventos AND dominio = v_dominio;\n    END','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_folha','fin_folha_eventos','PROCEDURE','fin_folha_eventos','SQL','CONTAINS_SQL','NO','DEFINER','v_id_user INT(11), v_dominio VARCHAR(255),v_ano VARCHAR(4),v_mes VARCHAR(2),v_parcela VARCHAR(3)','','BEGIN \nDECLARE done INT DEFAULT FALSE; \nDECLARE v_id_cad_servidor INT; \nDECLARE cur1 CURSOR FOR \nSELECT fin_sfuncional.id_cad_servidores \n	FROM fin_sfuncional \n	JOIN cad_servidores ON cad_servidores.id = fin_sfuncional.id_cad_servidores \n	WHERE fin_sfuncional.dominio = v_dominio AND fin_sfuncional.ano = v_ano \n	AND fin_sfuncional.mes = v_mes AND fin_sfuncional.parcela = v_parcela AND fin_sfuncional.situacao = 1 \n	AND fin_sfuncional.situacaofuncional >= 1 AND (fin_sfuncional.id_pccs IS NOT NULL AND fin_sfuncional.id_pccs > 0) \n	AND fin_sfuncional.lanca_salario = 1\n	ORDER BY cad_servidores.id; \nDECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE; \nDELETE FROM fin_rubricas WHERE dominio = v_dominio \n	AND ano = v_ano AND mes = v_mes AND parcela = v_parcela; \nOPEN cur1; \nread_loop: LOOP FETCH cur1 INTO v_id_cad_servidor; \n	IF done THEN \n		LEAVE read_loop; \n	END IF; \n	-- Geração dos eventos básicos 2,3 e 40 (001,002,003) da folha\n	CALL fin_folha_ev_basico(v_id_user,v_dominio,v_ano,v_mes,v_parcela,v_id_cad_servidor); \nEND LOOP; \nCLOSE cur1; \n/**\nAs operações abaixo foram deslocadas para suas próprias chamadas dentro de main.php\nCALL fin_folha_eventos_recorrentes(v_id_user,v_dominio,v_ano,v_mes,v_parcela); \nCALL fin_folha_eventos_parcelados(v_id_user,v_dominio,v_ano,v_mes,v_parcela); \n*/\nEND','root@localhost','2019-06-13 10:02:41','2019-06-13 10:02:41','NO_AUTO_VALUE_ON_ZERO','','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN \nDECLARE done INT DEFAULT FALSE; \nDECLARE v_id_cad_servidor INT; \nDECLARE cur1 CURSOR FOR \nSELECT fin_sfuncional.id_cad_servidores \n	FROM fin_sfuncional \n	JOIN cad_servidores ON cad_servidores.id = fin_sfuncional.id_cad_servidores \n	WHERE fin_sfuncional.dominio = v_dominio AND fin_sfuncional.ano = v_ano \n	AND fin_sfuncional.mes = v_mes AND fin_sfuncional.parcela = v_parcela AND fin_sfuncional.situacao = 1 \n	AND fin_sfuncional.situacaofuncional >= 1 AND (fin_sfuncional.id_pccs IS NOT NULL AND fin_sfuncional.id_pccs > 0) \n	AND fin_sfuncional.lanca_salario = 1\n	ORDER BY cad_servidores.id; \nDECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE; \nDELETE FROM fin_rubricas WHERE dominio = v_dominio \n	AND ano = v_ano AND mes = v_mes AND parcela = v_parcela; \nOPEN cur1; \nread_loop: LOOP FETCH cur1 INTO v_id_cad_servidor; \n	IF done THEN \n		LEAVE read_loop; \n	END IF; \n	-- Geração dos eventos básicos 2,3 e 40 (001,002,003) da folha\n	CALL fin_folha_ev_basico(v_id_user,v_dominio,v_ano,v_mes,v_parcela,v_id_cad_servidor); \nEND LOOP; \nCLOSE cur1; \n/**\nAs operações abaixo foram deslocadas para suas próprias chamadas dentro de main.php\nCALL fin_folha_eventos_recorrentes(v_id_user,v_dominio,v_ano,v_mes,v_parcela); \nCALL fin_folha_eventos_parcelados(v_id_user,v_dominio,v_ano,v_mes,v_parcela); \n*/\nEND','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_folha','fin_folha_eventos_consignados','PROCEDURE','fin_folha_eventos_consignados','SQL','CONTAINS_SQL','NO','DEFINER','\nv_id_user INT(11),v_dominio VARCHAR(255),v_ano VARCHAR(4),v_mes VARCHAR(2),v_parcela VARCHAR(3)','','BEGIN\n	DECLARE done INT DEFAULT FALSE;\n	DECLARE r_id_fin_rubricas,r_id_cad_servidores,r_id_fin_eventos,r_prazo,r_prazot,r_id_evento INT(11);\n	DECLARE r_slug,r_referencia,r_valor_base,r_valor,r_valor_patronal,\n			r_valor_maternidade,r_desconto,r_percentual VARCHAR(255);	 \n	-- obter referências\n	DECLARE cur1Referencias CURSOR FOR  \n		SELECT fin_rubricas.id_cad_servidores,fin_rubricas.id_fin_eventos,\n			fin_rubricas.referencia,fin_rubricas.valor_base,fin_rubricas.valor,fin_rubricas.valor_patronal,\n			fin_rubricas.valor_maternidade,fin_rubricas.desconto,fin_rubricas.percentual,\n			fin_rubricas.prazo + 1,fin_rubricas.prazot \n			FROM fin_rubricas\n			/*buscar a folha de informação*/\n			JOIN fin_parametros ON fin_parametros.ano_informacao = fin_rubricas.ano\n			AND fin_parametros.mes_informacao = fin_rubricas.mes AND fin_parametros.parcela_informacao = fin_rubricas.parcela\n			AND fin_parametros.dominio = fin_rubricas.dominio\n			JOIN fin_eventos ON fin_eventos.id = fin_rubricas.id_fin_eventos\n			JOIN fin_sfuncional ON fin_parametros.ano_informacao = fin_sfuncional.ano\n			AND fin_parametros.mes_informacao = fin_sfuncional.mes AND fin_parametros.parcela_informacao = fin_sfuncional.parcela\n			AND fin_rubricas.dominio = fin_sfuncional.dominio and fin_sfuncional.id_cad_servidores = fin_rubricas.id_cad_servidores\n			WHERE fin_rubricas.dominio = v_dominio AND fin_parametros.ano = v_ano \n			AND fin_parametros.mes = v_mes AND fin_parametros.parcela = v_parcela\n			AND fin_rubricas.prazot > fin_rubricas.prazo AND fin_eventos.consignado = 1 AND fin_rubricas.valor > 0\n			AND fin_sfuncional.situacao = 1 AND fin_sfuncional.situacaofuncional >= 1\n			GROUP BY fin_rubricas.id_cad_servidores,fin_rubricas.id_fin_eventos,fin_parametros.ano,fin_parametros.mes,fin_parametros.parcela\n			ORDER BY fin_rubricas.id_cad_servidores,fin_eventos.tipo,fin_eventos.id_evento;\n	DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;\n	-- Retorna e armazena o último id da tabela fiin_rubricas\n	SET r_id_fin_rubricas = (SELECT MAX(id) FROM fin_rubricas);	\n	\n	-- Varre as referencias para localizar a correta e registrar o valor\n	OPEN cur1Referencias;\n	read_loop: LOOP\n		FETCH cur1Referencias INTO r_id_cad_servidores,r_id_fin_eventos,r_referencia,\n			r_valor_base,r_valor,r_valor_patronal,r_valor_maternidade,r_desconto,\n			r_percentual,r_prazo,r_prazot;\n		IF done THEN\n			LEAVE read_loop;\n		END IF;	\n		/*primeiro verifica se o servidor é falecido. 0 quer dizer que não foi encontrado afastamento S2 ou S3 para o servidor*/\n		if (SELECT getSFalecimento(r_id_cad_servidores) = 0) then\n			/*gera um slug*/\n			SET r_slug = SHA(CONCAT(UNIX_TIMESTAMP(NOW()),r_id_fin_rubricas));\n			/*depois seta o novo r_id_fin_rubricas*/\n			SET r_id_fin_rubricas = r_id_fin_rubricas + 1;	\n			/*para garantir a integridade da chave primária, efetua uma segunda verificação e geração de r_id_fin_rubricas, se necessário*/	\n			IF (SELECT id FROM fin_rubricas WHERE id = r_id_fin_rubricas) IS NOT NULL THEN\n				SET r_id_fin_rubricas = r_id_fin_rubricas + 1;\n			END IF;\n			SET r_id_evento = getEventoSistema(v_dominio,CONCAT(\'Inclusão da rúbrica parcelada id: \', r_id_fin_eventos),\'actionC\', \'fin_rubricas\', r_id_fin_rubricas, v_id_user);\n			INSERT INTO fin_rubricas(\n				id,slug,status,dominio,evento,created_at,updated_at,\n				id_cad_servidores,id_fin_eventos,ano,mes,parcela,\n				referencia,valor_base,valor,valor_patronal,\n				valor_maternidade,prazo,prazot,desconto,percentual\n			) VALUES (\n				r_id_fin_rubricas,r_slug,10,v_dominio,r_id_evento,UNIX_TIMESTAMP(NOW()),UNIX_TIMESTAMP(NOW()),\n				r_id_cad_servidores,r_id_fin_eventos,v_ano,v_mes,v_parcela,\n				r_referencia,r_valor_base,r_valor,r_valor_patronal,\n				r_valor_maternidade,r_prazo,r_prazot,r_desconto,r_percentual\n			);\n		end if;\n	END LOOP;\n	CLOSE cur1Referencias;\nEND','root@localhost','2019-06-13 10:02:41','2019-06-13 10:02:41','NO_AUTO_VALUE_ON_ZERO','','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN\n	DECLARE done INT DEFAULT FALSE;\n	DECLARE r_id_fin_rubricas,r_id_cad_servidores,r_id_fin_eventos,r_prazo,r_prazot,r_id_evento INT(11);\n	DECLARE r_slug,r_referencia,r_valor_base,r_valor,r_valor_patronal,\n			r_valor_maternidade,r_desconto,r_percentual VARCHAR(255);	 \n	-- obter referências\n	DECLARE cur1Referencias CURSOR FOR  \n		SELECT fin_rubricas.id_cad_servidores,fin_rubricas.id_fin_eventos,\n			fin_rubricas.referencia,fin_rubricas.valor_base,fin_rubricas.valor,fin_rubricas.valor_patronal,\n			fin_rubricas.valor_maternidade,fin_rubricas.desconto,fin_rubricas.percentual,\n			fin_rubricas.prazo + 1,fin_rubricas.prazot \n			FROM fin_rubricas\n			/*buscar a folha de informação*/\n			JOIN fin_parametros ON fin_parametros.ano_informacao = fin_rubricas.ano\n			AND fin_parametros.mes_informacao = fin_rubricas.mes AND fin_parametros.parcela_informacao = fin_rubricas.parcela\n			AND fin_parametros.dominio = fin_rubricas.dominio\n			JOIN fin_eventos ON fin_eventos.id = fin_rubricas.id_fin_eventos\n			JOIN fin_sfuncional ON fin_parametros.ano_informacao = fin_sfuncional.ano\n			AND fin_parametros.mes_informacao = fin_sfuncional.mes AND fin_parametros.parcela_informacao = fin_sfuncional.parcela\n			AND fin_rubricas.dominio = fin_sfuncional.dominio and fin_sfuncional.id_cad_servidores = fin_rubricas.id_cad_servidores\n			WHERE fin_rubricas.dominio = v_dominio AND fin_parametros.ano = v_ano \n			AND fin_parametros.mes = v_mes AND fin_parametros.parcela = v_parcela\n			AND fin_rubricas.prazot > fin_rubricas.prazo AND fin_eventos.consignado = 1 AND fin_rubricas.valor > 0\n			AND fin_sfuncional.situacao = 1 AND fin_sfuncional.situacaofuncional >= 1\n			GROUP BY fin_rubricas.id_cad_servidores,fin_rubricas.id_fin_eventos,fin_parametros.ano,fin_parametros.mes,fin_parametros.parcela\n			ORDER BY fin_rubricas.id_cad_servidores,fin_eventos.tipo,fin_eventos.id_evento;\n	DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;\n	-- Retorna e armazena o último id da tabela fiin_rubricas\n	SET r_id_fin_rubricas = (SELECT MAX(id) FROM fin_rubricas);	\n	\n	-- Varre as referencias para localizar a correta e registrar o valor\n	OPEN cur1Referencias;\n	read_loop: LOOP\n		FETCH cur1Referencias INTO r_id_cad_servidores,r_id_fin_eventos,r_referencia,\n			r_valor_base,r_valor,r_valor_patronal,r_valor_maternidade,r_desconto,\n			r_percentual,r_prazo,r_prazot;\n		IF done THEN\n			LEAVE read_loop;\n		END IF;	\n		/*primeiro verifica se o servidor é falecido. 0 quer dizer que não foi encontrado afastamento S2 ou S3 para o servidor*/\n		if (SELECT getSFalecimento(r_id_cad_servidores) = 0) then\n			/*gera um slug*/\n			SET r_slug = SHA(CONCAT(UNIX_TIMESTAMP(NOW()),r_id_fin_rubricas));\n			/*depois seta o novo r_id_fin_rubricas*/\n			SET r_id_fin_rubricas = r_id_fin_rubricas + 1;	\n			/*para garantir a integridade da chave primária, efetua uma segunda verificação e geração de r_id_fin_rubricas, se necessário*/	\n			IF (SELECT id FROM fin_rubricas WHERE id = r_id_fin_rubricas) IS NOT NULL THEN\n				SET r_id_fin_rubricas = r_id_fin_rubricas + 1;\n			END IF;\n			SET r_id_evento = getEventoSistema(v_dominio,CONCAT(\'Inclusão da rúbrica parcelada id: \', r_id_fin_eventos),\'actionC\', \'fin_rubricas\', r_id_fin_rubricas, v_id_user);\n			INSERT INTO fin_rubricas(\n				id,slug,status,dominio,evento,created_at,updated_at,\n				id_cad_servidores,id_fin_eventos,ano,mes,parcela,\n				referencia,valor_base,valor,valor_patronal,\n				valor_maternidade,prazo,prazot,desconto,percentual\n			) VALUES (\n				r_id_fin_rubricas,r_slug,10,v_dominio,r_id_evento,UNIX_TIMESTAMP(NOW()),UNIX_TIMESTAMP(NOW()),\n				r_id_cad_servidores,r_id_fin_eventos,v_ano,v_mes,v_parcela,\n				r_referencia,r_valor_base,r_valor,r_valor_patronal,\n				r_valor_maternidade,r_prazo,r_prazot,r_desconto,r_percentual\n			);\n		end if;\n	END LOOP;\n	CLOSE cur1Referencias;\nEND','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_folha','fin_folha_eventos_unique','PROCEDURE','fin_folha_eventos_unique','SQL','CONTAINS_SQL','NO','DEFINER','v_dominio VARCHAR(255),v_ano VARCHAR(4),v_mes VARCHAR(2),v_parcela VARCHAR(3),v_id_cad_servidor INT','','BEGIN \nDECLARE done INT DEFAULT FALSE; \nDECLARE cur1 CURSOR FOR \nSELECT fin_sfuncional.id_cad_servidores \n	FROM fin_sfuncional \n	JOIN cad_servidores ON cad_servidores.id = fin_sfuncional.id_cad_servidores \n	WHERE fin_sfuncional.dominio = v_dominio AND fin_sfuncional.ano = v_ano \n	AND fin_sfuncional.mes = v_mes AND fin_sfuncional.parcela = v_parcela -- AND fin_sfuncional.situacao = 1 \n	AND fin_sfuncional.situacaofuncional > 0 AND (fin_sfuncional.id_pccs IS NOT NULL AND fin_sfuncional.id_pccs > 0) \n	AND fin_sfuncional.id_cad_servidores = CAST(v_id_cad_servidor AS UNSIGNED)\n	AND fin_sfuncional.lanca_salario = 1\n	ORDER BY cad_servidores.id; \nDECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE; \nDELETE FROM fin_rubricas WHERE dominio = v_dominio \n	AND ano = v_ano AND mes = v_mes AND parcela = v_parcela\n	AND fin_rubricas.id_cad_servidores = CAST(v_id_cad_servidor AS UNSIGNED); \nOPEN cur1; \nread_loop: LOOP FETCH cur1 INTO v_id_cad_servidor; \n	IF done THEN \n		LEAVE read_loop; \n	END IF; \n	CALL fin_folha_ev_basico(v_dominio,v_ano,v_mes,v_parcela,v_id_cad_servidor); \nEND LOOP; \nCLOSE cur1; \nEND','root@localhost','2019-06-13 10:02:41','2019-06-13 10:02:41','NO_AUTO_VALUE_ON_ZERO','','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN \nDECLARE done INT DEFAULT FALSE; \nDECLARE cur1 CURSOR FOR \nSELECT fin_sfuncional.id_cad_servidores \n	FROM fin_sfuncional \n	JOIN cad_servidores ON cad_servidores.id = fin_sfuncional.id_cad_servidores \n	WHERE fin_sfuncional.dominio = v_dominio AND fin_sfuncional.ano = v_ano \n	AND fin_sfuncional.mes = v_mes AND fin_sfuncional.parcela = v_parcela -- AND fin_sfuncional.situacao = 1 \n	AND fin_sfuncional.situacaofuncional > 0 AND (fin_sfuncional.id_pccs IS NOT NULL AND fin_sfuncional.id_pccs > 0) \n	AND fin_sfuncional.id_cad_servidores = CAST(v_id_cad_servidor AS UNSIGNED)\n	AND fin_sfuncional.lanca_salario = 1\n	ORDER BY cad_servidores.id; \nDECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE; \nDELETE FROM fin_rubricas WHERE dominio = v_dominio \n	AND ano = v_ano AND mes = v_mes AND parcela = v_parcela\n	AND fin_rubricas.id_cad_servidores = CAST(v_id_cad_servidor AS UNSIGNED); \nOPEN cur1; \nread_loop: LOOP FETCH cur1 INTO v_id_cad_servidor; \n	IF done THEN \n		LEAVE read_loop; \n	END IF; \n	CALL fin_folha_ev_basico(v_dominio,v_ano,v_mes,v_parcela,v_id_cad_servidor); \nEND LOOP; \nCLOSE cur1; \nEND','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_folha','fin_folha_eventos_parcelados','PROCEDURE','fin_folha_eventos_parcelados','SQL','CONTAINS_SQL','NO','DEFINER','\nv_id_user INT(11),v_dominio VARCHAR(255),v_ano VARCHAR(4),v_mes VARCHAR(2),v_parcela VARCHAR(3)','','BEGIN\n	DECLARE done INT DEFAULT FALSE;\n	DECLARE r_id_fin_rubricas,r_id_cad_servidores,r_id_fin_eventos,r_prazo,r_prazot,r_id_evento INT(11);\n	DECLARE r_slug,r_referencia,r_valor_base,r_valor,r_valor_patronal,\n			r_valor_maternidade,r_desconto,r_percentual VARCHAR(255);	 \n	-- obter referências\n	DECLARE cur1Referencias CURSOR FOR  \n		SELECT fin_rubricas.id_cad_servidores,fin_rubricas.id_fin_eventos,\n			fin_rubricas.referencia,fin_rubricas.valor_base,fin_rubricas.valor,fin_rubricas.valor_patronal,\n			fin_rubricas.valor_maternidade,fin_rubricas.desconto,fin_rubricas.percentual,\n			fin_rubricas.prazo + 1,fin_rubricas.prazot \n			FROM fin_rubricas\n			/*buscar a folha de informação*/\n			JOIN fin_parametros ON fin_parametros.ano_informacao = fin_rubricas.ano\n			AND fin_parametros.mes_informacao = fin_rubricas.mes AND fin_parametros.parcela_informacao = fin_rubricas.parcela\n			AND fin_parametros.dominio = fin_rubricas.dominio\n			JOIN fin_eventos ON fin_eventos.id = fin_rubricas.id_fin_eventos\n			JOIN fin_sfuncional ON fin_parametros.ano_informacao = fin_sfuncional.ano\n			AND fin_parametros.mes_informacao = fin_sfuncional.mes AND fin_parametros.parcela_informacao = fin_sfuncional.parcela\n			AND fin_rubricas.dominio = fin_sfuncional.dominio AND fin_sfuncional.id_cad_servidores = fin_rubricas.id_cad_servidores\n			WHERE fin_rubricas.dominio = v_dominio AND fin_parametros.ano = v_ano \n			AND fin_parametros.mes = v_mes AND fin_parametros.parcela = v_parcela\n			AND fin_rubricas.prazot > fin_rubricas.prazo AND fin_eventos.consignado = 0 AND fin_rubricas.valor > 0\n			AND fin_sfuncional.situacao = 1 AND fin_sfuncional.situacaofuncional >= 1\n			GROUP BY fin_rubricas.id_cad_servidores,fin_rubricas.id_fin_eventos,fin_parametros.ano,fin_parametros.mes,fin_parametros.parcela\n			ORDER BY fin_rubricas.id_cad_servidores,fin_eventos.tipo,fin_eventos.id_evento;\n	DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;\n	-- Retorna e armazena o último id da tabela fiin_rubricas\n	SET r_id_fin_rubricas = (SELECT MAX(id) FROM fin_rubricas);	\n	\n	-- Varre as referencias para localizar a correta e registrar o valor\n	OPEN cur1Referencias;\n	read_loop: LOOP\n		FETCH cur1Referencias INTO r_id_cad_servidores,r_id_fin_eventos,r_referencia,\n			r_valor_base,r_valor,r_valor_patronal,r_valor_maternidade,r_desconto,\n			r_percentual,r_prazo,r_prazot;\n		IF done THEN\n			LEAVE read_loop;\n		END IF;	\n		/*primeiro gera um slug*/\n		SET r_slug = SHA(CONCAT(UNIX_TIMESTAMP(NOW()),r_id_fin_rubricas));\n		/*depois seta o novo r_id_fin_rubricas*/\n		SET r_id_fin_rubricas = r_id_fin_rubricas + 1;	\n		/*para garantir a integridade da chave primária, efetua uma segunda verificação e geração de r_id_fin_rubricas, se necessário*/	\n		IF (SELECT id FROM fin_rubricas WHERE id = r_id_fin_rubricas) IS NOT NULL THEN\n			SET r_id_fin_rubricas = r_id_fin_rubricas + 1;\n		END IF;\n		SET r_id_evento = getEventoSistema(v_dominio,CONCAT(\'Inclusão da rúbrica parcelada id: \', r_id_fin_eventos),\'actionC\', \'fin_rubricas\', r_id_fin_rubricas, v_id_user);\n		INSERT INTO fin_rubricas(\n			id,slug,`status`,dominio,evento,created_at,updated_at,\n			id_cad_servidores,id_fin_eventos,ano,mes,parcela,\n			referencia,valor_base,valor,valor_patronal,\n			valor_maternidade,prazo,prazot,desconto,percentual\n		) VALUES (\n			r_id_fin_rubricas,r_slug,10,v_dominio,r_id_evento,UNIX_TIMESTAMP(NOW()),UNIX_TIMESTAMP(NOW()),\n			r_id_cad_servidores,r_id_fin_eventos,v_ano,v_mes,v_parcela,\n			r_referencia,r_valor_base,r_valor,r_valor_patronal,\n			r_valor_maternidade,r_prazo,r_prazot,r_desconto,r_percentual\n		);\n	END LOOP;\n	CLOSE cur1Referencias;\nEND','root@localhost','2019-06-13 10:02:41','2019-06-13 10:02:41','NO_AUTO_VALUE_ON_ZERO','','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN\n	DECLARE done INT DEFAULT FALSE;\n	DECLARE r_id_fin_rubricas,r_id_cad_servidores,r_id_fin_eventos,r_prazo,r_prazot,r_id_evento INT(11);\n	DECLARE r_slug,r_referencia,r_valor_base,r_valor,r_valor_patronal,\n			r_valor_maternidade,r_desconto,r_percentual VARCHAR(255);	 \n	-- obter referências\n	DECLARE cur1Referencias CURSOR FOR  \n		SELECT fin_rubricas.id_cad_servidores,fin_rubricas.id_fin_eventos,\n			fin_rubricas.referencia,fin_rubricas.valor_base,fin_rubricas.valor,fin_rubricas.valor_patronal,\n			fin_rubricas.valor_maternidade,fin_rubricas.desconto,fin_rubricas.percentual,\n			fin_rubricas.prazo + 1,fin_rubricas.prazot \n			FROM fin_rubricas\n			/*buscar a folha de informação*/\n			JOIN fin_parametros ON fin_parametros.ano_informacao = fin_rubricas.ano\n			AND fin_parametros.mes_informacao = fin_rubricas.mes AND fin_parametros.parcela_informacao = fin_rubricas.parcela\n			AND fin_parametros.dominio = fin_rubricas.dominio\n			JOIN fin_eventos ON fin_eventos.id = fin_rubricas.id_fin_eventos\n			JOIN fin_sfuncional ON fin_parametros.ano_informacao = fin_sfuncional.ano\n			AND fin_parametros.mes_informacao = fin_sfuncional.mes AND fin_parametros.parcela_informacao = fin_sfuncional.parcela\n			AND fin_rubricas.dominio = fin_sfuncional.dominio AND fin_sfuncional.id_cad_servidores = fin_rubricas.id_cad_servidores\n			WHERE fin_rubricas.dominio = v_dominio AND fin_parametros.ano = v_ano \n			AND fin_parametros.mes = v_mes AND fin_parametros.parcela = v_parcela\n			AND fin_rubricas.prazot > fin_rubricas.prazo AND fin_eventos.consignado = 0 AND fin_rubricas.valor > 0\n			AND fin_sfuncional.situacao = 1 AND fin_sfuncional.situacaofuncional >= 1\n			GROUP BY fin_rubricas.id_cad_servidores,fin_rubricas.id_fin_eventos,fin_parametros.ano,fin_parametros.mes,fin_parametros.parcela\n			ORDER BY fin_rubricas.id_cad_servidores,fin_eventos.tipo,fin_eventos.id_evento;\n	DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;\n	-- Retorna e armazena o último id da tabela fiin_rubricas\n	SET r_id_fin_rubricas = (SELECT MAX(id) FROM fin_rubricas);	\n	\n	-- Varre as referencias para localizar a correta e registrar o valor\n	OPEN cur1Referencias;\n	read_loop: LOOP\n		FETCH cur1Referencias INTO r_id_cad_servidores,r_id_fin_eventos,r_referencia,\n			r_valor_base,r_valor,r_valor_patronal,r_valor_maternidade,r_desconto,\n			r_percentual,r_prazo,r_prazot;\n		IF done THEN\n			LEAVE read_loop;\n		END IF;	\n		/*primeiro gera um slug*/\n		SET r_slug = SHA(CONCAT(UNIX_TIMESTAMP(NOW()),r_id_fin_rubricas));\n		/*depois seta o novo r_id_fin_rubricas*/\n		SET r_id_fin_rubricas = r_id_fin_rubricas + 1;	\n		/*para garantir a integridade da chave primária, efetua uma segunda verificação e geração de r_id_fin_rubricas, se necessário*/	\n		IF (SELECT id FROM fin_rubricas WHERE id = r_id_fin_rubricas) IS NOT NULL THEN\n			SET r_id_fin_rubricas = r_id_fin_rubricas + 1;\n		END IF;\n		SET r_id_evento = getEventoSistema(v_dominio,CONCAT(\'Inclusão da rúbrica parcelada id: \', r_id_fin_eventos),\'actionC\', \'fin_rubricas\', r_id_fin_rubricas, v_id_user);\n		INSERT INTO fin_rubricas(\n			id,slug,`status`,dominio,evento,created_at,updated_at,\n			id_cad_servidores,id_fin_eventos,ano,mes,parcela,\n			referencia,valor_base,valor,valor_patronal,\n			valor_maternidade,prazo,prazot,desconto,percentual\n		) VALUES (\n			r_id_fin_rubricas,r_slug,10,v_dominio,r_id_evento,UNIX_TIMESTAMP(NOW()),UNIX_TIMESTAMP(NOW()),\n			r_id_cad_servidores,r_id_fin_eventos,v_ano,v_mes,v_parcela,\n			r_referencia,r_valor_base,r_valor,r_valor_patronal,\n			r_valor_maternidade,r_prazo,r_prazot,r_desconto,r_percentual\n		);\n	END LOOP;\n	CLOSE cur1Referencias;\nEND','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_folha','fin_folha_eventos_recorrentes','PROCEDURE','fin_folha_eventos_recorrentes','SQL','CONTAINS_SQL','NO','DEFINER','\nv_id_user INT(11),v_dominio VARCHAR(255),v_ano VARCHAR(4),v_mes VARCHAR(2),v_parcela VARCHAR(3)','','BEGIN\n	DECLARE done INT DEFAULT FALSE;\n	DECLARE r_id_fin_rubricas,r_id_cad_servidores,r_id_fin_eventos,r_prazo,r_prazot,r_id_evento INT(11);\n	DECLARE r_slug,r_referencia,r_valor_base,r_valor,r_valor_patronal,\n			r_valor_maternidade,r_desconto,r_percentual VARCHAR(255);	 \n	-- obter referências\n	DECLARE cur1Referencias CURSOR FOR  \n		SELECT fin_rubricas.id_cad_servidores,fin_rubricas.id_fin_eventos,\n			fin_rubricas.referencia,fin_rubricas.valor_base,fin_rubricas.valor,fin_rubricas.valor_patronal,\n			fin_rubricas.valor_maternidade,fin_rubricas.desconto,fin_rubricas.percentual \n			FROM fin_rubricas\n			/*buscar a folha de informação*/\n			JOIN fin_parametros ON fin_parametros.ano_informacao = fin_rubricas.ano\n			AND fin_parametros.mes_informacao = fin_rubricas.mes AND fin_parametros.parcela_informacao = fin_rubricas.parcela\n			AND fin_parametros.dominio = fin_rubricas.dominio\n			JOIN fin_eventos ON fin_eventos.id = fin_rubricas.id_fin_eventos\n			JOIN fin_sfuncional ON fin_parametros.ano_informacao = fin_sfuncional.ano\n			AND fin_parametros.mes_informacao = fin_sfuncional.mes AND fin_parametros.parcela_informacao = fin_sfuncional.parcela\n			AND fin_rubricas.dominio = fin_sfuncional.dominio AND fin_sfuncional.id_cad_servidores = fin_rubricas.id_cad_servidores\n			WHERE fin_rubricas.dominio = v_dominio AND fin_parametros.ano = v_ano \n			AND fin_parametros.mes = v_mes AND fin_parametros.parcela = v_parcela			\n			AND fin_eventos.ev_root != 1 AND fin_eventos.fixo = 1 AND fin_rubricas.prazot = fin_rubricas.prazo \n			AND fin_rubricas.prazot IN (1,999) and fin_rubricas.valor > 0 \n			AND fin_sfuncional.situacao = 1 AND fin_sfuncional.situacaofuncional >= 1\n			GROUP BY fin_rubricas.id_cad_servidores,fin_rubricas.id_fin_eventos,fin_parametros.ano,fin_parametros.mes,fin_parametros.parcela\n			ORDER BY fin_rubricas.id_cad_servidores,fin_eventos.tipo,fin_eventos.id_evento;\n	DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;\n	-- Retorna e armazena o último id da tabela fiin_rubricas\n	SET r_id_fin_rubricas = (SELECT MAX(id) FROM fin_rubricas);	\n	\n	-- Varre as referencias para localizar a correta e registrar o valor\n	OPEN cur1Referencias;\n	read_loop: LOOP\n		FETCH cur1Referencias INTO r_id_cad_servidores,r_id_fin_eventos,r_referencia,\n			r_valor_base,r_valor,r_valor_patronal,r_valor_maternidade,r_desconto,r_percentual;\n		IF done THEN\n			LEAVE read_loop;\n		END IF;	\n		/*primeiro gera um slug*/\n		SET r_slug = SHA(CONCAT(UNIX_TIMESTAMP(NOW()),r_id_fin_rubricas));\n		/*depois seta o novo r_id_fin_rubricas*/\n		SET r_id_fin_rubricas = r_id_fin_rubricas + 1;	\n		/*para garantir a integridade da chave primária, efetua uma segunda verificação e geração de r_id_fin_rubricas, se necessário*/	\n		IF (SELECT id FROM fin_rubricas WHERE id = r_id_fin_rubricas) IS NOT NULL THEN\n			SET r_id_fin_rubricas = r_id_fin_rubricas + 1;\n		END IF;\n		SET r_id_evento = getEventoSistema(v_dominio,CONCAT(\'Inclusão da rúbrica recorrente id: \', r_id_fin_eventos),\'actionC\', \'fin_rubricas\', r_id_fin_rubricas, v_id_user);\n		SET r_valor_base = 0, r_valor = 0, r_valor_patronal = 0, r_valor_maternidade = 0, r_desconto = 0, r_prazo = 1, r_prazot = 1;\n		INSERT INTO fin_rubricas(\n			id,slug,`status`,dominio,evento,created_at,updated_at,\n			id_cad_servidores,id_fin_eventos,ano,mes,parcela,\n			referencia,valor_base,valor,valor_patronal,\n			valor_maternidade,prazo,prazot,desconto,percentual\n		) VALUES (\n			r_id_fin_rubricas,r_slug,10,v_dominio,r_id_evento,UNIX_TIMESTAMP(NOW()),UNIX_TIMESTAMP(NOW()),\n			r_id_cad_servidores,r_id_fin_eventos,v_ano,v_mes,v_parcela,\n			r_referencia,r_valor_base,r_valor,r_valor_patronal,\n			r_valor_maternidade,r_prazo,r_prazot,r_desconto,r_percentual\n		);\n	END LOOP;\n	CLOSE cur1Referencias;\nEND','root@localhost','2019-06-13 10:02:41','2019-06-13 10:02:41','NO_AUTO_VALUE_ON_ZERO','','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN\n	DECLARE done INT DEFAULT FALSE;\n	DECLARE r_id_fin_rubricas,r_id_cad_servidores,r_id_fin_eventos,r_prazo,r_prazot,r_id_evento INT(11);\n	DECLARE r_slug,r_referencia,r_valor_base,r_valor,r_valor_patronal,\n			r_valor_maternidade,r_desconto,r_percentual VARCHAR(255);	 \n	-- obter referências\n	DECLARE cur1Referencias CURSOR FOR  \n		SELECT fin_rubricas.id_cad_servidores,fin_rubricas.id_fin_eventos,\n			fin_rubricas.referencia,fin_rubricas.valor_base,fin_rubricas.valor,fin_rubricas.valor_patronal,\n			fin_rubricas.valor_maternidade,fin_rubricas.desconto,fin_rubricas.percentual \n			FROM fin_rubricas\n			/*buscar a folha de informação*/\n			JOIN fin_parametros ON fin_parametros.ano_informacao = fin_rubricas.ano\n			AND fin_parametros.mes_informacao = fin_rubricas.mes AND fin_parametros.parcela_informacao = fin_rubricas.parcela\n			AND fin_parametros.dominio = fin_rubricas.dominio\n			JOIN fin_eventos ON fin_eventos.id = fin_rubricas.id_fin_eventos\n			JOIN fin_sfuncional ON fin_parametros.ano_informacao = fin_sfuncional.ano\n			AND fin_parametros.mes_informacao = fin_sfuncional.mes AND fin_parametros.parcela_informacao = fin_sfuncional.parcela\n			AND fin_rubricas.dominio = fin_sfuncional.dominio AND fin_sfuncional.id_cad_servidores = fin_rubricas.id_cad_servidores\n			WHERE fin_rubricas.dominio = v_dominio AND fin_parametros.ano = v_ano \n			AND fin_parametros.mes = v_mes AND fin_parametros.parcela = v_parcela			\n			AND fin_eventos.ev_root != 1 AND fin_eventos.fixo = 1 AND fin_rubricas.prazot = fin_rubricas.prazo \n			AND fin_rubricas.prazot IN (1,999) and fin_rubricas.valor > 0 \n			AND fin_sfuncional.situacao = 1 AND fin_sfuncional.situacaofuncional >= 1\n			GROUP BY fin_rubricas.id_cad_servidores,fin_rubricas.id_fin_eventos,fin_parametros.ano,fin_parametros.mes,fin_parametros.parcela\n			ORDER BY fin_rubricas.id_cad_servidores,fin_eventos.tipo,fin_eventos.id_evento;\n	DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;\n	-- Retorna e armazena o último id da tabela fiin_rubricas\n	SET r_id_fin_rubricas = (SELECT MAX(id) FROM fin_rubricas);	\n	\n	-- Varre as referencias para localizar a correta e registrar o valor\n	OPEN cur1Referencias;\n	read_loop: LOOP\n		FETCH cur1Referencias INTO r_id_cad_servidores,r_id_fin_eventos,r_referencia,\n			r_valor_base,r_valor,r_valor_patronal,r_valor_maternidade,r_desconto,r_percentual;\n		IF done THEN\n			LEAVE read_loop;\n		END IF;	\n		/*primeiro gera um slug*/\n		SET r_slug = SHA(CONCAT(UNIX_TIMESTAMP(NOW()),r_id_fin_rubricas));\n		/*depois seta o novo r_id_fin_rubricas*/\n		SET r_id_fin_rubricas = r_id_fin_rubricas + 1;	\n		/*para garantir a integridade da chave primária, efetua uma segunda verificação e geração de r_id_fin_rubricas, se necessário*/	\n		IF (SELECT id FROM fin_rubricas WHERE id = r_id_fin_rubricas) IS NOT NULL THEN\n			SET r_id_fin_rubricas = r_id_fin_rubricas + 1;\n		END IF;\n		SET r_id_evento = getEventoSistema(v_dominio,CONCAT(\'Inclusão da rúbrica recorrente id: \', r_id_fin_eventos),\'actionC\', \'fin_rubricas\', r_id_fin_rubricas, v_id_user);\n		SET r_valor_base = 0, r_valor = 0, r_valor_patronal = 0, r_valor_maternidade = 0, r_desconto = 0, r_prazo = 1, r_prazot = 1;\n		INSERT INTO fin_rubricas(\n			id,slug,`status`,dominio,evento,created_at,updated_at,\n			id_cad_servidores,id_fin_eventos,ano,mes,parcela,\n			referencia,valor_base,valor,valor_patronal,\n			valor_maternidade,prazo,prazot,desconto,percentual\n		) VALUES (\n			r_id_fin_rubricas,r_slug,10,v_dominio,r_id_evento,UNIX_TIMESTAMP(NOW()),UNIX_TIMESTAMP(NOW()),\n			r_id_cad_servidores,r_id_fin_eventos,v_ano,v_mes,v_parcela,\n			r_referencia,r_valor_base,r_valor,r_valor_patronal,\n			r_valor_maternidade,r_prazo,r_prazot,r_desconto,r_percentual\n		);\n	END LOOP;\n	CLOSE cur1Referencias;\nEND','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_folha','fin_folha_ev_basico','PROCEDURE','fin_folha_ev_basico','SQL','CONTAINS_SQL','NO','DEFINER','v_id_user VARCHAR(255),v_dominio VARCHAR(255),v_ano VARCHAR(4),v_mes VARCHAR(2),\nv_parcela VARCHAR(3),v_id_cad_servidor VARCHAR(255)','','BEGIN\n DECLARE r_valor, v_valor DECIMAL(11,2);\n DECLARE v_referencia, v_anos, v_meses, v_dias CHAR(2);\n DECLARE v_i_ano_inicial, v_i_ano_final CHAR(3);\n DECLARE v_id_pccs, v_id_vinculo, v_dias_mes, v_dias_trabalhados, r_id_evento, r_id_fin_eventos, r_id_fin_rubricas INT;\n DECLARE v_d_admissao DATE; \n DECLARE done INT DEFAULT FALSE; \n DECLARE exec INT DEFAULT TRUE;  \n -- obter referências\n DECLARE cur1Referencias CURSOR FOR  \n	SELECT fin_referencias.valor, cad_classes.i_ano_inicial, cad_classes.i_ano_final \n		FROM fin_referencias \n		JOIN cad_pccs ON cad_pccs.dominio = fin_referencias.dominio \n			AND cad_pccs.id_pccs = fin_referencias.id_pccs \n		JOIN cad_classes ON cad_classes.dominio = fin_referencias.dominio \n			AND cad_classes.id_pccs = cad_pccs.id_pccs \n			AND cad_classes.id_classe = fin_referencias.id_classe \n		WHERE (cad_pccs.dominio=v_dominio) AND (fin_referencias.id_pccs=v_id_pccs) \n			AND (STR_TO_DATE(fin_referencias.data, \'%d/%m/%Y\') <= LAST_DAY(CONCAT(v_ano, \'-\', v_mes, \'-1\'))) \n			AND CAST(v_anos AS UNSIGNED) BETWEEN CAST(cad_classes.i_ano_inicial AS UNSIGNED) AND CAST(cad_classes.i_ano_final AS UNSIGNED)\n		ORDER BY fin_referencias.id_classe DESC, fin_referencias.referencia DESC\n		LIMIT 100000;\n DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;\n \n SET v_dias_mes = DATE_FORMAT(LAST_DAY(CONCAT(v_ano, \'-\', v_mes, \'-1\')), \'%d\');\n SET v_dias_trabalhados = getDiasPagarVctoBasico(v_id_cad_servidor,v_ano,v_mes);\n SET v_referencia = v_dias_trabalhados;\n SET r_valor = 0;\n -- Registra valor para: v_id_pccs, v_d_admissao, v_anos, v_meses, v_dias \n SELECT fin_sfuncional.id_pccs,cad_sfuncional.id_vinculo,\n	/*CONCAT(SUBSTR(cad_servidores.d_admissao, 7),\'-\',SUBSTR(cad_servidores.d_admissao, 4,2),\'-\',SUBSTR(cad_servidores.d_admissao, 1,2))*/\n	STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\')data_adm,\n	TIMESTAMPDIFF(YEAR, STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\'), LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) AS anos,\n	TIMESTAMPDIFF(MONTH, STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\') + INTERVAL TIMESTAMPDIFF(YEAR,  STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\'), LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) YEAR , LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) AS meses,\n	TIMESTAMPDIFF(DAY, STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\') + INTERVAL TIMESTAMPDIFF(MONTH,  STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\'), LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) MONTH , LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) + 1 AS dias\n	INTO v_id_pccs, v_id_vinculo, v_d_admissao, v_anos, v_meses, v_dias\n	FROM cad_sfuncional\n	JOIN cad_servidores ON cad_sfuncional.id_cad_servidores = cad_servidores.id\n	JOIN fin_sfuncional ON cad_sfuncional.id_cad_servidores = fin_sfuncional.id_cad_servidores AND \n	cad_sfuncional.ano = fin_sfuncional.ano AND cad_sfuncional.mes = fin_sfuncional.mes AND\n	cad_sfuncional.parcela = fin_sfuncional.parcela\n	WHERE fin_sfuncional.ano = v_ano AND fin_sfuncional.mes = v_mes AND fin_sfuncional.parcela = v_parcela \n	AND fin_sfuncional.id_cad_servidores = v_id_cad_servidor;\n	-- Varre as referencias para localizar a correta e registrar o valor\n	OPEN cur1Referencias;\n	read_loop: LOOP\n		FETCH cur1Referencias INTO v_valor, v_i_ano_inicial, v_i_ano_final;\n		IF done THEN\n			LEAVE read_loop;\n		END IF;\n		IF !(v_anos = v_i_ano_final && (v_meses != 0 || v_dias != 0)) THEN\n			SET r_valor = ((v_valor / v_dias_mes) * v_dias_trabalhados);\n			IF v_i_ano_final != 0 AND v_i_ano_inicial != 99 THEN\n				SET done = TRUE;\n			ELSE \n				SET done = FALSE;\n			END IF;\n		END IF;\n	END LOOP;\n	CLOSE cur1Referencias;\n	\n SET r_id_fin_eventos = getidvinculo(v_dominio,v_id_vinculo);\n \n IF v_dias_trabalhados > 0 THEN\n	SET exec = TRUE;\n ELSE\n	SET exec = FALSE;\n END IF;\n \nIF exec = TRUE THEN\n	-- Retorna e armazena o último id da tabela fiin_rubricas\n	SET r_id_fin_rubricas = (SELECT MAX(id) FROM fin_rubricas) + 1;\n	/*para garantir a integridade da chave primária, efetua uma segunda verificação e geração de r_id_fin_rubricas, se necessário*/	\n	IF (SELECT id FROM fin_rubricas WHERE id = r_id_fin_rubricas) IS NOT NULL THEN\n		SET r_id_fin_rubricas = r_id_fin_rubricas + 1;\n	END IF;	\n	SET r_id_evento = getEventoSistema(v_dominio,CONCAT(\'Inclusão da rúbrica id: \', r_id_fin_eventos),\'actionC\', \'fin_rubricas\', r_id_fin_rubricas, v_id_user);\n	-- Insere a rúbrica\n	INSERT INTO fin_rubricas (id,slug,STATUS,dominio,evento,created_at,updated_at,\n		id_cad_servidores,id_fin_eventos,\n		ano,mes,parcela,referencia,valor_base,valor,valor_patronal,valor_maternidade,prazo,prazot,desconto,percentual) \n	VALUES(\n		r_id_fin_rubricas,SHA(CONCAT(NOW(),v_dominio,v_id_cad_servidor)),10,v_dominio,r_id_evento,UNIX_TIMESTAMP(NOW()),UNIX_TIMESTAMP(NOW()),\n		v_id_cad_servidor,r_id_fin_eventos,\n		v_ano,v_mes,v_parcela,v_referencia,0.00,r_valor,0.00,0.00,1,1,0.00,100.00\n	);\n END IF; \n /*\nSELECT v_dias_trabalhados, v_id_pccs, r_id_fin_eventos, v_d_admissao, v_anos, v_meses, v_dias, r_valor, exec, v_dias_mes;\n */\nEND','root@localhost','2019-06-13 10:02:41','2019-06-13 10:02:41','NO_AUTO_VALUE_ON_ZERO','','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN\n DECLARE r_valor, v_valor DECIMAL(11,2);\n DECLARE v_referencia, v_anos, v_meses, v_dias CHAR(2);\n DECLARE v_i_ano_inicial, v_i_ano_final CHAR(3);\n DECLARE v_id_pccs, v_id_vinculo, v_dias_mes, v_dias_trabalhados, r_id_evento, r_id_fin_eventos, r_id_fin_rubricas INT;\n DECLARE v_d_admissao DATE; \n DECLARE done INT DEFAULT FALSE; \n DECLARE exec INT DEFAULT TRUE;  \n -- obter referências\n DECLARE cur1Referencias CURSOR FOR  \n	SELECT fin_referencias.valor, cad_classes.i_ano_inicial, cad_classes.i_ano_final \n		FROM fin_referencias \n		JOIN cad_pccs ON cad_pccs.dominio = fin_referencias.dominio \n			AND cad_pccs.id_pccs = fin_referencias.id_pccs \n		JOIN cad_classes ON cad_classes.dominio = fin_referencias.dominio \n			AND cad_classes.id_pccs = cad_pccs.id_pccs \n			AND cad_classes.id_classe = fin_referencias.id_classe \n		WHERE (cad_pccs.dominio=v_dominio) AND (fin_referencias.id_pccs=v_id_pccs) \n			AND (STR_TO_DATE(fin_referencias.data, \'%d/%m/%Y\') <= LAST_DAY(CONCAT(v_ano, \'-\', v_mes, \'-1\'))) \n			AND CAST(v_anos AS UNSIGNED) BETWEEN CAST(cad_classes.i_ano_inicial AS UNSIGNED) AND CAST(cad_classes.i_ano_final AS UNSIGNED)\n		ORDER BY fin_referencias.id_classe DESC, fin_referencias.referencia DESC\n		LIMIT 100000;\n DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;\n \n SET v_dias_mes = DATE_FORMAT(LAST_DAY(CONCAT(v_ano, \'-\', v_mes, \'-1\')), \'%d\');\n SET v_dias_trabalhados = getDiasPagarVctoBasico(v_id_cad_servidor,v_ano,v_mes);\n SET v_referencia = v_dias_trabalhados;\n SET r_valor = 0;\n -- Registra valor para: v_id_pccs, v_d_admissao, v_anos, v_meses, v_dias \n SELECT fin_sfuncional.id_pccs,cad_sfuncional.id_vinculo,\n	/*CONCAT(SUBSTR(cad_servidores.d_admissao, 7),\'-\',SUBSTR(cad_servidores.d_admissao, 4,2),\'-\',SUBSTR(cad_servidores.d_admissao, 1,2))*/\n	STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\')data_adm,\n	TIMESTAMPDIFF(YEAR, STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\'), LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) AS anos,\n	TIMESTAMPDIFF(MONTH, STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\') + INTERVAL TIMESTAMPDIFF(YEAR,  STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\'), LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) YEAR , LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) AS meses,\n	TIMESTAMPDIFF(DAY, STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\') + INTERVAL TIMESTAMPDIFF(MONTH,  STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\'), LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) MONTH , LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) + 1 AS dias\n	INTO v_id_pccs, v_id_vinculo, v_d_admissao, v_anos, v_meses, v_dias\n	FROM cad_sfuncional\n	JOIN cad_servidores ON cad_sfuncional.id_cad_servidores = cad_servidores.id\n	JOIN fin_sfuncional ON cad_sfuncional.id_cad_servidores = fin_sfuncional.id_cad_servidores AND \n	cad_sfuncional.ano = fin_sfuncional.ano AND cad_sfuncional.mes = fin_sfuncional.mes AND\n	cad_sfuncional.parcela = fin_sfuncional.parcela\n	WHERE fin_sfuncional.ano = v_ano AND fin_sfuncional.mes = v_mes AND fin_sfuncional.parcela = v_parcela \n	AND fin_sfuncional.id_cad_servidores = v_id_cad_servidor;\n	-- Varre as referencias para localizar a correta e registrar o valor\n	OPEN cur1Referencias;\n	read_loop: LOOP\n		FETCH cur1Referencias INTO v_valor, v_i_ano_inicial, v_i_ano_final;\n		IF done THEN\n			LEAVE read_loop;\n		END IF;\n		IF !(v_anos = v_i_ano_final && (v_meses != 0 || v_dias != 0)) THEN\n			SET r_valor = ((v_valor / v_dias_mes) * v_dias_trabalhados);\n			IF v_i_ano_final != 0 AND v_i_ano_inicial != 99 THEN\n				SET done = TRUE;\n			ELSE \n				SET done = FALSE;\n			END IF;\n		END IF;\n	END LOOP;\n	CLOSE cur1Referencias;\n	\n SET r_id_fin_eventos = getidvinculo(v_dominio,v_id_vinculo);\n \n IF v_dias_trabalhados > 0 THEN\n	SET exec = TRUE;\n ELSE\n	SET exec = FALSE;\n END IF;\n \nIF exec = TRUE THEN\n	-- Retorna e armazena o último id da tabela fiin_rubricas\n	SET r_id_fin_rubricas = (SELECT MAX(id) FROM fin_rubricas) + 1;\n	/*para garantir a integridade da chave primária, efetua uma segunda verificação e geração de r_id_fin_rubricas, se necessário*/	\n	IF (SELECT id FROM fin_rubricas WHERE id = r_id_fin_rubricas) IS NOT NULL THEN\n		SET r_id_fin_rubricas = r_id_fin_rubricas + 1;\n	END IF;	\n	SET r_id_evento = getEventoSistema(v_dominio,CONCAT(\'Inclusão da rúbrica id: \', r_id_fin_eventos),\'actionC\', \'fin_rubricas\', r_id_fin_rubricas, v_id_user);\n	-- Insere a rúbrica\n	INSERT INTO fin_rubricas (id,slug,STATUS,dominio,evento,created_at,updated_at,\n		id_cad_servidores,id_fin_eventos,\n		ano,mes,parcela,referencia,valor_base,valor,valor_patronal,valor_maternidade,prazo,prazot,desconto,percentual) \n	VALUES(\n		r_id_fin_rubricas,SHA(CONCAT(NOW(),v_dominio,v_id_cad_servidor)),10,v_dominio,r_id_evento,UNIX_TIMESTAMP(NOW()),UNIX_TIMESTAMP(NOW()),\n		v_id_cad_servidor,r_id_fin_eventos,\n		v_ano,v_mes,v_parcela,v_referencia,0.00,r_valor,0.00,0.00,1,1,0.00,100.00\n	);\n END IF; \n /*\nSELECT v_dias_trabalhados, v_id_pccs, r_id_fin_eventos, v_d_admissao, v_anos, v_meses, v_dias, r_valor, exec, v_dias_mes;\n */\nEND','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_folha','get_vcto_basico','PROCEDURE','get_vcto_basico','SQL','CONTAINS_SQL','NO','DEFINER','v_dominio VARCHAR(255),v_ano VARCHAR(4),v_mes VARCHAR(2),\nv_parcela VARCHAR(3),v_id_cad_servidor VARCHAR(255)','','BEGIN\n	DECLARE r_valor, v_valor DECIMAL(11,2);\n	DECLARE v_referencia, v_anos, v_meses, v_dias, v_i_ano_inicial, v_i_ano_final CHAR(2);\n	DECLARE v_id_referencia, v_id_pccs, v_id_vinculo, v_dias_mes, v_dias_trabalhados INT;\n	DECLARE v_d_admissao DATE; \n	DECLARE done INT DEFAULT FALSE; \n	DECLARE exec INT DEFAULT TRUE;  \n	-- obter referências\n	DECLARE cur1Referencias CURSOR FOR  \n	SELECT fin_referencias.id,/*MAX*/(fin_referencias.valor)valor, cad_classes.i_ano_inicial, cad_classes.i_ano_final \n		FROM fin_referencias \n		JOIN cad_pccs ON cad_pccs.dominio = fin_referencias.dominio \n			AND cad_pccs.id_pccs = fin_referencias.id_pccs \n		JOIN cad_classes ON cad_classes.dominio = fin_referencias.dominio \n			AND cad_classes.id_pccs = cad_pccs.id_pccs \n			AND cad_classes.id_classe = fin_referencias.id_classe \n		WHERE (cad_pccs.dominio=v_dominio) AND (fin_referencias.id_pccs=v_id_pccs) \n			AND (STR_TO_DATE(fin_referencias.data, \'%d/%m/%Y\') <= LAST_DAY(CONCAT(v_ano, \'-\', v_mes, \'-1\'))) \n			AND v_anos BETWEEN CAST(cad_classes.i_ano_inicial AS UNSIGNED) AND CAST(cad_classes.i_ano_final AS UNSIGNED)\n		-- GROUP BY cad_classes.i_ano_inicial, cad_classes.i_ano_final\n		ORDER BY fin_referencias.id_classe DESC, fin_referencias.referencia DESC\n		LIMIT 100000;\n	DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;\n	SET v_dias_mes = DATE_FORMAT(LAST_DAY(CONCAT(v_ano, \'-\', v_mes, \'-1\')), \'%d\');\n	SET v_dias_trabalhados = getDiasPagarVctoBasico(v_id_cad_servidor,v_ano,v_mes);\n	SET v_referencia = v_dias_trabalhados;\n	SET r_valor = 0;\n	-- Registra valor para: v_id_pccs, v_d_admissao, v_anos, v_meses, v_dias \n	SELECT fin_sfuncional.id_pccs,cad_sfuncional.id_vinculo,\n		/*CONCAT(SUBSTR(cad_servidores.d_admissao, 7),\'-\',SUBSTR(cad_servidores.d_admissao, 4,2),\'-\',SUBSTR(cad_servidores.d_admissao, 1,2))*/\n		STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\')data_adm,\n		TIMESTAMPDIFF(YEAR, STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\'), LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) AS anos,\n		TIMESTAMPDIFF(MONTH, STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\') + INTERVAL TIMESTAMPDIFF(YEAR,  STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\'), LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) YEAR , LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) AS meses,\n		TIMESTAMPDIFF(DAY, STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\') + INTERVAL TIMESTAMPDIFF(MONTH,  STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\'), LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) MONTH , LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) + 1 AS dias\n		INTO v_id_pccs, v_id_vinculo, v_d_admissao, v_anos, v_meses, v_dias\n		FROM cad_sfuncional\n		JOIN cad_servidores ON cad_sfuncional.id_cad_servidores = cad_servidores.id\n		JOIN fin_sfuncional ON cad_sfuncional.id_cad_servidores = fin_sfuncional.id_cad_servidores AND \n		cad_sfuncional.ano = fin_sfuncional.ano AND cad_sfuncional.mes = fin_sfuncional.mes AND\n		cad_sfuncional.parcela = fin_sfuncional.parcela\n		WHERE fin_sfuncional.ano = v_ano AND fin_sfuncional.mes = v_mes AND fin_sfuncional.parcela = v_parcela \n		AND fin_sfuncional.id_cad_servidores = v_id_cad_servidor;\n	-- Varre as referencias para localizar a correta e registrar o valor\n	OPEN cur1Referencias;\n	read_loop: LOOP\n		FETCH cur1Referencias INTO v_id_referencia, v_valor, v_i_ano_inicial, v_i_ano_final;\n		IF done THEN\n			LEAVE read_loop;\n		END IF;\n		IF !(v_anos = v_i_ano_final && (v_meses != 0 || v_dias != 0)) THEN\n			SET r_valor = ((v_valor / v_dias_mes) * v_dias_trabalhados);\n			IF v_i_ano_final != 0 AND v_i_ano_inicial != 99 THEN\n				SET done = TRUE;\n			ELSE \n				SET done = FALSE;\n			END IF;\n		END IF;\n	END LOOP;\n	CLOSE cur1Referencias;\n	-- armazena o id_fin_eventos baseado em cad_sfuncional.id_vinculo\n	IF (v_id_vinculo < 4) THEN\n		SET v_id_vinculo = (SELECT id FROM fin_eventos WHERE dominio = v_dominio AND id_evento = \'001\');\n	ELSEIF (v_id_vinculo BETWEEN 4 AND 5) THEN\n		SET v_id_vinculo = (SELECT id FROM fin_eventos WHERE dominio = v_dominio AND id_evento = \'003\');\n	ELSEIF (v_id_vinculo = 6) THEN \n		SET v_id_vinculo = (SELECT id FROM fin_eventos WHERE dominio = v_dominio AND id_evento = \'002\');\n	END IF;\n	SELECT v_id_referencia, v_dias_trabalhados, v_id_pccs, v_id_vinculo, v_d_admissao, v_anos, v_meses, v_dias, r_valor, exec, v_dias_mes;\nEND','root@localhost','2019-06-13 10:02:41','2019-06-13 10:02:41','NO_AUTO_VALUE_ON_ZERO','','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN\n	DECLARE r_valor, v_valor DECIMAL(11,2);\n	DECLARE v_referencia, v_anos, v_meses, v_dias, v_i_ano_inicial, v_i_ano_final CHAR(2);\n	DECLARE v_id_referencia, v_id_pccs, v_id_vinculo, v_dias_mes, v_dias_trabalhados INT;\n	DECLARE v_d_admissao DATE; \n	DECLARE done INT DEFAULT FALSE; \n	DECLARE exec INT DEFAULT TRUE;  \n	-- obter referências\n	DECLARE cur1Referencias CURSOR FOR  \n	SELECT fin_referencias.id,/*MAX*/(fin_referencias.valor)valor, cad_classes.i_ano_inicial, cad_classes.i_ano_final \n		FROM fin_referencias \n		JOIN cad_pccs ON cad_pccs.dominio = fin_referencias.dominio \n			AND cad_pccs.id_pccs = fin_referencias.id_pccs \n		JOIN cad_classes ON cad_classes.dominio = fin_referencias.dominio \n			AND cad_classes.id_pccs = cad_pccs.id_pccs \n			AND cad_classes.id_classe = fin_referencias.id_classe \n		WHERE (cad_pccs.dominio=v_dominio) AND (fin_referencias.id_pccs=v_id_pccs) \n			AND (STR_TO_DATE(fin_referencias.data, \'%d/%m/%Y\') <= LAST_DAY(CONCAT(v_ano, \'-\', v_mes, \'-1\'))) \n			AND v_anos BETWEEN CAST(cad_classes.i_ano_inicial AS UNSIGNED) AND CAST(cad_classes.i_ano_final AS UNSIGNED)\n		-- GROUP BY cad_classes.i_ano_inicial, cad_classes.i_ano_final\n		ORDER BY fin_referencias.id_classe DESC, fin_referencias.referencia DESC\n		LIMIT 100000;\n	DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;\n	SET v_dias_mes = DATE_FORMAT(LAST_DAY(CONCAT(v_ano, \'-\', v_mes, \'-1\')), \'%d\');\n	SET v_dias_trabalhados = getDiasPagarVctoBasico(v_id_cad_servidor,v_ano,v_mes);\n	SET v_referencia = v_dias_trabalhados;\n	SET r_valor = 0;\n	-- Registra valor para: v_id_pccs, v_d_admissao, v_anos, v_meses, v_dias \n	SELECT fin_sfuncional.id_pccs,cad_sfuncional.id_vinculo,\n		/*CONCAT(SUBSTR(cad_servidores.d_admissao, 7),\'-\',SUBSTR(cad_servidores.d_admissao, 4,2),\'-\',SUBSTR(cad_servidores.d_admissao, 1,2))*/\n		STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\')data_adm,\n		TIMESTAMPDIFF(YEAR, STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\'), LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) AS anos,\n		TIMESTAMPDIFF(MONTH, STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\') + INTERVAL TIMESTAMPDIFF(YEAR,  STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\'), LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) YEAR , LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) AS meses,\n		TIMESTAMPDIFF(DAY, STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\') + INTERVAL TIMESTAMPDIFF(MONTH,  STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\'), LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) MONTH , LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) + 1 AS dias\n		INTO v_id_pccs, v_id_vinculo, v_d_admissao, v_anos, v_meses, v_dias\n		FROM cad_sfuncional\n		JOIN cad_servidores ON cad_sfuncional.id_cad_servidores = cad_servidores.id\n		JOIN fin_sfuncional ON cad_sfuncional.id_cad_servidores = fin_sfuncional.id_cad_servidores AND \n		cad_sfuncional.ano = fin_sfuncional.ano AND cad_sfuncional.mes = fin_sfuncional.mes AND\n		cad_sfuncional.parcela = fin_sfuncional.parcela\n		WHERE fin_sfuncional.ano = v_ano AND fin_sfuncional.mes = v_mes AND fin_sfuncional.parcela = v_parcela \n		AND fin_sfuncional.id_cad_servidores = v_id_cad_servidor;\n	-- Varre as referencias para localizar a correta e registrar o valor\n	OPEN cur1Referencias;\n	read_loop: LOOP\n		FETCH cur1Referencias INTO v_id_referencia, v_valor, v_i_ano_inicial, v_i_ano_final;\n		IF done THEN\n			LEAVE read_loop;\n		END IF;\n		IF !(v_anos = v_i_ano_final && (v_meses != 0 || v_dias != 0)) THEN\n			SET r_valor = ((v_valor / v_dias_mes) * v_dias_trabalhados);\n			IF v_i_ano_final != 0 AND v_i_ano_inicial != 99 THEN\n				SET done = TRUE;\n			ELSE \n				SET done = FALSE;\n			END IF;\n		END IF;\n	END LOOP;\n	CLOSE cur1Referencias;\n	-- armazena o id_fin_eventos baseado em cad_sfuncional.id_vinculo\n	IF (v_id_vinculo < 4) THEN\n		SET v_id_vinculo = (SELECT id FROM fin_eventos WHERE dominio = v_dominio AND id_evento = \'001\');\n	ELSEIF (v_id_vinculo BETWEEN 4 AND 5) THEN\n		SET v_id_vinculo = (SELECT id FROM fin_eventos WHERE dominio = v_dominio AND id_evento = \'003\');\n	ELSEIF (v_id_vinculo = 6) THEN \n		SET v_id_vinculo = (SELECT id FROM fin_eventos WHERE dominio = v_dominio AND id_evento = \'002\');\n	END IF;\n	SELECT v_id_referencia, v_dias_trabalhados, v_id_pccs, v_id_vinculo, v_d_admissao, v_anos, v_meses, v_dias, r_valor, exec, v_dias_mes;\nEND','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_desenvolvimento','getDFPcc','FUNCTION','getDFPcc','SQL','CONTAINS_SQL','NO','DEFINER','v_dominio VARCHAR(255),v_ano VARCHAR(4),v_mes VARCHAR(2),\n	v_parcela VARCHAR(3),v_id_cad_servidor VARCHAR(255)','int(11)','BEGIN\n    DECLARE v_id_cad_pccs INT(11);    \n	SELECT fin_sfuncional.id_cad_pccs\n	FROM fin_sfuncional\n	WHERE fin_sfuncional.dominio = v_dominio AND fin_sfuncional.ano = v_ano \n	AND fin_sfuncional.mes = v_mes AND fin_sfuncional.parcela = v_parcela \n	AND fin_sfuncional.id_cad_servidores = v_id_cad_servidor\n	INTO v_id_cad_pccs;\n    RETURN v_id_cad_pccs;\n    END','root@localhost','2019-06-19 16:46:24','2019-06-19 16:46:24','NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION','Retorna o PCC de um servidor','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN\n    DECLARE v_id_cad_pccs INT(11);    \n	SELECT fin_sfuncional.id_cad_pccs\n	FROM fin_sfuncional\n	WHERE fin_sfuncional.dominio = v_dominio AND fin_sfuncional.ano = v_ano \n	AND fin_sfuncional.mes = v_mes AND fin_sfuncional.parcela = v_parcela \n	AND fin_sfuncional.id_cad_servidores = v_id_cad_servidor\n	INTO v_id_cad_pccs;\n    RETURN v_id_cad_pccs;\n    END','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_desenvolvimento','getFinRubricaPrazo','FUNCTION','getFinRubricaPrazo','SQL','CONTAINS_SQL','NO','DEFINER','prazo int, prazot int','int(11)','BEGIN\n	declare prazo_final int(3); -- prazo a retornar\n	if prazot = prazo then\n		set prazo_final = prazo;\n	elseIF prazot > prazo THEN\n		SET prazo_final = prazo + 1;\n	end if;\n	return prazo_final;\n    END','root@localhost','2019-06-18 08:06:09','2019-06-18 08:06:09','NO_AUTO_VALUE_ON_ZERO','Retorna o prazo inicial baseado nos prazos inicial e final passados','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN\n	declare prazo_final int(3); -- prazo a retornar\n	if prazot = prazo then\n		set prazo_final = prazo;\n	elseIF prazot > prazo THEN\n		SET prazo_final = prazo + 1;\n	end if;\n	return prazo_final;\n    END','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_desenvolvimento','getFinRubricaPrazoT','FUNCTION','getFinRubricaPrazoT','SQL','CONTAINS_SQL','NO','DEFINER','prazo int, prazot int','int(11)','BEGIN\n	declare prazo_final int(3); -- prazo a retornar\n	if (prazot = prazo) && ((prazot = \'999\') || (prazot = \'1\')) then\n		set prazo_final = prazot;\n	elseIF prazot > prazo THEN\n		SET prazo_final = prazo + 1;\n	end if;\n	return prazo_final;\n    END','root@localhost','2019-06-18 08:06:09','2019-06-18 08:06:09','NO_AUTO_VALUE_ON_ZERO','Retorna o prazo final baseado nos prazos inicial e final passados','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN\n	declare prazo_final int(3); -- prazo a retornar\n	if (prazot = prazo) && ((prazot = \'999\') || (prazot = \'1\')) then\n		set prazo_final = prazot;\n	elseIF prazot > prazo THEN\n		SET prazo_final = prazo + 1;\n	end if;\n	return prazo_final;\n    END','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_desenvolvimento','getIdVinculo','FUNCTION','getIdVinculo','SQL','CONTAINS_SQL','YES','DEFINER','v_dominio VARCHAR(255),v_id_vinculo INT','int(11)','BEGIN\n	DECLARE r_id_vinculo INT;\n	IF (v_id_vinculo < 4) THEN\n		SET r_id_vinculo = (SELECT id FROM fin_eventos WHERE dominio = v_dominio AND id_evento = \'001\');\n	ELSEIF (v_id_vinculo BETWEEN 4 AND 5) THEN\n		SET r_id_vinculo = (SELECT id FROM fin_eventos WHERE dominio = v_dominio AND id_evento = \'003\');\n	ELSEIF (v_id_vinculo = 6) THEN \n		SET r_id_vinculo = (SELECT id FROM fin_eventos WHERE dominio = v_dominio AND id_evento = \'002\');\n	ELSE \n		SET r_id_vinculo = 0;\n	END IF;\n	RETURN r_id_vinculo;\n    END','root@localhost','2019-06-18 08:06:09','2019-06-18 08:06:09','NO_AUTO_VALUE_ON_ZERO','Retorna o id_fin_eventos baseado em cad_sfuncional.id_vinculo','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN\n	DECLARE r_id_vinculo INT;\n	IF (v_id_vinculo < 4) THEN\n		SET r_id_vinculo = (SELECT id FROM fin_eventos WHERE dominio = v_dominio AND id_evento = \'001\');\n	ELSEIF (v_id_vinculo BETWEEN 4 AND 5) THEN\n		SET r_id_vinculo = (SELECT id FROM fin_eventos WHERE dominio = v_dominio AND id_evento = \'003\');\n	ELSEIF (v_id_vinculo = 6) THEN \n		SET r_id_vinculo = (SELECT id FROM fin_eventos WHERE dominio = v_dominio AND id_evento = \'002\');\n	ELSE \n		SET r_id_vinculo = 0;\n	END IF;\n	RETURN r_id_vinculo;\n    END','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_desenvolvimento','getSFalecimento','FUNCTION','getSFalecimento','SQL','CONTAINS_SQL','NO','DEFINER','v_id_cad_servidores INT','int(11)','BEGIN	\n	declare quant int;\n	SELECT COUNT(*)\n		FROM `cad_smovimentacao` \n		WHERE (`id_cad_servidores`=v_id_cad_servidores) \n		AND ((`codigo_afastamento`=\'S2\') OR (`codigo_afastamento`=\'S3\')) into quant;\n	return quant;\n    END','root@localhost','2019-06-18 08:06:09','2019-06-18 08:06:09','NO_AUTO_VALUE_ON_ZERO','Retorna um model caso o servidor esteja falecido ou null caso não esteja','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN	\n	declare quant int;\n	SELECT COUNT(*)\n		FROM `cad_smovimentacao` \n		WHERE (`id_cad_servidores`=v_id_cad_servidores) \n		AND ((`codigo_afastamento`=\'S2\') OR (`codigo_afastamento`=\'S3\')) into quant;\n	return quant;\n    END','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_desenvolvimento','getCodAfastamento','FUNCTION','getCodAfastamento','SQL','CONTAINS_SQL','YES','DEFINER','v VARCHAR(2)','varchar(500) CHARSET latin1','BEGIN\n	DECLARE RETORNO VARCHAR(500);\n	SET RETORNO = CASE v\n		WHEN \'Q1\' THEN \'Q1 - AFASTAMENTO TEMPORÁRIO POR MOTIVO DE LICENÇA-MATERNIDADE (120 DIAS)\'\n		WHEN \'X\' THEN \'X - LICENÇA SEM VENCIMENTOS\'\n		WHEN \'P1\' THEN \'P1 - AFASTAMENTO TEMPORÁRIO POR MOTIVO DE DOENÇA, POR PERÍODO SUPERIOR A 15 DIAS\'\n		WHEN \'H\' THEN \'H  - RESCISÃO, COM JUSTA CAUSA, POR INICIATIVA DO EMPREGADOR\'\n		WHEN \'I1\' THEN \'I1 - RESCISÃO SEM JUSTA CAUSA, POR INICIATIVA DO EMPREGADOR, INCLUSIVE RESCISÃO ANTECIPADA DO CONTRATO A TERMO\'\n		WHEN \'I2\' THEN \'I2 - RESCISÃO POR CULPA RECÍPROCA OU FORÇA MAIOR\'\n		WHEN \'I3\' THEN \'I3 - RESCISÃO POR TÉRMINO DO CONTRATO A TERMO\'\n		WHEN \'I4\' THEN \'I4 - RESCISÃO SEM JUSTA CAUSA DO CONTRATO DE TRABALHO DO EMPREGADO DOMÉSTICO, POR INICIATIVA DO EMPREGADOR\'\n		WHEN \'J\' THEN \'J  - RESCISÃO DO CONTRATO DE TRABALHO POR INICIATIVA DO EMPREGADO\'\n		WHEN \'K\' THEN \'K  - RESCISÃO A PEDIDO DO EMPREGADO OU POR INICIATIVA DO EMPREGADOR, COM JUSTA CAUSA, NO CASO DE EMPREGADO NÃO OPTANTE, COM MENOS DE UM ANO DE SERVIÇO\'\n		WHEN \'L\' THEN \'L  - OUTROS MOTIVOS DE RESCISÃO DO CONTRATO DE TRABALHO\'\n		WHEN \'S2\' THEN \'S2 - FALECIMENTO\'\n		WHEN \'S3\' THEN \'S3 - FALECIMENTO MOTIVADO POR ACIDENTE DE TRABALHO\'\n		WHEN \'U1\' THEN \'U1 - APOSENTADORIA\'\n		WHEN \'U3\' THEN \'U3 - APOSENTADORIA POR INVALIDEZ\' \n		ELSE NULL END;\n	RETURN RETORNO;\n    END','root@localhost','2019-06-19 16:46:54','2019-06-19 16:46:54','NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION','Retorna os labels dos códigos de afastamento','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN\n	DECLARE RETORNO VARCHAR(500);\n	SET RETORNO = CASE v\n		WHEN \'Q1\' THEN \'Q1 - AFASTAMENTO TEMPORÁRIO POR MOTIVO DE LICENÇA-MATERNIDADE (120 DIAS)\'\n		WHEN \'X\' THEN \'X - LICENÇA SEM VENCIMENTOS\'\n		WHEN \'P1\' THEN \'P1 - AFASTAMENTO TEMPORÁRIO POR MOTIVO DE DOENÇA, POR PERÍODO SUPERIOR A 15 DIAS\'\n		WHEN \'H\' THEN \'H  - RESCISÃO, COM JUSTA CAUSA, POR INICIATIVA DO EMPREGADOR\'\n		WHEN \'I1\' THEN \'I1 - RESCISÃO SEM JUSTA CAUSA, POR INICIATIVA DO EMPREGADOR, INCLUSIVE RESCISÃO ANTECIPADA DO CONTRATO A TERMO\'\n		WHEN \'I2\' THEN \'I2 - RESCISÃO POR CULPA RECÍPROCA OU FORÇA MAIOR\'\n		WHEN \'I3\' THEN \'I3 - RESCISÃO POR TÉRMINO DO CONTRATO A TERMO\'\n		WHEN \'I4\' THEN \'I4 - RESCISÃO SEM JUSTA CAUSA DO CONTRATO DE TRABALHO DO EMPREGADO DOMÉSTICO, POR INICIATIVA DO EMPREGADOR\'\n		WHEN \'J\' THEN \'J  - RESCISÃO DO CONTRATO DE TRABALHO POR INICIATIVA DO EMPREGADO\'\n		WHEN \'K\' THEN \'K  - RESCISÃO A PEDIDO DO EMPREGADO OU POR INICIATIVA DO EMPREGADOR, COM JUSTA CAUSA, NO CASO DE EMPREGADO NÃO OPTANTE, COM MENOS DE UM ANO DE SERVIÇO\'\n		WHEN \'L\' THEN \'L  - OUTROS MOTIVOS DE RESCISÃO DO CONTRATO DE TRABALHO\'\n		WHEN \'S2\' THEN \'S2 - FALECIMENTO\'\n		WHEN \'S3\' THEN \'S3 - FALECIMENTO MOTIVADO POR ACIDENTE DE TRABALHO\'\n		WHEN \'U1\' THEN \'U1 - APOSENTADORIA\'\n		WHEN \'U3\' THEN \'U3 - APOSENTADORIA POR INVALIDEZ\' \n		ELSE NULL END;\n	RETURN RETORNO;\n    END','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_desenvolvimento','getDiasPagarVctoBasico','FUNCTION','getDiasPagarVctoBasico','SQL','CONTAINS_SQL','YES','DEFINER','ics INT(11),ano_f CHAR(4),mes_f CHAR(2)','varchar(255) CHARSET latin1','BEGIN\n    DECLARE dias/*dias do período de cálculo*/\n    , dias_p/*CONSTANTE: dias antes de ir para previdência*/ INT(2);\n    DECLARE d_afastamento, d_limite/*data limite antes de ir para previdência*/\n    , d_admissao/*data de admissao*/\n    , d_retorno/*data do retorno*/\n    , udm0 /*último dia do mês anterior*/\n    , udm1 /*último dia do mês atual*/ DATE;\n    DECLARE codigo_afastamento VARCHAR(2);\n    DECLARE r VARCHAR(255);\n    -- dias de afastamento em que a autarquia paga antes de ir para previdência\n    SET dias_p = 15;\n    -- último dia do mês anterior\n    SET udm0 = LAST_DAY(DATE_SUB(CAST(CONCAT(ano_f,\'-\',mes_f,\'-01\') AS DATE), INTERVAL 1 MONTH));\n    -- último dia do mês atual\n    SET udm1 = LAST_DAY(CAST(CONCAT(ano_f,\'-\',mes_f,\'-01\') AS DATE));\n	SELECT STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\') AS d_admissao,	\n		STR_TO_DATE(cad_smovimentacao.d_afastamento, \'%d/%m/%Y\') AS d_afastamento,\n		STR_TO_DATE(cad_smovimentacao.d_retorno, \'%d/%m/%Y\') AS d_retorno,\n		cad_smovimentacao.codigo_afastamento AS codigo_afastamento\n		FROM cad_servidores\n		LEFT JOIN cad_smovimentacao ON cad_servidores.id = cad_smovimentacao.id_cad_servidores \n			AND cad_servidores.dominio = cad_smovimentacao.dominio\n		WHERE cad_servidores.id = ics\n		ORDER BY STR_TO_DATE(cad_smovimentacao.d_afastamento, \'%d/%m/%Y\') DESC\n		LIMIT 1 \n		INTO d_admissao, d_afastamento, d_retorno, codigo_afastamento;\n	IF codigo_afastamento = \'P1\' /*calculo dos dias em caso de afastamento temporário\n		por motivo de doença, por período superior à variável dias_p*/ THEN		\n		SET dias = DAY(d_afastamento) + dias_p;\n		SET d_limite = DATE_ADD(d_afastamento, INTERVAL dias_p DAY);\n		/*Se a data limite(afastamento) for posterior ou igual ao último dia do mês atual*/\n		IF d_limite >= udm1 THEN\n			/*dias a pagar é igual ao total de dias do mês atual pois \n			ou estourou o mês ou o final do prazo acaba no último dia*/\n			SET dias = DAY(udm1);\n			SET r = \'0\';\n		/*Se a data limite for anterior ao último dia do mês atual e o periodo for o mesmo*/\n		ELSEIF d_limite < udm1 AND \n		CONCAT(YEAR(d_limite),MONTH(d_limite)) = CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = DAY(d_limite);\n			SET r = \'1\';\n		/*Se a data limite for anterior ao último dia do mês atual e o periodo for outro*/\n		ELSEIF d_limite < udm1 AND \n		CONCAT(YEAR(d_limite),MONTH(d_limite)) != CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = 0;\n			SET r = \'2\';\n		END IF;\n		/*Adicionar os dias após o retorno à variável dias acima*/\n		/*Se a data de retorno for registrada e for no mês corrente(atual)*/\n		IF d_retorno IS NOT NULL \n		AND CONCAT(YEAR(d_retorno),MONTH(d_retorno)) = CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = dias + DATEDIFF(udm1,d_retorno);\n			SET r = \'3\';\n		ELSEIF d_retorno IS NOT NULL AND d_retorno < udm1 THEN\n			SET dias = DAY(udm1);\n			SET r = \'4\';\n		END IF;\n	ELSEIF codigo_afastamento = \'X\' /*calculo dos dias em caso de licença sem vencimento*/ THEN		\n		SET dias = DAY(d_afastamento);\n		SET d_limite = d_afastamento;\n		/*Se a data limite(afastamento) for posterior ou igual ao último dia do mês atual*/\n		IF d_limite >= udm1 THEN\n			/*dias a pagar é igual ao total de dias do mês atual pois \n			ou estourou o mês ou o final do prazo acaba no último dia*/\n			SET dias = DAY(udm1);\n			SET r = \'5\';\n		/*Se a data limite for anterior ao último dia do mês atual e o periodo for o mesmo*/\n		ELSEIF d_limite < udm1 AND \n		CONCAT(YEAR(d_limite),MONTH(d_limite)) = CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = DAY(d_limite);\n			SET r = \'6\';\n		/*Se a data limite for anterior ao último dia do mês atual e o periodo for outro*/\n		ELSEIF d_limite < udm1 AND \n		CONCAT(YEAR(d_limite),MONTH(d_limite)) != CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = 0;\n			SET r = \'7\';\n		END IF;\n		SET d_retorno = DATE_SUB(d_retorno, INTERVAL 1 DAY);\n		/*Adicionar os dias após o retorno à variável dias acima*/\n		/*Se a data de retorno for registrada e for no mês corrente(atual)*/\n		IF d_retorno IS NOT NULL \n		AND CONCAT(YEAR(d_retorno),MONTH(d_retorno)) = CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = dias + DATEDIFF(udm1,d_retorno);\n			SET r = \'8\';\n		ELSEIF d_retorno IS NOT NULL AND d_retorno < udm1 THEN\n			SET dias = DAY(udm1);\n			SET r = \'9\';\n		END IF;\n	-- calculo dos dias em caso de licença maternidade\n	/*ELSEIF codigo_afastamento = \'Q1\' THEN		\n		SET dias = DAY(d_afastamento);\n		SET d_limite = d_afastamento;\n		-- Se a data limite(afastamento) for posterior ao último dia do mês atual\n		IF d_limite > udm1 THEN\n			-- dias a pagar é igual ao total de dias do mês atual pois \n			-- a servidora ainda não saiu de licença\n			SET dias = DAY(udm1);\n			SET r = \'Q1:0\';\n		-- Se a data limite for anterior ao último dia do mês atual e o periodo for o mesmo\n		ELSEIF d_limite < udm1 AND \n		CONCAT(YEAR(d_limite),MONTH(d_limite)) = CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = DAY(d_limite) - 1;\n			SET r = \'Q1:1\';\n		-- Se a data limite for anterior ao último dia do mês atual e o periodo for outro\n		ELSEIF d_limite < udm1 AND \n		CONCAT(YEAR(d_limite),MONTH(d_limite)) != CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = 0;\n			SET r = \'Q1:2\';\n		END IF;\n		-- Adicionar os dias após o retorno à variável dias acima\n		-- Se a data de retorno for registrada e for no mês corrente(atual)\n		IF d_retorno IS NOT NULL \n		AND CONCAT(YEAR(d_retorno),MONTH(d_retorno)) = CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = dias + DATEDIFF(udm1,d_retorno);\n			SET r = \'Q1:3\';\n		-- Se a data de retorno é anterior ao primeiro dia do mês\n		ELSEIF d_retorno IS NOT NULL AND d_retorno < ADDDATE(LAST_DAY(DATE_SUB(udm1, INTERVAL 1 MONTH)),1) THEN\n			SET dias = DAY(udm1);\n			SET r = \'Q1:4\';\n		END IF;\n	*/\n	ELSEIF codigo_afastamento IS NOT NULL && codigo_afastamento != \'P1\'\n	 && codigo_afastamento != \'Q1\' && codigo_afastamento != \'X\' /*calculo dos dias em caso de demissão*/ THEN		\n		SET dias = DAY(d_afastamento);\n		SET d_limite = d_afastamento;\n		/*Se a data limite(afastamento) for posterior ou igual ao último dia do mês atual*/\n		IF d_limite > udm1 THEN\n			/*dias a pagar é igual ao total de dias do mês atual pois \n			pertence a outro período*/\n			SET dias = DAY(udm1);\n			SET r = \'Demiss0\';\n		/*Se a data limite for anterior ou igual ao último dia do mês atual e o periodo for o mesmo*/\n		ELSEIF d_limite <= udm1 AND \n		CONCAT(YEAR(d_limite),MONTH(d_limite)) = CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = DAY(d_limite);\n			SET r = \'Demiss1\';\n		/*Se a data limite for anterior ao último dia do mês atual e o periodo for outro*/\n		ELSEIF d_limite < udm1 AND \n		CONCAT(YEAR(d_limite),MONTH(d_limite)) != CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = 0;\n			SET r = \'Demiss2\';\n		END IF;\n	ELSEIF LAST_DAY(d_admissao) = udm1 THEN\n	/*calculo dos dias em caso de admissão no periodo informado*/\n		SET dias = DAY(udm1) - DAY(d_admissao) + 1;\n		SET r = \'10\';\n	ELSE\n	/*caso não atenda nenhuma das situações acima*/\n		SET dias = DAY(udm1);\n		SET r = \'11\';\n	END IF;\n	\nRETURN dias;-- concat(\'da: \',d_afastamento,\' > ca: \',codigo_afastamento,\' > dl: \',d_limite,\' > pos: \',r,\' > dias: \',dias);\nEND','root@localhost','2019-06-18 11:28:28','2019-06-18 11:28:28','NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION','','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN\n    DECLARE dias/*dias do período de cálculo*/\n    , dias_p/*CONSTANTE: dias antes de ir para previdência*/ INT(2);\n    DECLARE d_afastamento, d_limite/*data limite antes de ir para previdência*/\n    , d_admissao/*data de admissao*/\n    , d_retorno/*data do retorno*/\n    , udm0 /*último dia do mês anterior*/\n    , udm1 /*último dia do mês atual*/ DATE;\n    DECLARE codigo_afastamento VARCHAR(2);\n    DECLARE r VARCHAR(255);\n    -- dias de afastamento em que a autarquia paga antes de ir para previdência\n    SET dias_p = 15;\n    -- último dia do mês anterior\n    SET udm0 = LAST_DAY(DATE_SUB(CAST(CONCAT(ano_f,\'-\',mes_f,\'-01\') AS DATE), INTERVAL 1 MONTH));\n    -- último dia do mês atual\n    SET udm1 = LAST_DAY(CAST(CONCAT(ano_f,\'-\',mes_f,\'-01\') AS DATE));\n	SELECT STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\') AS d_admissao,	\n		STR_TO_DATE(cad_smovimentacao.d_afastamento, \'%d/%m/%Y\') AS d_afastamento,\n		STR_TO_DATE(cad_smovimentacao.d_retorno, \'%d/%m/%Y\') AS d_retorno,\n		cad_smovimentacao.codigo_afastamento AS codigo_afastamento\n		FROM cad_servidores\n		LEFT JOIN cad_smovimentacao ON cad_servidores.id = cad_smovimentacao.id_cad_servidores \n			AND cad_servidores.dominio = cad_smovimentacao.dominio\n		WHERE cad_servidores.id = ics\n		ORDER BY STR_TO_DATE(cad_smovimentacao.d_afastamento, \'%d/%m/%Y\') DESC\n		LIMIT 1 \n		INTO d_admissao, d_afastamento, d_retorno, codigo_afastamento;\n	IF codigo_afastamento = \'P1\' /*calculo dos dias em caso de afastamento temporário\n		por motivo de doença, por período superior à variável dias_p*/ THEN		\n		SET dias = DAY(d_afastamento) + dias_p;\n		SET d_limite = DATE_ADD(d_afastamento, INTERVAL dias_p DAY);\n		/*Se a data limite(afastamento) for posterior ou igual ao último dia do mês atual*/\n		IF d_limite >= udm1 THEN\n			/*dias a pagar é igual ao total de dias do mês atual pois \n			ou estourou o mês ou o final do prazo acaba no último dia*/\n			SET dias = DAY(udm1);\n			SET r = \'0\';\n		/*Se a data limite for anterior ao último dia do mês atual e o periodo for o mesmo*/\n		ELSEIF d_limite < udm1 AND \n		CONCAT(YEAR(d_limite),MONTH(d_limite)) = CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = DAY(d_limite);\n			SET r = \'1\';\n		/*Se a data limite for anterior ao último dia do mês atual e o periodo for outro*/\n		ELSEIF d_limite < udm1 AND \n		CONCAT(YEAR(d_limite),MONTH(d_limite)) != CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = 0;\n			SET r = \'2\';\n		END IF;\n		/*Adicionar os dias após o retorno à variável dias acima*/\n		/*Se a data de retorno for registrada e for no mês corrente(atual)*/\n		IF d_retorno IS NOT NULL \n		AND CONCAT(YEAR(d_retorno),MONTH(d_retorno)) = CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = dias + DATEDIFF(udm1,d_retorno);\n			SET r = \'3\';\n		ELSEIF d_retorno IS NOT NULL AND d_retorno < udm1 THEN\n			SET dias = DAY(udm1);\n			SET r = \'4\';\n		END IF;\n	ELSEIF codigo_afastamento = \'X\' /*calculo dos dias em caso de licença sem vencimento*/ THEN		\n		SET dias = DAY(d_afastamento);\n		SET d_limite = d_afastamento;\n		/*Se a data limite(afastamento) for posterior ou igual ao último dia do mês atual*/\n		IF d_limite >= udm1 THEN\n			/*dias a pagar é igual ao total de dias do mês atual pois \n			ou estourou o mês ou o final do prazo acaba no último dia*/\n			SET dias = DAY(udm1);\n			SET r = \'5\';\n		/*Se a data limite for anterior ao último dia do mês atual e o periodo for o mesmo*/\n		ELSEIF d_limite < udm1 AND \n		CONCAT(YEAR(d_limite),MONTH(d_limite)) = CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = DAY(d_limite);\n			SET r = \'6\';\n		/*Se a data limite for anterior ao último dia do mês atual e o periodo for outro*/\n		ELSEIF d_limite < udm1 AND \n		CONCAT(YEAR(d_limite),MONTH(d_limite)) != CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = 0;\n			SET r = \'7\';\n		END IF;\n		SET d_retorno = DATE_SUB(d_retorno, INTERVAL 1 DAY);\n		/*Adicionar os dias após o retorno à variável dias acima*/\n		/*Se a data de retorno for registrada e for no mês corrente(atual)*/\n		IF d_retorno IS NOT NULL \n		AND CONCAT(YEAR(d_retorno),MONTH(d_retorno)) = CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = dias + DATEDIFF(udm1,d_retorno);\n			SET r = \'8\';\n		ELSEIF d_retorno IS NOT NULL AND d_retorno < udm1 THEN\n			SET dias = DAY(udm1);\n			SET r = \'9\';\n		END IF;\n	-- calculo dos dias em caso de licença maternidade\n	/*ELSEIF codigo_afastamento = \'Q1\' THEN		\n		SET dias = DAY(d_afastamento);\n		SET d_limite = d_afastamento;\n		-- Se a data limite(afastamento) for posterior ao último dia do mês atual\n		IF d_limite > udm1 THEN\n			-- dias a pagar é igual ao total de dias do mês atual pois \n			-- a servidora ainda não saiu de licença\n			SET dias = DAY(udm1);\n			SET r = \'Q1:0\';\n		-- Se a data limite for anterior ao último dia do mês atual e o periodo for o mesmo\n		ELSEIF d_limite < udm1 AND \n		CONCAT(YEAR(d_limite),MONTH(d_limite)) = CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = DAY(d_limite) - 1;\n			SET r = \'Q1:1\';\n		-- Se a data limite for anterior ao último dia do mês atual e o periodo for outro\n		ELSEIF d_limite < udm1 AND \n		CONCAT(YEAR(d_limite),MONTH(d_limite)) != CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = 0;\n			SET r = \'Q1:2\';\n		END IF;\n		-- Adicionar os dias após o retorno à variável dias acima\n		-- Se a data de retorno for registrada e for no mês corrente(atual)\n		IF d_retorno IS NOT NULL \n		AND CONCAT(YEAR(d_retorno),MONTH(d_retorno)) = CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = dias + DATEDIFF(udm1,d_retorno);\n			SET r = \'Q1:3\';\n		-- Se a data de retorno é anterior ao primeiro dia do mês\n		ELSEIF d_retorno IS NOT NULL AND d_retorno < ADDDATE(LAST_DAY(DATE_SUB(udm1, INTERVAL 1 MONTH)),1) THEN\n			SET dias = DAY(udm1);\n			SET r = \'Q1:4\';\n		END IF;\n	*/\n	ELSEIF codigo_afastamento IS NOT NULL && codigo_afastamento != \'P1\'\n	 && codigo_afastamento != \'Q1\' && codigo_afastamento != \'X\' /*calculo dos dias em caso de demissão*/ THEN		\n		SET dias = DAY(d_afastamento);\n		SET d_limite = d_afastamento;\n		/*Se a data limite(afastamento) for posterior ou igual ao último dia do mês atual*/\n		IF d_limite > udm1 THEN\n			/*dias a pagar é igual ao total de dias do mês atual pois \n			pertence a outro período*/\n			SET dias = DAY(udm1);\n			SET r = \'Demiss0\';\n		/*Se a data limite for anterior ou igual ao último dia do mês atual e o periodo for o mesmo*/\n		ELSEIF d_limite <= udm1 AND \n		CONCAT(YEAR(d_limite),MONTH(d_limite)) = CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = DAY(d_limite);\n			SET r = \'Demiss1\';\n		/*Se a data limite for anterior ao último dia do mês atual e o periodo for outro*/\n		ELSEIF d_limite < udm1 AND \n		CONCAT(YEAR(d_limite),MONTH(d_limite)) != CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = 0;\n			SET r = \'Demiss2\';\n		END IF;\n	ELSEIF LAST_DAY(d_admissao) = udm1 THEN\n	/*calculo dos dias em caso de admissão no periodo informado*/\n		SET dias = DAY(udm1) - DAY(d_admissao) + 1;\n		SET r = \'10\';\n	ELSE\n	/*caso não atenda nenhuma das situações acima*/\n		SET dias = DAY(udm1);\n		SET r = \'11\';\n	END IF;\n	\nRETURN dias;-- concat(\'da: \',d_afastamento,\' > ca: \',codigo_afastamento,\' > dl: \',d_limite,\' > pos: \',r,\' > dias: \',dias);\nEND','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_desenvolvimento','fin_folha_eventos_basico','PROCEDURE','fin_folha_eventos_basico','SQL','CONTAINS_SQL','NO','DEFINER','v_id_user VARCHAR(255),v_dominio VARCHAR(255),v_ano VARCHAR(4),v_mes VARCHAR(2),\nv_parcela VARCHAR(3),v_id_cad_servidor VARCHAR(255)','','BEGIN\n DECLARE r_valor, v_valor DECIMAL(11,2);\n DECLARE v_referencia, v_anos, v_meses, v_dias CHAR(2);\n DECLARE v_i_ano_inicial, v_i_ano_final CHAR(3);\n DECLARE v_id_pccs, v_id_vinculo, v_dias_mes, v_dias_trabalhados, r_id_evento, r_id_fin_eventos, r_id_fin_rubricas INT;\n DECLARE v_d_admissao DATE; \n DECLARE done INT DEFAULT FALSE; \n DECLARE exec INT DEFAULT TRUE;  \n -- obter referências\n DECLARE cur1Referencias CURSOR FOR  \n	SELECT fin_referencias.valor, cad_classes.i_ano_inicial, cad_classes.i_ano_final \n		FROM fin_referencias \n		JOIN cad_pccs ON cad_pccs.dominio = fin_referencias.dominio \n			AND cad_pccs.id_pccs = fin_referencias.id_pccs \n		JOIN cad_classes ON cad_classes.dominio = fin_referencias.dominio \n			AND cad_classes.id_pccs = cad_pccs.id_pccs \n			AND cad_classes.id_classe = fin_referencias.id_classe \n		WHERE (cad_pccs.dominio=v_dominio) AND (fin_referencias.id_pccs=v_id_pccs) \n			AND (STR_TO_DATE(fin_referencias.data, \'%d/%m/%Y\') <= LAST_DAY(CONCAT(v_ano, \'-\', v_mes, \'-1\'))) \n			AND CAST(v_anos AS UNSIGNED) BETWEEN CAST(cad_classes.i_ano_inicial AS UNSIGNED) AND CAST(cad_classes.i_ano_final AS UNSIGNED)\n		ORDER BY fin_referencias.id_classe DESC, fin_referencias.referencia DESC\n		LIMIT 100000;\n DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;\n \n SET v_dias_mes = DATE_FORMAT(LAST_DAY(CONCAT(v_ano, \'-\', v_mes, \'-1\')), \'%d\');\n SET v_dias_trabalhados = getDiasPagarVctoBasico(v_id_cad_servidor,v_ano,v_mes);\n SET v_referencia = v_dias_trabalhados;\n SET r_valor = 0;\n -- Registra valor para: v_id_pccs, v_d_admissao, v_anos, v_meses, v_dias \n SELECT fin_sfuncional.id_pccs,cad_sfuncional.id_vinculo,\n	/*CONCAT(SUBSTR(cad_servidores.d_admissao, 7),\'-\',SUBSTR(cad_servidores.d_admissao, 4,2),\'-\',SUBSTR(cad_servidores.d_admissao, 1,2))*/\n	STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\')data_adm,\n	TIMESTAMPDIFF(YEAR, STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\'), LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) AS anos,\n	TIMESTAMPDIFF(MONTH, STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\') + INTERVAL TIMESTAMPDIFF(YEAR,  STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\'), LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) YEAR , LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) AS meses,\n	TIMESTAMPDIFF(DAY, STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\') + INTERVAL TIMESTAMPDIFF(MONTH,  STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\'), LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) MONTH , LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) + 1 AS dias\n	INTO v_id_pccs, v_id_vinculo, v_d_admissao, v_anos, v_meses, v_dias\n	FROM cad_sfuncional\n	JOIN cad_servidores ON cad_sfuncional.id_cad_servidores = cad_servidores.id\n	JOIN fin_sfuncional ON cad_sfuncional.id_cad_servidores = fin_sfuncional.id_cad_servidores AND \n	cad_sfuncional.ano = fin_sfuncional.ano AND cad_sfuncional.mes = fin_sfuncional.mes AND\n	cad_sfuncional.parcela = fin_sfuncional.parcela\n	WHERE fin_sfuncional.ano = v_ano AND fin_sfuncional.mes = v_mes AND fin_sfuncional.parcela = v_parcela \n	AND fin_sfuncional.id_cad_servidores = v_id_cad_servidor;\n	-- Varre as referencias para localizar a correta e registrar o valor\n	OPEN cur1Referencias;\n	read_loop: LOOP\n		FETCH cur1Referencias INTO v_valor, v_i_ano_inicial, v_i_ano_final;\n		IF done THEN\n			LEAVE read_loop;\n		END IF;\n		IF !(v_anos = v_i_ano_final && (v_meses != 0 || v_dias != 0)) THEN\n			SET r_valor = ((v_valor / v_dias_mes) * v_dias_trabalhados);\n			IF v_i_ano_final != 0 AND v_i_ano_inicial != 99 THEN\n				SET done = TRUE;\n			ELSE \n				SET done = FALSE;\n			END IF;\n		END IF;\n	END LOOP;\n	CLOSE cur1Referencias;\n	\n SET r_id_fin_eventos = getidvinculo(v_dominio,v_id_vinculo);\n \n IF v_dias_trabalhados > 0 THEN\n	SET exec = TRUE;\n ELSE\n	SET exec = FALSE;\n END IF;\n \nIF exec = TRUE THEN\n	-- Retorna e armazena o último id da tabela fiin_rubricas\n	SET r_id_fin_rubricas = (SELECT MAX(id) FROM fin_rubricas) + 1;\n	/*para garantir a integridade da chave primária, efetua uma segunda verificação e geração de r_id_fin_rubricas, se necessário*/	\n	IF (SELECT id FROM fin_rubricas WHERE id = r_id_fin_rubricas) IS NOT NULL THEN\n		SET r_id_fin_rubricas = r_id_fin_rubricas + 1;\n	END IF;	\n	SET r_id_evento = getEventoSistema(v_dominio,CONCAT(\'Inclusão da rúbrica id: \', r_id_fin_eventos),\'actionC\', \'fin_rubricas\', r_id_fin_rubricas, v_id_user);\n	-- Insere a rúbrica\n	INSERT INTO fin_rubricas (id,slug,STATUS,dominio,evento,created_at,updated_at,\n		id_cad_servidores,id_fin_eventos,\n		ano,mes,parcela,referencia,valor_base,valor,valor_patronal,valor_maternidade,prazo,prazot,desconto,percentual) \n	VALUES(\n		r_id_fin_rubricas,SHA(CONCAT(NOW(),v_dominio,v_id_cad_servidor)),10,v_dominio,r_id_evento,UNIX_TIMESTAMP(NOW()),UNIX_TIMESTAMP(NOW()),\n		v_id_cad_servidor,r_id_fin_eventos,\n		v_ano,v_mes,v_parcela,v_referencia,0.00,r_valor,0.00,0.00,1,1,0.00,100.00\n	);\n END IF; \n /*\nSELECT v_dias_trabalhados, v_id_pccs, r_id_fin_eventos, v_d_admissao, v_anos, v_meses, v_dias, r_valor, exec, v_dias_mes;\n */\nEND','megasses@localhost','2019-06-13 09:48:24','2019-06-13 09:48:24','NO_AUTO_VALUE_ON_ZERO','','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN\n DECLARE r_valor, v_valor DECIMAL(11,2);\n DECLARE v_referencia, v_anos, v_meses, v_dias CHAR(2);\n DECLARE v_i_ano_inicial, v_i_ano_final CHAR(3);\n DECLARE v_id_pccs, v_id_vinculo, v_dias_mes, v_dias_trabalhados, r_id_evento, r_id_fin_eventos, r_id_fin_rubricas INT;\n DECLARE v_d_admissao DATE; \n DECLARE done INT DEFAULT FALSE; \n DECLARE exec INT DEFAULT TRUE;  \n -- obter referências\n DECLARE cur1Referencias CURSOR FOR  \n	SELECT fin_referencias.valor, cad_classes.i_ano_inicial, cad_classes.i_ano_final \n		FROM fin_referencias \n		JOIN cad_pccs ON cad_pccs.dominio = fin_referencias.dominio \n			AND cad_pccs.id_pccs = fin_referencias.id_pccs \n		JOIN cad_classes ON cad_classes.dominio = fin_referencias.dominio \n			AND cad_classes.id_pccs = cad_pccs.id_pccs \n			AND cad_classes.id_classe = fin_referencias.id_classe \n		WHERE (cad_pccs.dominio=v_dominio) AND (fin_referencias.id_pccs=v_id_pccs) \n			AND (STR_TO_DATE(fin_referencias.data, \'%d/%m/%Y\') <= LAST_DAY(CONCAT(v_ano, \'-\', v_mes, \'-1\'))) \n			AND CAST(v_anos AS UNSIGNED) BETWEEN CAST(cad_classes.i_ano_inicial AS UNSIGNED) AND CAST(cad_classes.i_ano_final AS UNSIGNED)\n		ORDER BY fin_referencias.id_classe DESC, fin_referencias.referencia DESC\n		LIMIT 100000;\n DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;\n \n SET v_dias_mes = DATE_FORMAT(LAST_DAY(CONCAT(v_ano, \'-\', v_mes, \'-1\')), \'%d\');\n SET v_dias_trabalhados = getDiasPagarVctoBasico(v_id_cad_servidor,v_ano,v_mes);\n SET v_referencia = v_dias_trabalhados;\n SET r_valor = 0;\n -- Registra valor para: v_id_pccs, v_d_admissao, v_anos, v_meses, v_dias \n SELECT fin_sfuncional.id_pccs,cad_sfuncional.id_vinculo,\n	/*CONCAT(SUBSTR(cad_servidores.d_admissao, 7),\'-\',SUBSTR(cad_servidores.d_admissao, 4,2),\'-\',SUBSTR(cad_servidores.d_admissao, 1,2))*/\n	STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\')data_adm,\n	TIMESTAMPDIFF(YEAR, STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\'), LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) AS anos,\n	TIMESTAMPDIFF(MONTH, STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\') + INTERVAL TIMESTAMPDIFF(YEAR,  STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\'), LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) YEAR , LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) AS meses,\n	TIMESTAMPDIFF(DAY, STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\') + INTERVAL TIMESTAMPDIFF(MONTH,  STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\'), LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) MONTH , LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) + 1 AS dias\n	INTO v_id_pccs, v_id_vinculo, v_d_admissao, v_anos, v_meses, v_dias\n	FROM cad_sfuncional\n	JOIN cad_servidores ON cad_sfuncional.id_cad_servidores = cad_servidores.id\n	JOIN fin_sfuncional ON cad_sfuncional.id_cad_servidores = fin_sfuncional.id_cad_servidores AND \n	cad_sfuncional.ano = fin_sfuncional.ano AND cad_sfuncional.mes = fin_sfuncional.mes AND\n	cad_sfuncional.parcela = fin_sfuncional.parcela\n	WHERE fin_sfuncional.ano = v_ano AND fin_sfuncional.mes = v_mes AND fin_sfuncional.parcela = v_parcela \n	AND fin_sfuncional.id_cad_servidores = v_id_cad_servidor;\n	-- Varre as referencias para localizar a correta e registrar o valor\n	OPEN cur1Referencias;\n	read_loop: LOOP\n		FETCH cur1Referencias INTO v_valor, v_i_ano_inicial, v_i_ano_final;\n		IF done THEN\n			LEAVE read_loop;\n		END IF;\n		IF !(v_anos = v_i_ano_final && (v_meses != 0 || v_dias != 0)) THEN\n			SET r_valor = ((v_valor / v_dias_mes) * v_dias_trabalhados);\n			IF v_i_ano_final != 0 AND v_i_ano_inicial != 99 THEN\n				SET done = TRUE;\n			ELSE \n				SET done = FALSE;\n			END IF;\n		END IF;\n	END LOOP;\n	CLOSE cur1Referencias;\n	\n SET r_id_fin_eventos = getidvinculo(v_dominio,v_id_vinculo);\n \n IF v_dias_trabalhados > 0 THEN\n	SET exec = TRUE;\n ELSE\n	SET exec = FALSE;\n END IF;\n \nIF exec = TRUE THEN\n	-- Retorna e armazena o último id da tabela fiin_rubricas\n	SET r_id_fin_rubricas = (SELECT MAX(id) FROM fin_rubricas) + 1;\n	/*para garantir a integridade da chave primária, efetua uma segunda verificação e geração de r_id_fin_rubricas, se necessário*/	\n	IF (SELECT id FROM fin_rubricas WHERE id = r_id_fin_rubricas) IS NOT NULL THEN\n		SET r_id_fin_rubricas = r_id_fin_rubricas + 1;\n	END IF;	\n	SET r_id_evento = getEventoSistema(v_dominio,CONCAT(\'Inclusão da rúbrica id: \', r_id_fin_eventos),\'actionC\', \'fin_rubricas\', r_id_fin_rubricas, v_id_user);\n	-- Insere a rúbrica\n	INSERT INTO fin_rubricas (id,slug,STATUS,dominio,evento,created_at,updated_at,\n		id_cad_servidores,id_fin_eventos,\n		ano,mes,parcela,referencia,valor_base,valor,valor_patronal,valor_maternidade,prazo,prazot,desconto,percentual) \n	VALUES(\n		r_id_fin_rubricas,SHA(CONCAT(NOW(),v_dominio,v_id_cad_servidor)),10,v_dominio,r_id_evento,UNIX_TIMESTAMP(NOW()),UNIX_TIMESTAMP(NOW()),\n		v_id_cad_servidor,r_id_fin_eventos,\n		v_ano,v_mes,v_parcela,v_referencia,0.00,r_valor,0.00,0.00,1,1,0.00,100.00\n	);\n END IF; \n /*\nSELECT v_dias_trabalhados, v_id_pccs, r_id_fin_eventos, v_d_admissao, v_anos, v_meses, v_dias, r_valor, exec, v_dias_mes;\n */\nEND','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_desenvolvimento','fin_folha_eventos_unique','PROCEDURE','fin_folha_eventos_unique','SQL','CONTAINS_SQL','NO','DEFINER','v_dominio VARCHAR(255),v_ano VARCHAR(4),v_mes VARCHAR(2),v_parcela VARCHAR(3),v_id_cad_servidor INT','','BEGIN \nDECLARE done INT DEFAULT FALSE; \nDECLARE cur1 CURSOR FOR \nSELECT fin_sfuncional.id_cad_servidores \n	FROM fin_sfuncional \n	JOIN cad_servidores ON cad_servidores.id = fin_sfuncional.id_cad_servidores \n	WHERE fin_sfuncional.dominio = v_dominio AND fin_sfuncional.ano = v_ano \n	AND fin_sfuncional.mes = v_mes AND fin_sfuncional.parcela = v_parcela -- AND fin_sfuncional.situacao = 1 \n	AND fin_sfuncional.situacaofuncional > 0 AND (fin_sfuncional.id_pccs IS NOT NULL AND fin_sfuncional.id_pccs > 0) \n	AND fin_sfuncional.id_cad_servidores = CAST(v_id_cad_servidor AS UNSIGNED)\n	AND fin_sfuncional.lanca_salario = 1\n	ORDER BY cad_servidores.id; \nDECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE; \nDELETE FROM fin_rubricas WHERE dominio = v_dominio \n	AND ano = v_ano AND mes = v_mes AND parcela = v_parcela\n	AND fin_rubricas.id_cad_servidores = CAST(v_id_cad_servidor AS UNSIGNED); \nOPEN cur1; \nread_loop: LOOP FETCH cur1 INTO v_id_cad_servidor; \n	IF done THEN \n		LEAVE read_loop; \n	END IF; \n	CALL fin_folha_ev_basico(v_dominio,v_ano,v_mes,v_parcela,v_id_cad_servidor); \nEND LOOP; \nCLOSE cur1; \nEND','root@localhost','2019-06-18 08:06:09','2019-06-18 08:06:09','NO_AUTO_VALUE_ON_ZERO','','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN \nDECLARE done INT DEFAULT FALSE; \nDECLARE cur1 CURSOR FOR \nSELECT fin_sfuncional.id_cad_servidores \n	FROM fin_sfuncional \n	JOIN cad_servidores ON cad_servidores.id = fin_sfuncional.id_cad_servidores \n	WHERE fin_sfuncional.dominio = v_dominio AND fin_sfuncional.ano = v_ano \n	AND fin_sfuncional.mes = v_mes AND fin_sfuncional.parcela = v_parcela -- AND fin_sfuncional.situacao = 1 \n	AND fin_sfuncional.situacaofuncional > 0 AND (fin_sfuncional.id_pccs IS NOT NULL AND fin_sfuncional.id_pccs > 0) \n	AND fin_sfuncional.id_cad_servidores = CAST(v_id_cad_servidor AS UNSIGNED)\n	AND fin_sfuncional.lanca_salario = 1\n	ORDER BY cad_servidores.id; \nDECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE; \nDELETE FROM fin_rubricas WHERE dominio = v_dominio \n	AND ano = v_ano AND mes = v_mes AND parcela = v_parcela\n	AND fin_rubricas.id_cad_servidores = CAST(v_id_cad_servidor AS UNSIGNED); \nOPEN cur1; \nread_loop: LOOP FETCH cur1 INTO v_id_cad_servidor; \n	IF done THEN \n		LEAVE read_loop; \n	END IF; \n	CALL fin_folha_ev_basico(v_dominio,v_ano,v_mes,v_parcela,v_id_cad_servidor); \nEND LOOP; \nCLOSE cur1; \nEND','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_desenvolvimento','get_eventos_percentual','PROCEDURE','get_eventos_percentual','SQL','CONTAINS_SQL','NO','DEFINER','v_dominio VARCHAR(255),v_id_eventos INT','','BEGIN\n	SELECT id, slug, id_eventos_percentual, percentual, `data` FROM fin_eventospercentual WHERE id_fin_eventos = v_id_eventos AND dominio = v_dominio;\n    END','root@localhost','2019-06-18 08:06:09','2019-06-18 08:06:09','NO_AUTO_VALUE_ON_ZERO','','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN\n	SELECT id, slug, id_eventos_percentual, percentual, `data` FROM fin_eventospercentual WHERE id_fin_eventos = v_id_eventos AND dominio = v_dominio;\n    END','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_desenvolvimento','fin_folha_ev_basico','PROCEDURE','fin_folha_ev_basico','SQL','CONTAINS_SQL','NO','DEFINER','v_id_user VARCHAR(255),v_dominio VARCHAR(255),v_ano VARCHAR(4),v_mes VARCHAR(2),\nv_parcela VARCHAR(3),v_id_cad_servidores VARCHAR(255)','','BEGIN\n DECLARE r_valor, v_valor DECIMAL(11,2);\n DECLARE v_referencia, v_anos, v_meses, v_dias CHAR(2);\n DECLARE v_i_ano_inicial, v_i_ano_final CHAR(3);\n DECLARE v_id_pccs, v_id_vinculo, v_dias_mes, v_dias_trabalhados, r_id_evento, r_id_fin_eventos, r_id_fin_rubricas INT;\n DECLARE v_d_admissao DATE; \n DECLARE done INT DEFAULT FALSE; \n DECLARE exec INT DEFAULT TRUE;  \n -- obter referências\n DECLARE cur1Referencias CURSOR FOR  \n	SELECT fin_referencias.valor, cad_classes.i_ano_inicial, cad_classes.i_ano_final \n		FROM fin_referencias \n		JOIN cad_pccs ON cad_pccs.dominio = fin_referencias.dominio \n			AND cad_pccs.id_pccs = fin_referencias.id_pccs \n		JOIN cad_classes ON cad_classes.dominio = fin_referencias.dominio \n			AND cad_classes.id_pccs = cad_pccs.id_pccs \n			AND cad_classes.id_classe = fin_referencias.id_classe \n		WHERE (cad_pccs.dominio=v_dominio) AND (fin_referencias.id_pccs=v_id_pccs) \n			AND (STR_TO_DATE(fin_referencias.data, \'%d/%m/%Y\') <= LAST_DAY(CONCAT(v_ano, \'-\', v_mes, \'-1\'))) \n			AND CAST(v_anos AS UNSIGNED) BETWEEN CAST(cad_classes.i_ano_inicial AS UNSIGNED) AND CAST(cad_classes.i_ano_final AS UNSIGNED)\n		ORDER BY fin_referencias.id_classe DESC, fin_referencias.referencia DESC\n		LIMIT 100000;\n DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;\n \n SET v_dias_mes = DATE_FORMAT(LAST_DAY(CONCAT(v_ano, \'-\', v_mes, \'-1\')), \'%d\');\n SET v_dias_trabalhados = getDiasPagarVctoBasico(v_id_cad_servidores,v_ano,v_mes);\n SET v_referencia = v_dias_trabalhados;\n SET r_valor = 0;\n -- Registra valor para: v_id_pccs, v_d_admissao, v_anos, v_meses, v_dias \n SELECT fin_sfuncional.id_pccs,cad_sfuncional.id_vinculo,\n	/*CONCAT(SUBSTR(cad_servidores.d_admissao, 7),\'-\',SUBSTR(cad_servidores.d_admissao, 4,2),\'-\',SUBSTR(cad_servidores.d_admissao, 1,2))*/\n	STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\')data_adm,\n	TIMESTAMPDIFF(YEAR, STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\'), LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) AS anos,\n	TIMESTAMPDIFF(MONTH, STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\') + INTERVAL TIMESTAMPDIFF(YEAR,  STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\'), LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) YEAR , LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) AS meses,\n	TIMESTAMPDIFF(DAY, STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\') + INTERVAL TIMESTAMPDIFF(MONTH,  STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\'), LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) MONTH , LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) + 1 AS dias\n	INTO v_id_pccs, v_id_vinculo, v_d_admissao, v_anos, v_meses, v_dias\n	FROM cad_sfuncional\n	JOIN cad_servidores ON cad_sfuncional.id_cad_servidores = cad_servidores.id\n	JOIN fin_sfuncional ON cad_sfuncional.id_cad_servidores = fin_sfuncional.id_cad_servidores AND \n	cad_sfuncional.ano = fin_sfuncional.ano AND cad_sfuncional.mes = fin_sfuncional.mes AND\n	cad_sfuncional.parcela = fin_sfuncional.parcela\n	WHERE fin_sfuncional.ano = v_ano AND fin_sfuncional.mes = v_mes AND fin_sfuncional.parcela = v_parcela \n	AND fin_sfuncional.id_cad_servidores = v_id_cad_servidores;\n	-- Varre as referencias para localizar a correta e registrar o valor\n	OPEN cur1Referencias;\n	read_loop: LOOP\n		FETCH cur1Referencias INTO v_valor, v_i_ano_inicial, v_i_ano_final;\n		IF done THEN\n			LEAVE read_loop;\n		END IF;\n		IF !(v_anos = v_i_ano_final && (v_meses != 0 || v_dias != 0)) THEN\n			SET r_valor = ((v_valor / v_dias_mes) * v_dias_trabalhados);\n			IF v_i_ano_final != 0 AND v_i_ano_inicial != 99 THEN\n				SET done = TRUE;\n			ELSE \n				SET done = FALSE;\n			END IF;\n		END IF;\n	END LOOP;\n	CLOSE cur1Referencias;\n	\n SET r_id_fin_eventos = getidvinculo(v_dominio,v_id_vinculo);\n \n IF v_dias_trabalhados > 0 THEN\n	SET exec = TRUE;\n ELSE\n	SET exec = FALSE;\n END IF;\n \nIF exec = TRUE THEN\n	-- Retorna e armazena o último id da tabela fiin_rubricas\n	SET r_id_fin_rubricas = (SELECT MAX(id) FROM fin_rubricas) + 1;\n	/*para garantir a integridade da chave primária, efetua uma segunda verificação e geração de r_id_fin_rubricas, se necessário*/	\n	IF (SELECT id FROM fin_rubricas WHERE id = r_id_fin_rubricas) IS NOT NULL THEN\n		SET r_id_fin_rubricas = r_id_fin_rubricas + 1;\n	END IF;	\n	SET r_id_evento = getEventoSistema(v_dominio,CONCAT(\'Inclusão da rúbrica id: \', r_id_fin_eventos),\'actionC\', \'fin_rubricas\', r_id_fin_rubricas, v_id_user);		\n	IF (v_id_cad_servidores > 0) THEN		\n		DELETE FROM fin_rubricas WHERE dominio = v_dominio \n			AND ano = v_ano AND mes = v_mes AND parcela = v_parcela \n			AND id_fin_eventos = r_id_fin_eventos\n			AND id_cad_servidores = v_id_cad_servidores; \n	END IF;\n	-- Insere a rúbrica\n	INSERT INTO fin_rubricas (id,slug,STATUS,dominio,evento,created_at,updated_at,\n		id_cad_servidores,id_fin_eventos,\n		ano,mes,parcela,referencia,valor_base,valor,valor_patronal,valor_maternidade,prazo,prazot,desconto,percentual) \n	VALUES(\n		r_id_fin_rubricas,SHA(CONCAT(NOW(),v_dominio,v_id_cad_servidores)),10,v_dominio,r_id_evento,UNIX_TIMESTAMP(NOW()),UNIX_TIMESTAMP(NOW()),\n		v_id_cad_servidores,r_id_fin_eventos,\n		v_ano,v_mes,v_parcela,v_referencia,0.00,r_valor,0.00,0.00,1,1,0.00,100.00\n	);\n END IF; \n /*\nSELECT v_dias_trabalhados, v_id_pccs, r_id_fin_eventos, v_d_admissao, v_anos, v_meses, v_dias, r_valor, exec, v_dias_mes;\n */\nEND','root@localhost','2019-06-20 13:19:39','2019-06-20 13:19:39','NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION','','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN\n DECLARE r_valor, v_valor DECIMAL(11,2);\n DECLARE v_referencia, v_anos, v_meses, v_dias CHAR(2);\n DECLARE v_i_ano_inicial, v_i_ano_final CHAR(3);\n DECLARE v_id_pccs, v_id_vinculo, v_dias_mes, v_dias_trabalhados, r_id_evento, r_id_fin_eventos, r_id_fin_rubricas INT;\n DECLARE v_d_admissao DATE; \n DECLARE done INT DEFAULT FALSE; \n DECLARE exec INT DEFAULT TRUE;  \n -- obter referências\n DECLARE cur1Referencias CURSOR FOR  \n	SELECT fin_referencias.valor, cad_classes.i_ano_inicial, cad_classes.i_ano_final \n		FROM fin_referencias \n		JOIN cad_pccs ON cad_pccs.dominio = fin_referencias.dominio \n			AND cad_pccs.id_pccs = fin_referencias.id_pccs \n		JOIN cad_classes ON cad_classes.dominio = fin_referencias.dominio \n			AND cad_classes.id_pccs = cad_pccs.id_pccs \n			AND cad_classes.id_classe = fin_referencias.id_classe \n		WHERE (cad_pccs.dominio=v_dominio) AND (fin_referencias.id_pccs=v_id_pccs) \n			AND (STR_TO_DATE(fin_referencias.data, \'%d/%m/%Y\') <= LAST_DAY(CONCAT(v_ano, \'-\', v_mes, \'-1\'))) \n			AND CAST(v_anos AS UNSIGNED) BETWEEN CAST(cad_classes.i_ano_inicial AS UNSIGNED) AND CAST(cad_classes.i_ano_final AS UNSIGNED)\n		ORDER BY fin_referencias.id_classe DESC, fin_referencias.referencia DESC\n		LIMIT 100000;\n DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;\n \n SET v_dias_mes = DATE_FORMAT(LAST_DAY(CONCAT(v_ano, \'-\', v_mes, \'-1\')), \'%d\');\n SET v_dias_trabalhados = getDiasPagarVctoBasico(v_id_cad_servidores,v_ano,v_mes);\n SET v_referencia = v_dias_trabalhados;\n SET r_valor = 0;\n -- Registra valor para: v_id_pccs, v_d_admissao, v_anos, v_meses, v_dias \n SELECT fin_sfuncional.id_pccs,cad_sfuncional.id_vinculo,\n	/*CONCAT(SUBSTR(cad_servidores.d_admissao, 7),\'-\',SUBSTR(cad_servidores.d_admissao, 4,2),\'-\',SUBSTR(cad_servidores.d_admissao, 1,2))*/\n	STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\')data_adm,\n	TIMESTAMPDIFF(YEAR, STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\'), LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) AS anos,\n	TIMESTAMPDIFF(MONTH, STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\') + INTERVAL TIMESTAMPDIFF(YEAR,  STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\'), LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) YEAR , LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) AS meses,\n	TIMESTAMPDIFF(DAY, STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\') + INTERVAL TIMESTAMPDIFF(MONTH,  STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\'), LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) MONTH , LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) + 1 AS dias\n	INTO v_id_pccs, v_id_vinculo, v_d_admissao, v_anos, v_meses, v_dias\n	FROM cad_sfuncional\n	JOIN cad_servidores ON cad_sfuncional.id_cad_servidores = cad_servidores.id\n	JOIN fin_sfuncional ON cad_sfuncional.id_cad_servidores = fin_sfuncional.id_cad_servidores AND \n	cad_sfuncional.ano = fin_sfuncional.ano AND cad_sfuncional.mes = fin_sfuncional.mes AND\n	cad_sfuncional.parcela = fin_sfuncional.parcela\n	WHERE fin_sfuncional.ano = v_ano AND fin_sfuncional.mes = v_mes AND fin_sfuncional.parcela = v_parcela \n	AND fin_sfuncional.id_cad_servidores = v_id_cad_servidores;\n	-- Varre as referencias para localizar a correta e registrar o valor\n	OPEN cur1Referencias;\n	read_loop: LOOP\n		FETCH cur1Referencias INTO v_valor, v_i_ano_inicial, v_i_ano_final;\n		IF done THEN\n			LEAVE read_loop;\n		END IF;\n		IF !(v_anos = v_i_ano_final && (v_meses != 0 || v_dias != 0)) THEN\n			SET r_valor = ((v_valor / v_dias_mes) * v_dias_trabalhados);\n			IF v_i_ano_final != 0 AND v_i_ano_inicial != 99 THEN\n				SET done = TRUE;\n			ELSE \n				SET done = FALSE;\n			END IF;\n		END IF;\n	END LOOP;\n	CLOSE cur1Referencias;\n	\n SET r_id_fin_eventos = getidvinculo(v_dominio,v_id_vinculo);\n \n IF v_dias_trabalhados > 0 THEN\n	SET exec = TRUE;\n ELSE\n	SET exec = FALSE;\n END IF;\n \nIF exec = TRUE THEN\n	-- Retorna e armazena o último id da tabela fiin_rubricas\n	SET r_id_fin_rubricas = (SELECT MAX(id) FROM fin_rubricas) + 1;\n	/*para garantir a integridade da chave primária, efetua uma segunda verificação e geração de r_id_fin_rubricas, se necessário*/	\n	IF (SELECT id FROM fin_rubricas WHERE id = r_id_fin_rubricas) IS NOT NULL THEN\n		SET r_id_fin_rubricas = r_id_fin_rubricas + 1;\n	END IF;	\n	SET r_id_evento = getEventoSistema(v_dominio,CONCAT(\'Inclusão da rúbrica id: \', r_id_fin_eventos),\'actionC\', \'fin_rubricas\', r_id_fin_rubricas, v_id_user);		\n	IF (v_id_cad_servidores > 0) THEN		\n		DELETE FROM fin_rubricas WHERE dominio = v_dominio \n			AND ano = v_ano AND mes = v_mes AND parcela = v_parcela \n			AND id_fin_eventos = r_id_fin_eventos\n			AND id_cad_servidores = v_id_cad_servidores; \n	END IF;\n	-- Insere a rúbrica\n	INSERT INTO fin_rubricas (id,slug,STATUS,dominio,evento,created_at,updated_at,\n		id_cad_servidores,id_fin_eventos,\n		ano,mes,parcela,referencia,valor_base,valor,valor_patronal,valor_maternidade,prazo,prazot,desconto,percentual) \n	VALUES(\n		r_id_fin_rubricas,SHA(CONCAT(NOW(),v_dominio,v_id_cad_servidores)),10,v_dominio,r_id_evento,UNIX_TIMESTAMP(NOW()),UNIX_TIMESTAMP(NOW()),\n		v_id_cad_servidores,r_id_fin_eventos,\n		v_ano,v_mes,v_parcela,v_referencia,0.00,r_valor,0.00,0.00,1,1,0.00,100.00\n	);\n END IF; \n /*\nSELECT v_dias_trabalhados, v_id_pccs, r_id_fin_eventos, v_d_admissao, v_anos, v_meses, v_dias, r_valor, exec, v_dias_mes;\n */\nEND','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_desenvolvimento','fin_folha_eventos','PROCEDURE','fin_folha_eventos','SQL','CONTAINS_SQL','NO','DEFINER','v_id_user INT(11), v_dominio VARCHAR(255),v_ano VARCHAR(4),v_mes VARCHAR(2),v_parcela VARCHAR(3), v_id_cad_servidores INT','','BEGIN \nDECLARE done INT DEFAULT FALSE; \nDECLARE v_id_cad_servidor INT; \nDECLARE cur1 CURSOR FOR \nSELECT fin_sfuncional.id_cad_servidores \n	FROM fin_sfuncional \n	JOIN cad_servidores ON cad_servidores.id = fin_sfuncional.id_cad_servidores \n	WHERE fin_sfuncional.dominio = v_dominio AND fin_sfuncional.ano = v_ano \n	AND fin_sfuncional.mes = v_mes AND fin_sfuncional.parcela = v_parcela AND fin_sfuncional.situacao = 1 \n	AND fin_sfuncional.situacaofuncional >= 1 AND (fin_sfuncional.id_pccs IS NOT NULL AND fin_sfuncional.id_pccs > 0) \n	AND fin_sfuncional.lanca_salario = 1\n	AND IF (v_id_cad_servidores > 0, fin_sfuncional.id_cad_servidores = v_id_cad_servidores, 1=1)\n	ORDER BY cad_servidores.id; \nDECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE; \n/*\nFoi comentado para que a operação de exclusão possa ocorrer apenas antes do registro da rúbrica e por rúbrica\nDELETE FROM fin_rubricas WHERE dominio = v_dominio \n	AND ano = v_ano AND mes = v_mes AND parcela = v_parcela;*/ \nOPEN cur1; \nread_loop: LOOP FETCH cur1 INTO v_id_cad_servidor; \n	IF done THEN \n		LEAVE read_loop; \n	END IF; \n	-- Geração dos eventos básicos 2,3 e 40 (001,002,003) da folha\n	CALL fin_folha_ev_basico(v_id_user,v_dominio,v_ano,v_mes,v_parcela,v_id_cad_servidor); \nEND LOOP; \nCLOSE cur1; \n/**\nAs operações abaixo foram deslocadas para suas próprias chamadas dentro de main.php\nCALL fin_folha_eventos_recorrentes(v_id_user,v_dominio,v_ano,v_mes,v_parcela); \nCALL fin_folha_eventos_parcelados(v_id_user,v_dominio,v_ano,v_mes,v_parcela); \n*/\nEND','root@localhost','2019-06-20 13:18:41','2019-06-20 13:18:41','NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION','','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN \nDECLARE done INT DEFAULT FALSE; \nDECLARE v_id_cad_servidor INT; \nDECLARE cur1 CURSOR FOR \nSELECT fin_sfuncional.id_cad_servidores \n	FROM fin_sfuncional \n	JOIN cad_servidores ON cad_servidores.id = fin_sfuncional.id_cad_servidores \n	WHERE fin_sfuncional.dominio = v_dominio AND fin_sfuncional.ano = v_ano \n	AND fin_sfuncional.mes = v_mes AND fin_sfuncional.parcela = v_parcela AND fin_sfuncional.situacao = 1 \n	AND fin_sfuncional.situacaofuncional >= 1 AND (fin_sfuncional.id_pccs IS NOT NULL AND fin_sfuncional.id_pccs > 0) \n	AND fin_sfuncional.lanca_salario = 1\n	AND IF (v_id_cad_servidores > 0, fin_sfuncional.id_cad_servidores = v_id_cad_servidores, 1=1)\n	ORDER BY cad_servidores.id; \nDECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE; \n/*\nFoi comentado para que a operação de exclusão possa ocorrer apenas antes do registro da rúbrica e por rúbrica\nDELETE FROM fin_rubricas WHERE dominio = v_dominio \n	AND ano = v_ano AND mes = v_mes AND parcela = v_parcela;*/ \nOPEN cur1; \nread_loop: LOOP FETCH cur1 INTO v_id_cad_servidor; \n	IF done THEN \n		LEAVE read_loop; \n	END IF; \n	-- Geração dos eventos básicos 2,3 e 40 (001,002,003) da folha\n	CALL fin_folha_ev_basico(v_id_user,v_dominio,v_ano,v_mes,v_parcela,v_id_cad_servidor); \nEND LOOP; \nCLOSE cur1; \n/**\nAs operações abaixo foram deslocadas para suas próprias chamadas dentro de main.php\nCALL fin_folha_eventos_recorrentes(v_id_user,v_dominio,v_ano,v_mes,v_parcela); \nCALL fin_folha_eventos_parcelados(v_id_user,v_dominio,v_ano,v_mes,v_parcela); \n*/\nEND','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_desenvolvimento','get_vcto_basico','PROCEDURE','get_vcto_basico','SQL','CONTAINS_SQL','NO','DEFINER','v_dominio VARCHAR(255),v_ano VARCHAR(4),v_mes VARCHAR(2),\nv_parcela VARCHAR(3),v_id_cad_servidor VARCHAR(255)','','BEGIN\n	DECLARE r_valor, v_valor DECIMAL(11,2);\n	DECLARE v_referencia, v_anos, v_meses, v_dias, v_i_ano_inicial, v_i_ano_final CHAR(2);\n	DECLARE v_id_referencia, v_id_pccs, v_id_vinculo, v_dias_mes, v_dias_trabalhados INT;\n	DECLARE v_d_admissao DATE; \n	DECLARE done INT DEFAULT FALSE; \n	DECLARE exec INT DEFAULT TRUE;  \n	-- obter referências\n	DECLARE cur1Referencias CURSOR FOR  \n	SELECT fin_referencias.id,/*MAX*/(fin_referencias.valor)valor, cad_classes.i_ano_inicial, cad_classes.i_ano_final \n		FROM fin_referencias \n		JOIN cad_pccs ON cad_pccs.dominio = fin_referencias.dominio \n			AND cad_pccs.id_pccs = fin_referencias.id_pccs \n		JOIN cad_classes ON cad_classes.dominio = fin_referencias.dominio \n			AND cad_classes.id_pccs = cad_pccs.id_pccs \n			AND cad_classes.id_classe = fin_referencias.id_classe \n		WHERE (cad_pccs.dominio=v_dominio) AND (fin_referencias.id_pccs=v_id_pccs) \n			AND (STR_TO_DATE(fin_referencias.data, \'%d/%m/%Y\') <= LAST_DAY(CONCAT(v_ano, \'-\', v_mes, \'-1\'))) \n			AND v_anos BETWEEN CAST(cad_classes.i_ano_inicial AS UNSIGNED) AND CAST(cad_classes.i_ano_final AS UNSIGNED)\n		-- GROUP BY cad_classes.i_ano_inicial, cad_classes.i_ano_final\n		ORDER BY fin_referencias.id_classe DESC, fin_referencias.referencia DESC\n		LIMIT 100000;\n	DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;\n	SET v_dias_mes = DATE_FORMAT(LAST_DAY(CONCAT(v_ano, \'-\', v_mes, \'-1\')), \'%d\');\n	SET v_dias_trabalhados = getDiasPagarVctoBasico(v_id_cad_servidor,v_ano,v_mes);\n	SET v_referencia = v_dias_trabalhados;\n	SET r_valor = 0;\n	-- Registra valor para: v_id_pccs, v_d_admissao, v_anos, v_meses, v_dias \n	SELECT fin_sfuncional.id_pccs,cad_sfuncional.id_vinculo,\n		/*CONCAT(SUBSTR(cad_servidores.d_admissao, 7),\'-\',SUBSTR(cad_servidores.d_admissao, 4,2),\'-\',SUBSTR(cad_servidores.d_admissao, 1,2))*/\n		STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\')data_adm,\n		TIMESTAMPDIFF(YEAR, STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\'), LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) AS anos,\n		TIMESTAMPDIFF(MONTH, STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\') + INTERVAL TIMESTAMPDIFF(YEAR,  STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\'), LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) YEAR , LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) AS meses,\n		TIMESTAMPDIFF(DAY, STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\') + INTERVAL TIMESTAMPDIFF(MONTH,  STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\'), LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) MONTH , LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) + 1 AS dias\n		INTO v_id_pccs, v_id_vinculo, v_d_admissao, v_anos, v_meses, v_dias\n		FROM cad_sfuncional\n		JOIN cad_servidores ON cad_sfuncional.id_cad_servidores = cad_servidores.id\n		JOIN fin_sfuncional ON cad_sfuncional.id_cad_servidores = fin_sfuncional.id_cad_servidores AND \n		cad_sfuncional.ano = fin_sfuncional.ano AND cad_sfuncional.mes = fin_sfuncional.mes AND\n		cad_sfuncional.parcela = fin_sfuncional.parcela\n		WHERE fin_sfuncional.ano = v_ano AND fin_sfuncional.mes = v_mes AND fin_sfuncional.parcela = v_parcela \n		AND fin_sfuncional.id_cad_servidores = v_id_cad_servidor;\n	-- Varre as referencias para localizar a correta e registrar o valor\n	OPEN cur1Referencias;\n	read_loop: LOOP\n		FETCH cur1Referencias INTO v_id_referencia, v_valor, v_i_ano_inicial, v_i_ano_final;\n		IF done THEN\n			LEAVE read_loop;\n		END IF;\n		IF !(v_anos = v_i_ano_final && (v_meses != 0 || v_dias != 0)) THEN\n			SET r_valor = ((v_valor / v_dias_mes) * v_dias_trabalhados);\n			IF v_i_ano_final != 0 AND v_i_ano_inicial != 99 THEN\n				SET done = TRUE;\n			ELSE \n				SET done = FALSE;\n			END IF;\n		END IF;\n	END LOOP;\n	CLOSE cur1Referencias;\n	-- armazena o id_fin_eventos baseado em cad_sfuncional.id_vinculo\n	IF (v_id_vinculo < 4) THEN\n		SET v_id_vinculo = (SELECT id FROM fin_eventos WHERE dominio = v_dominio AND id_evento = \'001\');\n	ELSEIF (v_id_vinculo BETWEEN 4 AND 5) THEN\n		SET v_id_vinculo = (SELECT id FROM fin_eventos WHERE dominio = v_dominio AND id_evento = \'003\');\n	ELSEIF (v_id_vinculo = 6) THEN \n		SET v_id_vinculo = (SELECT id FROM fin_eventos WHERE dominio = v_dominio AND id_evento = \'002\');\n	END IF;\n	SELECT v_id_referencia, v_dias_trabalhados, v_id_pccs, v_id_vinculo, v_d_admissao, v_anos, v_meses, v_dias, r_valor, exec, v_dias_mes;\nEND','root@localhost','2019-06-18 08:06:09','2019-06-18 08:06:09','NO_AUTO_VALUE_ON_ZERO','','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN\n	DECLARE r_valor, v_valor DECIMAL(11,2);\n	DECLARE v_referencia, v_anos, v_meses, v_dias, v_i_ano_inicial, v_i_ano_final CHAR(2);\n	DECLARE v_id_referencia, v_id_pccs, v_id_vinculo, v_dias_mes, v_dias_trabalhados INT;\n	DECLARE v_d_admissao DATE; \n	DECLARE done INT DEFAULT FALSE; \n	DECLARE exec INT DEFAULT TRUE;  \n	-- obter referências\n	DECLARE cur1Referencias CURSOR FOR  \n	SELECT fin_referencias.id,/*MAX*/(fin_referencias.valor)valor, cad_classes.i_ano_inicial, cad_classes.i_ano_final \n		FROM fin_referencias \n		JOIN cad_pccs ON cad_pccs.dominio = fin_referencias.dominio \n			AND cad_pccs.id_pccs = fin_referencias.id_pccs \n		JOIN cad_classes ON cad_classes.dominio = fin_referencias.dominio \n			AND cad_classes.id_pccs = cad_pccs.id_pccs \n			AND cad_classes.id_classe = fin_referencias.id_classe \n		WHERE (cad_pccs.dominio=v_dominio) AND (fin_referencias.id_pccs=v_id_pccs) \n			AND (STR_TO_DATE(fin_referencias.data, \'%d/%m/%Y\') <= LAST_DAY(CONCAT(v_ano, \'-\', v_mes, \'-1\'))) \n			AND v_anos BETWEEN CAST(cad_classes.i_ano_inicial AS UNSIGNED) AND CAST(cad_classes.i_ano_final AS UNSIGNED)\n		-- GROUP BY cad_classes.i_ano_inicial, cad_classes.i_ano_final\n		ORDER BY fin_referencias.id_classe DESC, fin_referencias.referencia DESC\n		LIMIT 100000;\n	DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;\n	SET v_dias_mes = DATE_FORMAT(LAST_DAY(CONCAT(v_ano, \'-\', v_mes, \'-1\')), \'%d\');\n	SET v_dias_trabalhados = getDiasPagarVctoBasico(v_id_cad_servidor,v_ano,v_mes);\n	SET v_referencia = v_dias_trabalhados;\n	SET r_valor = 0;\n	-- Registra valor para: v_id_pccs, v_d_admissao, v_anos, v_meses, v_dias \n	SELECT fin_sfuncional.id_pccs,cad_sfuncional.id_vinculo,\n		/*CONCAT(SUBSTR(cad_servidores.d_admissao, 7),\'-\',SUBSTR(cad_servidores.d_admissao, 4,2),\'-\',SUBSTR(cad_servidores.d_admissao, 1,2))*/\n		STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\')data_adm,\n		TIMESTAMPDIFF(YEAR, STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\'), LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) AS anos,\n		TIMESTAMPDIFF(MONTH, STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\') + INTERVAL TIMESTAMPDIFF(YEAR,  STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\'), LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) YEAR , LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) AS meses,\n		TIMESTAMPDIFF(DAY, STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\') + INTERVAL TIMESTAMPDIFF(MONTH,  STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\'), LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) MONTH , LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) + 1 AS dias\n		INTO v_id_pccs, v_id_vinculo, v_d_admissao, v_anos, v_meses, v_dias\n		FROM cad_sfuncional\n		JOIN cad_servidores ON cad_sfuncional.id_cad_servidores = cad_servidores.id\n		JOIN fin_sfuncional ON cad_sfuncional.id_cad_servidores = fin_sfuncional.id_cad_servidores AND \n		cad_sfuncional.ano = fin_sfuncional.ano AND cad_sfuncional.mes = fin_sfuncional.mes AND\n		cad_sfuncional.parcela = fin_sfuncional.parcela\n		WHERE fin_sfuncional.ano = v_ano AND fin_sfuncional.mes = v_mes AND fin_sfuncional.parcela = v_parcela \n		AND fin_sfuncional.id_cad_servidores = v_id_cad_servidor;\n	-- Varre as referencias para localizar a correta e registrar o valor\n	OPEN cur1Referencias;\n	read_loop: LOOP\n		FETCH cur1Referencias INTO v_id_referencia, v_valor, v_i_ano_inicial, v_i_ano_final;\n		IF done THEN\n			LEAVE read_loop;\n		END IF;\n		IF !(v_anos = v_i_ano_final && (v_meses != 0 || v_dias != 0)) THEN\n			SET r_valor = ((v_valor / v_dias_mes) * v_dias_trabalhados);\n			IF v_i_ano_final != 0 AND v_i_ano_inicial != 99 THEN\n				SET done = TRUE;\n			ELSE \n				SET done = FALSE;\n			END IF;\n		END IF;\n	END LOOP;\n	CLOSE cur1Referencias;\n	-- armazena o id_fin_eventos baseado em cad_sfuncional.id_vinculo\n	IF (v_id_vinculo < 4) THEN\n		SET v_id_vinculo = (SELECT id FROM fin_eventos WHERE dominio = v_dominio AND id_evento = \'001\');\n	ELSEIF (v_id_vinculo BETWEEN 4 AND 5) THEN\n		SET v_id_vinculo = (SELECT id FROM fin_eventos WHERE dominio = v_dominio AND id_evento = \'003\');\n	ELSEIF (v_id_vinculo = 6) THEN \n		SET v_id_vinculo = (SELECT id FROM fin_eventos WHERE dominio = v_dominio AND id_evento = \'002\');\n	END IF;\n	SELECT v_id_referencia, v_dias_trabalhados, v_id_pccs, v_id_vinculo, v_d_admissao, v_anos, v_meses, v_dias, r_valor, exec, v_dias_mes;\nEND','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_tapera','getDFPcc','FUNCTION','getDFPcc','SQL','CONTAINS_SQL','NO','DEFINER','v_dominio VARCHAR(255),v_ano VARCHAR(4),v_mes VARCHAR(2),\n	v_parcela VARCHAR(3),v_id_cad_servidor VARCHAR(255)','int(11)','BEGIN\n    DECLARE v_id_cad_pccs INT(11);    \n	SELECT fin_sfuncional.id_cad_pccs\n	FROM fin_sfuncional\n	WHERE fin_sfuncional.dominio = v_dominio AND fin_sfuncional.ano = v_ano \n	AND fin_sfuncional.mes = v_mes AND fin_sfuncional.parcela = v_parcela \n	AND fin_sfuncional.id_cad_servidores = v_id_cad_servidor\n	INTO v_id_cad_pccs;\n    RETURN v_id_cad_pccs;\n    END','root@localhost','2019-06-13 10:02:55','2019-06-13 10:02:55','NO_AUTO_VALUE_ON_ZERO','','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN\n    DECLARE v_id_cad_pccs INT(11);    \n	SELECT fin_sfuncional.id_cad_pccs\n	FROM fin_sfuncional\n	WHERE fin_sfuncional.dominio = v_dominio AND fin_sfuncional.ano = v_ano \n	AND fin_sfuncional.mes = v_mes AND fin_sfuncional.parcela = v_parcela \n	AND fin_sfuncional.id_cad_servidores = v_id_cad_servidor\n	INTO v_id_cad_pccs;\n    RETURN v_id_cad_pccs;\n    END','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_tapera','getFinRubricaPrazo','FUNCTION','getFinRubricaPrazo','SQL','CONTAINS_SQL','NO','DEFINER','prazo int, prazot int','int(11)','BEGIN\n	declare prazo_final int(3); -- prazo a retornar\n	if prazot = prazo then\n		set prazo_final = prazo;\n	elseIF prazot > prazo THEN\n		SET prazo_final = prazo + 1;\n	end if;\n	return prazo_final;\n    END','root@localhost','2019-06-13 10:02:55','2019-06-13 10:02:55','NO_AUTO_VALUE_ON_ZERO','Retorna o prazo inicial baseado nos prazos inicial e final passados','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN\n	declare prazo_final int(3); -- prazo a retornar\n	if prazot = prazo then\n		set prazo_final = prazo;\n	elseIF prazot > prazo THEN\n		SET prazo_final = prazo + 1;\n	end if;\n	return prazo_final;\n    END','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_tapera','getFinRubricaPrazoT','FUNCTION','getFinRubricaPrazoT','SQL','CONTAINS_SQL','NO','DEFINER','prazo int, prazot int','int(11)','BEGIN\n	declare prazo_final int(3); -- prazo a retornar\n	if (prazot = prazo) && ((prazot = \'999\') || (prazot = \'1\')) then\n		set prazo_final = prazot;\n	elseIF prazot > prazo THEN\n		SET prazo_final = prazo + 1;\n	end if;\n	return prazo_final;\n    END','root@localhost','2019-06-13 10:02:55','2019-06-13 10:02:55','NO_AUTO_VALUE_ON_ZERO','Retorna o prazo final baseado nos prazos inicial e final passados','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN\n	declare prazo_final int(3); -- prazo a retornar\n	if (prazot = prazo) && ((prazot = \'999\') || (prazot = \'1\')) then\n		set prazo_final = prazot;\n	elseIF prazot > prazo THEN\n		SET prazo_final = prazo + 1;\n	end if;\n	return prazo_final;\n    END','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_tapera','getIdVinculo','FUNCTION','getIdVinculo','SQL','CONTAINS_SQL','YES','DEFINER','v_dominio VARCHAR(255),v_id_vinculo INT','int(11)','BEGIN\n	DECLARE r_id_vinculo INT;\n	IF (v_id_vinculo < 4) THEN\n		SET r_id_vinculo = (SELECT id FROM fin_eventos WHERE dominio = v_dominio AND id_evento = \'001\');\n	ELSEIF (v_id_vinculo BETWEEN 4 AND 5) THEN\n		SET r_id_vinculo = (SELECT id FROM fin_eventos WHERE dominio = v_dominio AND id_evento = \'003\');\n	ELSEIF (v_id_vinculo = 6) THEN \n		SET r_id_vinculo = (SELECT id FROM fin_eventos WHERE dominio = v_dominio AND id_evento = \'002\');\n	ELSE \n		SET r_id_vinculo = 0;\n	END IF;\n	RETURN r_id_vinculo;\n    END','root@localhost','2019-06-13 10:02:55','2019-06-13 10:02:55','NO_AUTO_VALUE_ON_ZERO','Retorna o id_fin_eventos baseado em cad_sfuncional.id_vinculo','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN\n	DECLARE r_id_vinculo INT;\n	IF (v_id_vinculo < 4) THEN\n		SET r_id_vinculo = (SELECT id FROM fin_eventos WHERE dominio = v_dominio AND id_evento = \'001\');\n	ELSEIF (v_id_vinculo BETWEEN 4 AND 5) THEN\n		SET r_id_vinculo = (SELECT id FROM fin_eventos WHERE dominio = v_dominio AND id_evento = \'003\');\n	ELSEIF (v_id_vinculo = 6) THEN \n		SET r_id_vinculo = (SELECT id FROM fin_eventos WHERE dominio = v_dominio AND id_evento = \'002\');\n	ELSE \n		SET r_id_vinculo = 0;\n	END IF;\n	RETURN r_id_vinculo;\n    END','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_tapera','getSFalecimento','FUNCTION','getSFalecimento','SQL','CONTAINS_SQL','NO','DEFINER','v_id_cad_servidores INT','int(11)','BEGIN	\n	declare quant int;\n	SELECT COUNT(*)\n		FROM `cad_smovimentacao` \n		WHERE (`id_cad_servidores`=v_id_cad_servidores) \n		AND ((`codigo_afastamento`=\'S2\') OR (`codigo_afastamento`=\'S3\')) into quant;\n	return quant;\n    END','root@localhost','2019-06-13 10:02:55','2019-06-13 10:02:55','NO_AUTO_VALUE_ON_ZERO','Retorna um model caso o servidor esteja falecido ou null caso não esteja','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN	\n	declare quant int;\n	SELECT COUNT(*)\n		FROM `cad_smovimentacao` \n		WHERE (`id_cad_servidores`=v_id_cad_servidores) \n		AND ((`codigo_afastamento`=\'S2\') OR (`codigo_afastamento`=\'S3\')) into quant;\n	return quant;\n    END','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_tapera','getCodAfastamento','FUNCTION','getCodAfastamento','SQL','CONTAINS_SQL','YES','DEFINER','v VARCHAR(2)','varchar(500) CHARSET latin1','BEGIN\n	DECLARE RETORNO VARCHAR(500);\n	SET RETORNO = CASE v\n		WHEN \'Q1\' THEN \'Q1 - AFASTAMENTO TEMPORÁRIO POR MOTIVO DE LICENÇA-MATERNIDADE (120 DIAS)\'\n		WHEN \'X\' THEN \'X - LICENÇA SEM VENCIMENTOS\'\n		WHEN \'P1\' THEN \'P1 - AFASTAMENTO TEMPORÁRIO POR MOTIVO DE DOENÇA, POR PERÍODO SUPERIOR A 15 DIAS\'\n		WHEN \'H\' THEN \'H  - RESCISÃO, COM JUSTA CAUSA, POR INICIATIVA DO EMPREGADOR\'\n		WHEN \'I1\' THEN \'I1 - RESCISÃO SEM JUSTA CAUSA, POR INICIATIVA DO EMPREGADOR, INCLUSIVE RESCISÃO ANTECIPADA DO CONTRATO A TERMO\'\n		WHEN \'I2\' THEN \'I2 - RESCISÃO POR CULPA RECÍPROCA OU FORÇA MAIOR\'\n		WHEN \'I3\' THEN \'I3 - RESCISÃO POR TÉRMINO DO CONTRATO A TERMO\'\n		WHEN \'I4\' THEN \'I4 - RESCISÃO SEM JUSTA CAUSA DO CONTRATO DE TRABALHO DO EMPREGADO DOMÉSTICO, POR INICIATIVA DO EMPREGADOR\'\n		WHEN \'J\' THEN \'J  - RESCISÃO DO CONTRATO DE TRABALHO POR INICIATIVA DO EMPREGADO\'\n		WHEN \'K\' THEN \'K  - RESCISÃO A PEDIDO DO EMPREGADO OU POR INICIATIVA DO EMPREGADOR, COM JUSTA CAUSA, NO CASO DE EMPREGADO NÃO OPTANTE, COM MENOS DE UM ANO DE SERVIÇO\'\n		WHEN \'L\' THEN \'L  - OUTROS MOTIVOS DE RESCISÃO DO CONTRATO DE TRABALHO\'\n		WHEN \'S2\' THEN \'S2 - FALECIMENTO\'\n		WHEN \'S3\' THEN \'S3 - FALECIMENTO MOTIVADO POR ACIDENTE DE TRABALHO\'\n		WHEN \'U1\' THEN \'U1 - APOSENTADORIA\'\n		WHEN \'U3\' THEN \'U3 - APOSENTADORIA POR INVALIDEZ\' \n		ELSE NULL END;\n	RETURN RETORNO;\n    END','root@localhost','2019-06-13 10:02:55','2019-06-13 10:02:55','NO_AUTO_VALUE_ON_ZERO','','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN\n	DECLARE RETORNO VARCHAR(500);\n	SET RETORNO = CASE v\n		WHEN \'Q1\' THEN \'Q1 - AFASTAMENTO TEMPORÁRIO POR MOTIVO DE LICENÇA-MATERNIDADE (120 DIAS)\'\n		WHEN \'X\' THEN \'X - LICENÇA SEM VENCIMENTOS\'\n		WHEN \'P1\' THEN \'P1 - AFASTAMENTO TEMPORÁRIO POR MOTIVO DE DOENÇA, POR PERÍODO SUPERIOR A 15 DIAS\'\n		WHEN \'H\' THEN \'H  - RESCISÃO, COM JUSTA CAUSA, POR INICIATIVA DO EMPREGADOR\'\n		WHEN \'I1\' THEN \'I1 - RESCISÃO SEM JUSTA CAUSA, POR INICIATIVA DO EMPREGADOR, INCLUSIVE RESCISÃO ANTECIPADA DO CONTRATO A TERMO\'\n		WHEN \'I2\' THEN \'I2 - RESCISÃO POR CULPA RECÍPROCA OU FORÇA MAIOR\'\n		WHEN \'I3\' THEN \'I3 - RESCISÃO POR TÉRMINO DO CONTRATO A TERMO\'\n		WHEN \'I4\' THEN \'I4 - RESCISÃO SEM JUSTA CAUSA DO CONTRATO DE TRABALHO DO EMPREGADO DOMÉSTICO, POR INICIATIVA DO EMPREGADOR\'\n		WHEN \'J\' THEN \'J  - RESCISÃO DO CONTRATO DE TRABALHO POR INICIATIVA DO EMPREGADO\'\n		WHEN \'K\' THEN \'K  - RESCISÃO A PEDIDO DO EMPREGADO OU POR INICIATIVA DO EMPREGADOR, COM JUSTA CAUSA, NO CASO DE EMPREGADO NÃO OPTANTE, COM MENOS DE UM ANO DE SERVIÇO\'\n		WHEN \'L\' THEN \'L  - OUTROS MOTIVOS DE RESCISÃO DO CONTRATO DE TRABALHO\'\n		WHEN \'S2\' THEN \'S2 - FALECIMENTO\'\n		WHEN \'S3\' THEN \'S3 - FALECIMENTO MOTIVADO POR ACIDENTE DE TRABALHO\'\n		WHEN \'U1\' THEN \'U1 - APOSENTADORIA\'\n		WHEN \'U3\' THEN \'U3 - APOSENTADORIA POR INVALIDEZ\' \n		ELSE NULL END;\n	RETURN RETORNO;\n    END','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_tapera','getEventoSistema','FUNCTION','getEventoSistema','SQL','CONTAINS_SQL','NO','DEFINER','v_dominio VARCHAR(255),v_evento TEXT, \n	v_classevento VARCHAR(255), v_tabela_bd VARCHAR(255), v_id_registro INT(11), v_id_user INT(11)','int(11)','BEGIN\n		DECLARE id_evento INT(11);\n		DECLARE ip, geo_td, geo_ln VARCHAR(255);\n		SELECT er.ip,er.geo_lt,er.geo_ln INTO ip, geo_td, geo_ln FROM eventos er WHERE er.id_user = v_id_user ORDER BY er.id DESC LIMIT 1;\n		-- SET id_evento = (SELECT MAX(id) FROM eventos);\n		INSERT INTO megasses_folha.eventos (\n			id,slug,STATUS,dominio,evento,classevento,tabela_bd,id_registro,\n			ip,geo_lt,geo_ln,id_user,username,data_registro,created_at,updated_at\n		) VALUES (\n			null,SHA(CONCAT(UNIX_TIMESTAMP(NOW()),v_dominio,v_evento,v_classevento)),10,v_dominio,v_evento,v_classevento,v_tabela_bd,v_id_registro,\n			ip, geo_td, geo_ln,\n			v_id_user,(SELECT username FROM megasses_folha.user WHERE id = v_id_user),FROM_UNIXTIME(NOW()),UNIX_TIMESTAMP(NOW()),UNIX_TIMESTAMP(NOW())\n		);\n		return (SELECT MAX(id) FROM eventos);\n	END','root@localhost','2019-06-13 10:02:55','2019-06-13 10:02:55','NO_AUTO_VALUE_ON_ZERO','Auxilia no registro de um evento de sistema','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN\n		DECLARE id_evento INT(11);\n		DECLARE ip, geo_td, geo_ln VARCHAR(255);\n		SELECT er.ip,er.geo_lt,er.geo_ln INTO ip, geo_td, geo_ln FROM eventos er WHERE er.id_user = v_id_user ORDER BY er.id DESC LIMIT 1;\n		-- SET id_evento = (SELECT MAX(id) FROM eventos);\n		INSERT INTO megasses_folha.eventos (\n			id,slug,STATUS,dominio,evento,classevento,tabela_bd,id_registro,\n			ip,geo_lt,geo_ln,id_user,username,data_registro,created_at,updated_at\n		) VALUES (\n			null,SHA(CONCAT(UNIX_TIMESTAMP(NOW()),v_dominio,v_evento,v_classevento)),10,v_dominio,v_evento,v_classevento,v_tabela_bd,v_id_registro,\n			ip, geo_td, geo_ln,\n			v_id_user,(SELECT username FROM megasses_folha.user WHERE id = v_id_user),FROM_UNIXTIME(NOW()),UNIX_TIMESTAMP(NOW()),UNIX_TIMESTAMP(NOW())\n		);\n		return (SELECT MAX(id) FROM eventos);\n	END','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_tapera','getDiasPagarVctoBasico','FUNCTION','getDiasPagarVctoBasico','SQL','CONTAINS_SQL','YES','DEFINER','ics INT(11),ano_f CHAR(4),mes_f CHAR(2)','varchar(255) CHARSET latin1','BEGIN\n    DECLARE dias/*dias do período de cálculo*/\n    , dias_p/*CONSTANTE: dias antes de ir para previdência*/ INT(2);\n    DECLARE d_afastamento, d_limite/*data limite antes de ir para previdência*/\n    , d_admissao/*data de admissao*/\n    , d_retorno/*data do retorno*/\n    , udm0 /*último dia do mês anterior*/\n    , udm1 /*último dia do mês atual*/ DATE;\n    DECLARE codigo_afastamento VARCHAR(2);\n    DECLARE r VARCHAR(255);\n    -- dias de afastamento em que a autarquia paga antes de ir para previdência\n    SET dias_p = 15;\n    -- último dia do mês anterior\n    SET udm0 = LAST_DAY(DATE_SUB(CAST(CONCAT(ano_f,\'-\',mes_f,\'-01\') AS DATE), INTERVAL 1 MONTH));\n    -- último dia do mês atual\n    SET udm1 = LAST_DAY(CAST(CONCAT(ano_f,\'-\',mes_f,\'-01\') AS DATE));\n	SELECT STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\') AS d_admissao,	\n		STR_TO_DATE(cad_smovimentacao.d_afastamento, \'%d/%m/%Y\') AS d_afastamento,\n		STR_TO_DATE(cad_smovimentacao.d_retorno, \'%d/%m/%Y\') AS d_retorno,\n		cad_smovimentacao.codigo_afastamento AS codigo_afastamento\n		FROM cad_servidores\n		LEFT JOIN cad_smovimentacao ON cad_servidores.id = cad_smovimentacao.id_cad_servidores \n			AND cad_servidores.dominio = cad_smovimentacao.dominio\n		WHERE cad_servidores.id = ics\n		ORDER BY STR_TO_DATE(cad_smovimentacao.d_afastamento, \'%d/%m/%Y\') DESC\n		LIMIT 1 \n		INTO d_admissao, d_afastamento, d_retorno, codigo_afastamento;\n	IF codigo_afastamento = \'P1\' /*calculo dos dias em caso de afastamento temporário\n		por motivo de doença, por período superior à variável dias_p*/ THEN		\n		SET dias = DAY(d_afastamento) + dias_p;\n		SET d_limite = DATE_ADD(d_afastamento, INTERVAL dias_p DAY);\n		/*Se a data limite(afastamento) for posterior ou igual ao último dia do mês atual*/\n		IF d_limite >= udm1 THEN\n			/*dias a pagar é igual ao total de dias do mês atual pois \n			ou estourou o mês ou o final do prazo acaba no último dia*/\n			SET dias = DAY(udm1);\n			SET r = \'0\';\n		/*Se a data limite for anterior ao último dia do mês atual e o periodo for o mesmo*/\n		ELSEIF d_limite < udm1 AND \n		CONCAT(YEAR(d_limite),MONTH(d_limite)) = CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = DAY(d_limite);\n			SET r = \'1\';\n		/*Se a data limite for anterior ao último dia do mês atual e o periodo for outro*/\n		ELSEIF d_limite < udm1 AND \n		CONCAT(YEAR(d_limite),MONTH(d_limite)) != CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = 0;\n			SET r = \'2\';\n		END IF;\n		/*Adicionar os dias após o retorno à variável dias acima*/\n		/*Se a data de retorno for registrada e for no mês corrente(atual)*/\n		IF d_retorno IS NOT NULL \n		AND CONCAT(YEAR(d_retorno),MONTH(d_retorno)) = CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = dias + DATEDIFF(udm1,d_retorno);\n			SET r = \'3\';\n		ELSEIF d_retorno IS NOT NULL AND d_retorno < udm1 THEN\n			SET dias = DAY(udm1);\n			SET r = \'4\';\n		END IF;\n	ELSEIF codigo_afastamento = \'X\' /*calculo dos dias em caso de licença sem vencimento*/ THEN		\n		SET dias = DAY(d_afastamento);\n		SET d_limite = d_afastamento;\n		/*Se a data limite(afastamento) for posterior ou igual ao último dia do mês atual*/\n		IF d_limite >= udm1 THEN\n			/*dias a pagar é igual ao total de dias do mês atual pois \n			ou estourou o mês ou o final do prazo acaba no último dia*/\n			SET dias = DAY(udm1);\n			SET r = \'5\';\n		/*Se a data limite for anterior ao último dia do mês atual e o periodo for o mesmo*/\n		ELSEIF d_limite < udm1 AND \n		CONCAT(YEAR(d_limite),MONTH(d_limite)) = CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = DAY(d_limite);\n			SET r = \'6\';\n		/*Se a data limite for anterior ao último dia do mês atual e o periodo for outro*/\n		ELSEIF d_limite < udm1 AND \n		CONCAT(YEAR(d_limite),MONTH(d_limite)) != CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = 0;\n			SET r = \'7\';\n		END IF;\n		SET d_retorno = DATE_SUB(d_retorno, INTERVAL 1 DAY);\n		/*Adicionar os dias após o retorno à variável dias acima*/\n		/*Se a data de retorno for registrada e for no mês corrente(atual)*/\n		IF d_retorno IS NOT NULL \n		AND CONCAT(YEAR(d_retorno),MONTH(d_retorno)) = CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = dias + DATEDIFF(udm1,d_retorno);\n			SET r = \'8\';\n		ELSEIF d_retorno IS NOT NULL AND d_retorno < udm1 THEN\n			SET dias = DAY(udm1);\n			SET r = \'9\';\n		END IF;\n	ELSEIF codigo_afastamento = \'Q1\' /*calculo dos dias em caso de licença maternidade*/ THEN		\n		SET dias = DAY(d_afastamento);\n		SET d_limite = d_afastamento;\n		/*Se a data limite(afastamento) for posterior ao último dia do mês atual*/\n		IF d_limite > udm1 THEN\n			/*dias a pagar é igual ao total de dias do mês atual pois \n			a servidora ainda não saiu de licença*/\n			SET dias = DAY(udm1);\n			SET r = \'Q1:0\';\n		/*Se a data limite for anterior ao último dia do mês atual e o periodo for o mesmo*/\n		ELSEIF d_limite < udm1 AND \n		CONCAT(YEAR(d_limite),MONTH(d_limite)) = CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = DAY(d_limite) - 1;\n			SET r = \'Q1:1\';\n		/*Se a data limite for anterior ao último dia do mês atual e o periodo for outro*/\n		ELSEIF d_limite < udm1 AND \n		CONCAT(YEAR(d_limite),MONTH(d_limite)) != CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = 0;\n			SET r = \'Q1:2\';\n		END IF;\n		/*Adicionar os dias após o retorno à variável dias acima*/\n		/*Se a data de retorno for registrada e for no mês corrente(atual)*/\n		IF d_retorno IS NOT NULL \n		AND CONCAT(YEAR(d_retorno),MONTH(d_retorno)) = CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = dias + DATEDIFF(udm1,d_retorno);\n			SET r = \'Q1:3\';\n		/*Se a data de retorno é anterior ao primeiro dia do mês */\n		ELSEIF d_retorno IS NOT NULL AND d_retorno < ADDDATE(LAST_DAY(DATE_SUB(udm1, INTERVAL 1 MONTH)),1) THEN\n			SET dias = DAY(udm1);\n			SET r = \'Q1:4\';\n		END IF;\n	ELSEIF codigo_afastamento IS NOT NULL && codigo_afastamento != \'P1\'\n	 && codigo_afastamento != \'Q1\' && codigo_afastamento != \'X\' /*calculo dos dias em caso de demissão*/ THEN		\n		SET dias = DAY(d_afastamento);\n		SET d_limite = d_afastamento;\n		/*Se a data limite(afastamento) for posterior ou igual ao último dia do mês atual*/\n		IF d_limite > udm1 THEN\n			/*dias a pagar é igual ao total de dias do mês atual pois \n			pertence a outro período*/\n			SET dias = DAY(udm1);\n			SET r = \'Demiss0\';\n		/*Se a data limite for anterior ou igual ao último dia do mês atual e o periodo for o mesmo*/\n		ELSEIF d_limite <= udm1 AND \n		CONCAT(YEAR(d_limite),MONTH(d_limite)) = CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = DAY(d_limite);\n			SET r = \'Demiss1\';\n		/*Se a data limite for anterior ao último dia do mês atual e o periodo for outro*/\n		ELSEIF d_limite < udm1 AND \n		CONCAT(YEAR(d_limite),MONTH(d_limite)) != CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = 0;\n			SET r = \'Demiss2\';\n		END IF;\n	ELSEIF LAST_DAY(d_admissao) = udm1 THEN\n	/*calculo dos dias em caso de admissão no periodo informado*/\n		SET dias = DAY(udm1) - DAY(d_admissao) + 1;\n		SET r = \'10\';\n	ELSE\n	/*caso não atenda nenhuma das situações acima*/\n		SET dias = DAY(udm1);\n		SET r = \'11\';\n	END IF;\n	\nRETURN dias;-- concat(\'da: \',d_afastamento,\' > ca: \',codigo_afastamento,\' > dl: \',d_limite,\' > pos: \',r,\' > dias: \',dias);\nEND','root@localhost','2019-06-13 10:02:55','2019-06-13 10:02:55','NO_AUTO_VALUE_ON_ZERO','','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN\n    DECLARE dias/*dias do período de cálculo*/\n    , dias_p/*CONSTANTE: dias antes de ir para previdência*/ INT(2);\n    DECLARE d_afastamento, d_limite/*data limite antes de ir para previdência*/\n    , d_admissao/*data de admissao*/\n    , d_retorno/*data do retorno*/\n    , udm0 /*último dia do mês anterior*/\n    , udm1 /*último dia do mês atual*/ DATE;\n    DECLARE codigo_afastamento VARCHAR(2);\n    DECLARE r VARCHAR(255);\n    -- dias de afastamento em que a autarquia paga antes de ir para previdência\n    SET dias_p = 15;\n    -- último dia do mês anterior\n    SET udm0 = LAST_DAY(DATE_SUB(CAST(CONCAT(ano_f,\'-\',mes_f,\'-01\') AS DATE), INTERVAL 1 MONTH));\n    -- último dia do mês atual\n    SET udm1 = LAST_DAY(CAST(CONCAT(ano_f,\'-\',mes_f,\'-01\') AS DATE));\n	SELECT STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\') AS d_admissao,	\n		STR_TO_DATE(cad_smovimentacao.d_afastamento, \'%d/%m/%Y\') AS d_afastamento,\n		STR_TO_DATE(cad_smovimentacao.d_retorno, \'%d/%m/%Y\') AS d_retorno,\n		cad_smovimentacao.codigo_afastamento AS codigo_afastamento\n		FROM cad_servidores\n		LEFT JOIN cad_smovimentacao ON cad_servidores.id = cad_smovimentacao.id_cad_servidores \n			AND cad_servidores.dominio = cad_smovimentacao.dominio\n		WHERE cad_servidores.id = ics\n		ORDER BY STR_TO_DATE(cad_smovimentacao.d_afastamento, \'%d/%m/%Y\') DESC\n		LIMIT 1 \n		INTO d_admissao, d_afastamento, d_retorno, codigo_afastamento;\n	IF codigo_afastamento = \'P1\' /*calculo dos dias em caso de afastamento temporário\n		por motivo de doença, por período superior à variável dias_p*/ THEN		\n		SET dias = DAY(d_afastamento) + dias_p;\n		SET d_limite = DATE_ADD(d_afastamento, INTERVAL dias_p DAY);\n		/*Se a data limite(afastamento) for posterior ou igual ao último dia do mês atual*/\n		IF d_limite >= udm1 THEN\n			/*dias a pagar é igual ao total de dias do mês atual pois \n			ou estourou o mês ou o final do prazo acaba no último dia*/\n			SET dias = DAY(udm1);\n			SET r = \'0\';\n		/*Se a data limite for anterior ao último dia do mês atual e o periodo for o mesmo*/\n		ELSEIF d_limite < udm1 AND \n		CONCAT(YEAR(d_limite),MONTH(d_limite)) = CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = DAY(d_limite);\n			SET r = \'1\';\n		/*Se a data limite for anterior ao último dia do mês atual e o periodo for outro*/\n		ELSEIF d_limite < udm1 AND \n		CONCAT(YEAR(d_limite),MONTH(d_limite)) != CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = 0;\n			SET r = \'2\';\n		END IF;\n		/*Adicionar os dias após o retorno à variável dias acima*/\n		/*Se a data de retorno for registrada e for no mês corrente(atual)*/\n		IF d_retorno IS NOT NULL \n		AND CONCAT(YEAR(d_retorno),MONTH(d_retorno)) = CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = dias + DATEDIFF(udm1,d_retorno);\n			SET r = \'3\';\n		ELSEIF d_retorno IS NOT NULL AND d_retorno < udm1 THEN\n			SET dias = DAY(udm1);\n			SET r = \'4\';\n		END IF;\n	ELSEIF codigo_afastamento = \'X\' /*calculo dos dias em caso de licença sem vencimento*/ THEN		\n		SET dias = DAY(d_afastamento);\n		SET d_limite = d_afastamento;\n		/*Se a data limite(afastamento) for posterior ou igual ao último dia do mês atual*/\n		IF d_limite >= udm1 THEN\n			/*dias a pagar é igual ao total de dias do mês atual pois \n			ou estourou o mês ou o final do prazo acaba no último dia*/\n			SET dias = DAY(udm1);\n			SET r = \'5\';\n		/*Se a data limite for anterior ao último dia do mês atual e o periodo for o mesmo*/\n		ELSEIF d_limite < udm1 AND \n		CONCAT(YEAR(d_limite),MONTH(d_limite)) = CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = DAY(d_limite);\n			SET r = \'6\';\n		/*Se a data limite for anterior ao último dia do mês atual e o periodo for outro*/\n		ELSEIF d_limite < udm1 AND \n		CONCAT(YEAR(d_limite),MONTH(d_limite)) != CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = 0;\n			SET r = \'7\';\n		END IF;\n		SET d_retorno = DATE_SUB(d_retorno, INTERVAL 1 DAY);\n		/*Adicionar os dias após o retorno à variável dias acima*/\n		/*Se a data de retorno for registrada e for no mês corrente(atual)*/\n		IF d_retorno IS NOT NULL \n		AND CONCAT(YEAR(d_retorno),MONTH(d_retorno)) = CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = dias + DATEDIFF(udm1,d_retorno);\n			SET r = \'8\';\n		ELSEIF d_retorno IS NOT NULL AND d_retorno < udm1 THEN\n			SET dias = DAY(udm1);\n			SET r = \'9\';\n		END IF;\n	ELSEIF codigo_afastamento = \'Q1\' /*calculo dos dias em caso de licença maternidade*/ THEN		\n		SET dias = DAY(d_afastamento);\n		SET d_limite = d_afastamento;\n		/*Se a data limite(afastamento) for posterior ao último dia do mês atual*/\n		IF d_limite > udm1 THEN\n			/*dias a pagar é igual ao total de dias do mês atual pois \n			a servidora ainda não saiu de licença*/\n			SET dias = DAY(udm1);\n			SET r = \'Q1:0\';\n		/*Se a data limite for anterior ao último dia do mês atual e o periodo for o mesmo*/\n		ELSEIF d_limite < udm1 AND \n		CONCAT(YEAR(d_limite),MONTH(d_limite)) = CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = DAY(d_limite) - 1;\n			SET r = \'Q1:1\';\n		/*Se a data limite for anterior ao último dia do mês atual e o periodo for outro*/\n		ELSEIF d_limite < udm1 AND \n		CONCAT(YEAR(d_limite),MONTH(d_limite)) != CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = 0;\n			SET r = \'Q1:2\';\n		END IF;\n		/*Adicionar os dias após o retorno à variável dias acima*/\n		/*Se a data de retorno for registrada e for no mês corrente(atual)*/\n		IF d_retorno IS NOT NULL \n		AND CONCAT(YEAR(d_retorno),MONTH(d_retorno)) = CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = dias + DATEDIFF(udm1,d_retorno);\n			SET r = \'Q1:3\';\n		/*Se a data de retorno é anterior ao primeiro dia do mês */\n		ELSEIF d_retorno IS NOT NULL AND d_retorno < ADDDATE(LAST_DAY(DATE_SUB(udm1, INTERVAL 1 MONTH)),1) THEN\n			SET dias = DAY(udm1);\n			SET r = \'Q1:4\';\n		END IF;\n	ELSEIF codigo_afastamento IS NOT NULL && codigo_afastamento != \'P1\'\n	 && codigo_afastamento != \'Q1\' && codigo_afastamento != \'X\' /*calculo dos dias em caso de demissão*/ THEN		\n		SET dias = DAY(d_afastamento);\n		SET d_limite = d_afastamento;\n		/*Se a data limite(afastamento) for posterior ou igual ao último dia do mês atual*/\n		IF d_limite > udm1 THEN\n			/*dias a pagar é igual ao total de dias do mês atual pois \n			pertence a outro período*/\n			SET dias = DAY(udm1);\n			SET r = \'Demiss0\';\n		/*Se a data limite for anterior ou igual ao último dia do mês atual e o periodo for o mesmo*/\n		ELSEIF d_limite <= udm1 AND \n		CONCAT(YEAR(d_limite),MONTH(d_limite)) = CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = DAY(d_limite);\n			SET r = \'Demiss1\';\n		/*Se a data limite for anterior ao último dia do mês atual e o periodo for outro*/\n		ELSEIF d_limite < udm1 AND \n		CONCAT(YEAR(d_limite),MONTH(d_limite)) != CONCAT(YEAR(udm1),MONTH(udm1)) THEN\n			SET dias = 0;\n			SET r = \'Demiss2\';\n		END IF;\n	ELSEIF LAST_DAY(d_admissao) = udm1 THEN\n	/*calculo dos dias em caso de admissão no periodo informado*/\n		SET dias = DAY(udm1) - DAY(d_admissao) + 1;\n		SET r = \'10\';\n	ELSE\n	/*caso não atenda nenhuma das situações acima*/\n		SET dias = DAY(udm1);\n		SET r = \'11\';\n	END IF;\n	\nRETURN dias;-- concat(\'da: \',d_afastamento,\' > ca: \',codigo_afastamento,\' > dl: \',d_limite,\' > pos: \',r,\' > dias: \',dias);\nEND','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_tapera','get_eventos_percentual','PROCEDURE','get_eventos_percentual','SQL','CONTAINS_SQL','NO','DEFINER','v_dominio VARCHAR(255),v_id_eventos INT','','BEGIN\n	SELECT id, slug, id_eventos_percentual, percentual, `data` FROM fin_eventospercentual WHERE id_fin_eventos = v_id_eventos AND dominio = v_dominio;\n    END','root@localhost','2019-06-13 10:02:55','2019-06-13 10:02:55','NO_AUTO_VALUE_ON_ZERO','','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN\n	SELECT id, slug, id_eventos_percentual, percentual, `data` FROM fin_eventospercentual WHERE id_fin_eventos = v_id_eventos AND dominio = v_dominio;\n    END','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_tapera','fin_folha_eventos','PROCEDURE','fin_folha_eventos','SQL','CONTAINS_SQL','NO','DEFINER','v_id_user INT(11), v_dominio VARCHAR(255),v_ano VARCHAR(4),v_mes VARCHAR(2),v_parcela VARCHAR(3)','','BEGIN \nDECLARE done INT DEFAULT FALSE; \nDECLARE v_id_cad_servidor INT; \nDECLARE cur1 CURSOR FOR \nSELECT fin_sfuncional.id_cad_servidores \n	FROM fin_sfuncional \n	JOIN cad_servidores ON cad_servidores.id = fin_sfuncional.id_cad_servidores \n	WHERE fin_sfuncional.dominio = v_dominio AND fin_sfuncional.ano = v_ano \n	AND fin_sfuncional.mes = v_mes AND fin_sfuncional.parcela = v_parcela AND fin_sfuncional.situacao = 1 \n	AND fin_sfuncional.situacaofuncional >= 1 AND (fin_sfuncional.id_pccs IS NOT NULL AND fin_sfuncional.id_pccs > 0) \n	AND fin_sfuncional.lanca_salario = 1\n	ORDER BY cad_servidores.id; \nDECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE; \nDELETE FROM fin_rubricas WHERE dominio = v_dominio \n	AND ano = v_ano AND mes = v_mes AND parcela = v_parcela; \nOPEN cur1; \nread_loop: LOOP FETCH cur1 INTO v_id_cad_servidor; \n	IF done THEN \n		LEAVE read_loop; \n	END IF; \n	-- Geração dos eventos básicos 2,3 e 40 (001,002,003) da folha\n	CALL fin_folha_ev_basico(v_id_user,v_dominio,v_ano,v_mes,v_parcela,v_id_cad_servidor); \nEND LOOP; \nCLOSE cur1; \n/**\nAs operações abaixo foram deslocadas para suas próprias chamadas dentro de main.php\nCALL fin_folha_eventos_recorrentes(v_id_user,v_dominio,v_ano,v_mes,v_parcela); \nCALL fin_folha_eventos_parcelados(v_id_user,v_dominio,v_ano,v_mes,v_parcela); \n*/\nEND','root@localhost','2019-06-13 10:02:55','2019-06-13 10:02:55','NO_AUTO_VALUE_ON_ZERO','','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN \nDECLARE done INT DEFAULT FALSE; \nDECLARE v_id_cad_servidor INT; \nDECLARE cur1 CURSOR FOR \nSELECT fin_sfuncional.id_cad_servidores \n	FROM fin_sfuncional \n	JOIN cad_servidores ON cad_servidores.id = fin_sfuncional.id_cad_servidores \n	WHERE fin_sfuncional.dominio = v_dominio AND fin_sfuncional.ano = v_ano \n	AND fin_sfuncional.mes = v_mes AND fin_sfuncional.parcela = v_parcela AND fin_sfuncional.situacao = 1 \n	AND fin_sfuncional.situacaofuncional >= 1 AND (fin_sfuncional.id_pccs IS NOT NULL AND fin_sfuncional.id_pccs > 0) \n	AND fin_sfuncional.lanca_salario = 1\n	ORDER BY cad_servidores.id; \nDECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE; \nDELETE FROM fin_rubricas WHERE dominio = v_dominio \n	AND ano = v_ano AND mes = v_mes AND parcela = v_parcela; \nOPEN cur1; \nread_loop: LOOP FETCH cur1 INTO v_id_cad_servidor; \n	IF done THEN \n		LEAVE read_loop; \n	END IF; \n	-- Geração dos eventos básicos 2,3 e 40 (001,002,003) da folha\n	CALL fin_folha_ev_basico(v_id_user,v_dominio,v_ano,v_mes,v_parcela,v_id_cad_servidor); \nEND LOOP; \nCLOSE cur1; \n/**\nAs operações abaixo foram deslocadas para suas próprias chamadas dentro de main.php\nCALL fin_folha_eventos_recorrentes(v_id_user,v_dominio,v_ano,v_mes,v_parcela); \nCALL fin_folha_eventos_parcelados(v_id_user,v_dominio,v_ano,v_mes,v_parcela); \n*/\nEND','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_tapera','fin_folha_eventos_consignados','PROCEDURE','fin_folha_eventos_consignados','SQL','CONTAINS_SQL','NO','DEFINER','\nv_id_user INT(11),v_dominio VARCHAR(255),v_ano VARCHAR(4),v_mes VARCHAR(2),v_parcela VARCHAR(3)','','BEGIN\n	DECLARE done INT DEFAULT FALSE;\n	DECLARE r_id_fin_rubricas,r_id_cad_servidores,r_id_fin_eventos,r_prazo,r_prazot,r_id_evento INT(11);\n	DECLARE r_slug,r_referencia,r_valor_base,r_valor,r_valor_patronal,\n			r_valor_maternidade,r_desconto,r_percentual VARCHAR(255);	 \n	-- obter referências\n	DECLARE cur1Referencias CURSOR FOR  \n		SELECT fin_rubricas.id_cad_servidores,fin_rubricas.id_fin_eventos,\n			fin_rubricas.referencia,fin_rubricas.valor_base,fin_rubricas.valor,fin_rubricas.valor_patronal,\n			fin_rubricas.valor_maternidade,fin_rubricas.desconto,fin_rubricas.percentual,\n			fin_rubricas.prazo + 1,fin_rubricas.prazot \n			FROM fin_rubricas\n			/*buscar a folha de informação*/\n			JOIN fin_parametros ON fin_parametros.ano_informacao = fin_rubricas.ano\n			AND fin_parametros.mes_informacao = fin_rubricas.mes AND fin_parametros.parcela_informacao = fin_rubricas.parcela\n			AND fin_parametros.dominio = fin_rubricas.dominio\n			JOIN fin_eventos ON fin_eventos.id = fin_rubricas.id_fin_eventos\n			JOIN fin_sfuncional ON fin_parametros.ano_informacao = fin_sfuncional.ano\n			AND fin_parametros.mes_informacao = fin_sfuncional.mes AND fin_parametros.parcela_informacao = fin_sfuncional.parcela\n			AND fin_rubricas.dominio = fin_sfuncional.dominio and fin_sfuncional.id_cad_servidores = fin_rubricas.id_cad_servidores\n			WHERE fin_rubricas.dominio = v_dominio AND fin_parametros.ano = v_ano \n			AND fin_parametros.mes = v_mes AND fin_parametros.parcela = v_parcela\n			AND fin_rubricas.prazot > fin_rubricas.prazo AND fin_eventos.consignado = 1 AND fin_rubricas.valor > 0\n			AND fin_sfuncional.situacao = 1 AND fin_sfuncional.situacaofuncional >= 1\n			GROUP BY fin_rubricas.id_cad_servidores,fin_rubricas.id_fin_eventos,fin_parametros.ano,fin_parametros.mes,fin_parametros.parcela\n			ORDER BY fin_rubricas.id_cad_servidores,fin_eventos.tipo,fin_eventos.id_evento;\n	DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;\n	-- Retorna e armazena o último id da tabela fiin_rubricas\n	SET r_id_fin_rubricas = (SELECT MAX(id) FROM fin_rubricas);	\n	\n	-- Varre as referencias para localizar a correta e registrar o valor\n	OPEN cur1Referencias;\n	read_loop: LOOP\n		FETCH cur1Referencias INTO r_id_cad_servidores,r_id_fin_eventos,r_referencia,\n			r_valor_base,r_valor,r_valor_patronal,r_valor_maternidade,r_desconto,\n			r_percentual,r_prazo,r_prazot;\n		IF done THEN\n			LEAVE read_loop;\n		END IF;	\n		/*primeiro verifica se o servidor é falecido. 0 quer dizer que não foi encontrado afastamento S2 ou S3 para o servidor*/\n		if (SELECT getSFalecimento(r_id_cad_servidores) = 0) then\n			/*gera um slug*/\n			SET r_slug = SHA(CONCAT(UNIX_TIMESTAMP(NOW()),r_id_fin_rubricas));\n			/*depois seta o novo r_id_fin_rubricas*/\n			SET r_id_fin_rubricas = r_id_fin_rubricas + 1;	\n			/*para garantir a integridade da chave primária, efetua uma segunda verificação e geração de r_id_fin_rubricas, se necessário*/	\n			IF (SELECT id FROM fin_rubricas WHERE id = r_id_fin_rubricas) IS NOT NULL THEN\n				SET r_id_fin_rubricas = r_id_fin_rubricas + 1;\n			END IF;\n			SET r_id_evento = getEventoSistema(v_dominio,CONCAT(\'Inclusão da rúbrica parcelada id: \', r_id_fin_eventos),\'actionC\', \'fin_rubricas\', r_id_fin_rubricas, v_id_user);\n			INSERT INTO fin_rubricas(\n				id,slug,status,dominio,evento,created_at,updated_at,\n				id_cad_servidores,id_fin_eventos,ano,mes,parcela,\n				referencia,valor_base,valor,valor_patronal,\n				valor_maternidade,prazo,prazot,desconto,percentual\n			) VALUES (\n				r_id_fin_rubricas,r_slug,10,v_dominio,r_id_evento,UNIX_TIMESTAMP(NOW()),UNIX_TIMESTAMP(NOW()),\n				r_id_cad_servidores,r_id_fin_eventos,v_ano,v_mes,v_parcela,\n				r_referencia,r_valor_base,r_valor,r_valor_patronal,\n				r_valor_maternidade,r_prazo,r_prazot,r_desconto,r_percentual\n			);\n		end if;\n	END LOOP;\n	CLOSE cur1Referencias;\nEND','root@localhost','2019-06-13 10:02:55','2019-06-13 10:02:55','NO_AUTO_VALUE_ON_ZERO','','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN\n	DECLARE done INT DEFAULT FALSE;\n	DECLARE r_id_fin_rubricas,r_id_cad_servidores,r_id_fin_eventos,r_prazo,r_prazot,r_id_evento INT(11);\n	DECLARE r_slug,r_referencia,r_valor_base,r_valor,r_valor_patronal,\n			r_valor_maternidade,r_desconto,r_percentual VARCHAR(255);	 \n	-- obter referências\n	DECLARE cur1Referencias CURSOR FOR  \n		SELECT fin_rubricas.id_cad_servidores,fin_rubricas.id_fin_eventos,\n			fin_rubricas.referencia,fin_rubricas.valor_base,fin_rubricas.valor,fin_rubricas.valor_patronal,\n			fin_rubricas.valor_maternidade,fin_rubricas.desconto,fin_rubricas.percentual,\n			fin_rubricas.prazo + 1,fin_rubricas.prazot \n			FROM fin_rubricas\n			/*buscar a folha de informação*/\n			JOIN fin_parametros ON fin_parametros.ano_informacao = fin_rubricas.ano\n			AND fin_parametros.mes_informacao = fin_rubricas.mes AND fin_parametros.parcela_informacao = fin_rubricas.parcela\n			AND fin_parametros.dominio = fin_rubricas.dominio\n			JOIN fin_eventos ON fin_eventos.id = fin_rubricas.id_fin_eventos\n			JOIN fin_sfuncional ON fin_parametros.ano_informacao = fin_sfuncional.ano\n			AND fin_parametros.mes_informacao = fin_sfuncional.mes AND fin_parametros.parcela_informacao = fin_sfuncional.parcela\n			AND fin_rubricas.dominio = fin_sfuncional.dominio and fin_sfuncional.id_cad_servidores = fin_rubricas.id_cad_servidores\n			WHERE fin_rubricas.dominio = v_dominio AND fin_parametros.ano = v_ano \n			AND fin_parametros.mes = v_mes AND fin_parametros.parcela = v_parcela\n			AND fin_rubricas.prazot > fin_rubricas.prazo AND fin_eventos.consignado = 1 AND fin_rubricas.valor > 0\n			AND fin_sfuncional.situacao = 1 AND fin_sfuncional.situacaofuncional >= 1\n			GROUP BY fin_rubricas.id_cad_servidores,fin_rubricas.id_fin_eventos,fin_parametros.ano,fin_parametros.mes,fin_parametros.parcela\n			ORDER BY fin_rubricas.id_cad_servidores,fin_eventos.tipo,fin_eventos.id_evento;\n	DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;\n	-- Retorna e armazena o último id da tabela fiin_rubricas\n	SET r_id_fin_rubricas = (SELECT MAX(id) FROM fin_rubricas);	\n	\n	-- Varre as referencias para localizar a correta e registrar o valor\n	OPEN cur1Referencias;\n	read_loop: LOOP\n		FETCH cur1Referencias INTO r_id_cad_servidores,r_id_fin_eventos,r_referencia,\n			r_valor_base,r_valor,r_valor_patronal,r_valor_maternidade,r_desconto,\n			r_percentual,r_prazo,r_prazot;\n		IF done THEN\n			LEAVE read_loop;\n		END IF;	\n		/*primeiro verifica se o servidor é falecido. 0 quer dizer que não foi encontrado afastamento S2 ou S3 para o servidor*/\n		if (SELECT getSFalecimento(r_id_cad_servidores) = 0) then\n			/*gera um slug*/\n			SET r_slug = SHA(CONCAT(UNIX_TIMESTAMP(NOW()),r_id_fin_rubricas));\n			/*depois seta o novo r_id_fin_rubricas*/\n			SET r_id_fin_rubricas = r_id_fin_rubricas + 1;	\n			/*para garantir a integridade da chave primária, efetua uma segunda verificação e geração de r_id_fin_rubricas, se necessário*/	\n			IF (SELECT id FROM fin_rubricas WHERE id = r_id_fin_rubricas) IS NOT NULL THEN\n				SET r_id_fin_rubricas = r_id_fin_rubricas + 1;\n			END IF;\n			SET r_id_evento = getEventoSistema(v_dominio,CONCAT(\'Inclusão da rúbrica parcelada id: \', r_id_fin_eventos),\'actionC\', \'fin_rubricas\', r_id_fin_rubricas, v_id_user);\n			INSERT INTO fin_rubricas(\n				id,slug,status,dominio,evento,created_at,updated_at,\n				id_cad_servidores,id_fin_eventos,ano,mes,parcela,\n				referencia,valor_base,valor,valor_patronal,\n				valor_maternidade,prazo,prazot,desconto,percentual\n			) VALUES (\n				r_id_fin_rubricas,r_slug,10,v_dominio,r_id_evento,UNIX_TIMESTAMP(NOW()),UNIX_TIMESTAMP(NOW()),\n				r_id_cad_servidores,r_id_fin_eventos,v_ano,v_mes,v_parcela,\n				r_referencia,r_valor_base,r_valor,r_valor_patronal,\n				r_valor_maternidade,r_prazo,r_prazot,r_desconto,r_percentual\n			);\n		end if;\n	END LOOP;\n	CLOSE cur1Referencias;\nEND','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_tapera','fin_folha_eventos_unique','PROCEDURE','fin_folha_eventos_unique','SQL','CONTAINS_SQL','NO','DEFINER','v_dominio VARCHAR(255),v_ano VARCHAR(4),v_mes VARCHAR(2),v_parcela VARCHAR(3),v_id_cad_servidor INT','','BEGIN \nDECLARE done INT DEFAULT FALSE; \nDECLARE cur1 CURSOR FOR \nSELECT fin_sfuncional.id_cad_servidores \n	FROM fin_sfuncional \n	JOIN cad_servidores ON cad_servidores.id = fin_sfuncional.id_cad_servidores \n	WHERE fin_sfuncional.dominio = v_dominio AND fin_sfuncional.ano = v_ano \n	AND fin_sfuncional.mes = v_mes AND fin_sfuncional.parcela = v_parcela -- AND fin_sfuncional.situacao = 1 \n	AND fin_sfuncional.situacaofuncional > 0 AND (fin_sfuncional.id_pccs IS NOT NULL AND fin_sfuncional.id_pccs > 0) \n	AND fin_sfuncional.id_cad_servidores = CAST(v_id_cad_servidor AS UNSIGNED)\n	AND fin_sfuncional.lanca_salario = 1\n	ORDER BY cad_servidores.id; \nDECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE; \nDELETE FROM fin_rubricas WHERE dominio = v_dominio \n	AND ano = v_ano AND mes = v_mes AND parcela = v_parcela\n	AND fin_rubricas.id_cad_servidores = CAST(v_id_cad_servidor AS UNSIGNED); \nOPEN cur1; \nread_loop: LOOP FETCH cur1 INTO v_id_cad_servidor; \n	IF done THEN \n		LEAVE read_loop; \n	END IF; \n	CALL fin_folha_ev_basico(v_dominio,v_ano,v_mes,v_parcela,v_id_cad_servidor); \nEND LOOP; \nCLOSE cur1; \nEND','root@localhost','2019-06-13 10:02:55','2019-06-13 10:02:55','NO_AUTO_VALUE_ON_ZERO','','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN \nDECLARE done INT DEFAULT FALSE; \nDECLARE cur1 CURSOR FOR \nSELECT fin_sfuncional.id_cad_servidores \n	FROM fin_sfuncional \n	JOIN cad_servidores ON cad_servidores.id = fin_sfuncional.id_cad_servidores \n	WHERE fin_sfuncional.dominio = v_dominio AND fin_sfuncional.ano = v_ano \n	AND fin_sfuncional.mes = v_mes AND fin_sfuncional.parcela = v_parcela -- AND fin_sfuncional.situacao = 1 \n	AND fin_sfuncional.situacaofuncional > 0 AND (fin_sfuncional.id_pccs IS NOT NULL AND fin_sfuncional.id_pccs > 0) \n	AND fin_sfuncional.id_cad_servidores = CAST(v_id_cad_servidor AS UNSIGNED)\n	AND fin_sfuncional.lanca_salario = 1\n	ORDER BY cad_servidores.id; \nDECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE; \nDELETE FROM fin_rubricas WHERE dominio = v_dominio \n	AND ano = v_ano AND mes = v_mes AND parcela = v_parcela\n	AND fin_rubricas.id_cad_servidores = CAST(v_id_cad_servidor AS UNSIGNED); \nOPEN cur1; \nread_loop: LOOP FETCH cur1 INTO v_id_cad_servidor; \n	IF done THEN \n		LEAVE read_loop; \n	END IF; \n	CALL fin_folha_ev_basico(v_dominio,v_ano,v_mes,v_parcela,v_id_cad_servidor); \nEND LOOP; \nCLOSE cur1; \nEND','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_tapera','fin_folha_eventos_parcelados','PROCEDURE','fin_folha_eventos_parcelados','SQL','CONTAINS_SQL','NO','DEFINER','\nv_id_user INT(11),v_dominio VARCHAR(255),v_ano VARCHAR(4),v_mes VARCHAR(2),v_parcela VARCHAR(3)','','BEGIN\n	DECLARE done INT DEFAULT FALSE;\n	DECLARE r_id_fin_rubricas,r_id_cad_servidores,r_id_fin_eventos,r_prazo,r_prazot,r_id_evento INT(11);\n	DECLARE r_slug,r_referencia,r_valor_base,r_valor,r_valor_patronal,\n			r_valor_maternidade,r_desconto,r_percentual VARCHAR(255);	 \n	-- obter referências\n	DECLARE cur1Referencias CURSOR FOR  \n		SELECT fin_rubricas.id_cad_servidores,fin_rubricas.id_fin_eventos,\n			fin_rubricas.referencia,fin_rubricas.valor_base,fin_rubricas.valor,fin_rubricas.valor_patronal,\n			fin_rubricas.valor_maternidade,fin_rubricas.desconto,fin_rubricas.percentual,\n			fin_rubricas.prazo + 1,fin_rubricas.prazot \n			FROM fin_rubricas\n			/*buscar a folha de informação*/\n			JOIN fin_parametros ON fin_parametros.ano_informacao = fin_rubricas.ano\n			AND fin_parametros.mes_informacao = fin_rubricas.mes AND fin_parametros.parcela_informacao = fin_rubricas.parcela\n			AND fin_parametros.dominio = fin_rubricas.dominio\n			JOIN fin_eventos ON fin_eventos.id = fin_rubricas.id_fin_eventos\n			JOIN fin_sfuncional ON fin_parametros.ano_informacao = fin_sfuncional.ano\n			AND fin_parametros.mes_informacao = fin_sfuncional.mes AND fin_parametros.parcela_informacao = fin_sfuncional.parcela\n			AND fin_rubricas.dominio = fin_sfuncional.dominio AND fin_sfuncional.id_cad_servidores = fin_rubricas.id_cad_servidores\n			WHERE fin_rubricas.dominio = v_dominio AND fin_parametros.ano = v_ano \n			AND fin_parametros.mes = v_mes AND fin_parametros.parcela = v_parcela\n			AND fin_rubricas.prazot > fin_rubricas.prazo AND fin_eventos.consignado = 0 AND fin_rubricas.valor > 0\n			AND fin_sfuncional.situacao = 1 AND fin_sfuncional.situacaofuncional >= 1\n			GROUP BY fin_rubricas.id_cad_servidores,fin_rubricas.id_fin_eventos,fin_parametros.ano,fin_parametros.mes,fin_parametros.parcela\n			ORDER BY fin_rubricas.id_cad_servidores,fin_eventos.tipo,fin_eventos.id_evento;\n	DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;\n	-- Retorna e armazena o último id da tabela fiin_rubricas\n	SET r_id_fin_rubricas = (SELECT MAX(id) FROM fin_rubricas);	\n	\n	-- Varre as referencias para localizar a correta e registrar o valor\n	OPEN cur1Referencias;\n	read_loop: LOOP\n		FETCH cur1Referencias INTO r_id_cad_servidores,r_id_fin_eventos,r_referencia,\n			r_valor_base,r_valor,r_valor_patronal,r_valor_maternidade,r_desconto,\n			r_percentual,r_prazo,r_prazot;\n		IF done THEN\n			LEAVE read_loop;\n		END IF;	\n		/*primeiro gera um slug*/\n		SET r_slug = SHA(CONCAT(UNIX_TIMESTAMP(NOW()),r_id_fin_rubricas));\n		/*depois seta o novo r_id_fin_rubricas*/\n		SET r_id_fin_rubricas = r_id_fin_rubricas + 1;	\n		/*para garantir a integridade da chave primária, efetua uma segunda verificação e geração de r_id_fin_rubricas, se necessário*/	\n		IF (SELECT id FROM fin_rubricas WHERE id = r_id_fin_rubricas) IS NOT NULL THEN\n			SET r_id_fin_rubricas = r_id_fin_rubricas + 1;\n		END IF;\n		SET r_id_evento = getEventoSistema(v_dominio,CONCAT(\'Inclusão da rúbrica parcelada id: \', r_id_fin_eventos),\'actionC\', \'fin_rubricas\', r_id_fin_rubricas, v_id_user);\n		INSERT INTO fin_rubricas(\n			id,slug,`status`,dominio,evento,created_at,updated_at,\n			id_cad_servidores,id_fin_eventos,ano,mes,parcela,\n			referencia,valor_base,valor,valor_patronal,\n			valor_maternidade,prazo,prazot,desconto,percentual\n		) VALUES (\n			r_id_fin_rubricas,r_slug,10,v_dominio,r_id_evento,UNIX_TIMESTAMP(NOW()),UNIX_TIMESTAMP(NOW()),\n			r_id_cad_servidores,r_id_fin_eventos,v_ano,v_mes,v_parcela,\n			r_referencia,r_valor_base,r_valor,r_valor_patronal,\n			r_valor_maternidade,r_prazo,r_prazot,r_desconto,r_percentual\n		);\n	END LOOP;\n	CLOSE cur1Referencias;\nEND','root@localhost','2019-06-13 10:02:55','2019-06-13 10:02:55','NO_AUTO_VALUE_ON_ZERO','','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN\n	DECLARE done INT DEFAULT FALSE;\n	DECLARE r_id_fin_rubricas,r_id_cad_servidores,r_id_fin_eventos,r_prazo,r_prazot,r_id_evento INT(11);\n	DECLARE r_slug,r_referencia,r_valor_base,r_valor,r_valor_patronal,\n			r_valor_maternidade,r_desconto,r_percentual VARCHAR(255);	 \n	-- obter referências\n	DECLARE cur1Referencias CURSOR FOR  \n		SELECT fin_rubricas.id_cad_servidores,fin_rubricas.id_fin_eventos,\n			fin_rubricas.referencia,fin_rubricas.valor_base,fin_rubricas.valor,fin_rubricas.valor_patronal,\n			fin_rubricas.valor_maternidade,fin_rubricas.desconto,fin_rubricas.percentual,\n			fin_rubricas.prazo + 1,fin_rubricas.prazot \n			FROM fin_rubricas\n			/*buscar a folha de informação*/\n			JOIN fin_parametros ON fin_parametros.ano_informacao = fin_rubricas.ano\n			AND fin_parametros.mes_informacao = fin_rubricas.mes AND fin_parametros.parcela_informacao = fin_rubricas.parcela\n			AND fin_parametros.dominio = fin_rubricas.dominio\n			JOIN fin_eventos ON fin_eventos.id = fin_rubricas.id_fin_eventos\n			JOIN fin_sfuncional ON fin_parametros.ano_informacao = fin_sfuncional.ano\n			AND fin_parametros.mes_informacao = fin_sfuncional.mes AND fin_parametros.parcela_informacao = fin_sfuncional.parcela\n			AND fin_rubricas.dominio = fin_sfuncional.dominio AND fin_sfuncional.id_cad_servidores = fin_rubricas.id_cad_servidores\n			WHERE fin_rubricas.dominio = v_dominio AND fin_parametros.ano = v_ano \n			AND fin_parametros.mes = v_mes AND fin_parametros.parcela = v_parcela\n			AND fin_rubricas.prazot > fin_rubricas.prazo AND fin_eventos.consignado = 0 AND fin_rubricas.valor > 0\n			AND fin_sfuncional.situacao = 1 AND fin_sfuncional.situacaofuncional >= 1\n			GROUP BY fin_rubricas.id_cad_servidores,fin_rubricas.id_fin_eventos,fin_parametros.ano,fin_parametros.mes,fin_parametros.parcela\n			ORDER BY fin_rubricas.id_cad_servidores,fin_eventos.tipo,fin_eventos.id_evento;\n	DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;\n	-- Retorna e armazena o último id da tabela fiin_rubricas\n	SET r_id_fin_rubricas = (SELECT MAX(id) FROM fin_rubricas);	\n	\n	-- Varre as referencias para localizar a correta e registrar o valor\n	OPEN cur1Referencias;\n	read_loop: LOOP\n		FETCH cur1Referencias INTO r_id_cad_servidores,r_id_fin_eventos,r_referencia,\n			r_valor_base,r_valor,r_valor_patronal,r_valor_maternidade,r_desconto,\n			r_percentual,r_prazo,r_prazot;\n		IF done THEN\n			LEAVE read_loop;\n		END IF;	\n		/*primeiro gera um slug*/\n		SET r_slug = SHA(CONCAT(UNIX_TIMESTAMP(NOW()),r_id_fin_rubricas));\n		/*depois seta o novo r_id_fin_rubricas*/\n		SET r_id_fin_rubricas = r_id_fin_rubricas + 1;	\n		/*para garantir a integridade da chave primária, efetua uma segunda verificação e geração de r_id_fin_rubricas, se necessário*/	\n		IF (SELECT id FROM fin_rubricas WHERE id = r_id_fin_rubricas) IS NOT NULL THEN\n			SET r_id_fin_rubricas = r_id_fin_rubricas + 1;\n		END IF;\n		SET r_id_evento = getEventoSistema(v_dominio,CONCAT(\'Inclusão da rúbrica parcelada id: \', r_id_fin_eventos),\'actionC\', \'fin_rubricas\', r_id_fin_rubricas, v_id_user);\n		INSERT INTO fin_rubricas(\n			id,slug,`status`,dominio,evento,created_at,updated_at,\n			id_cad_servidores,id_fin_eventos,ano,mes,parcela,\n			referencia,valor_base,valor,valor_patronal,\n			valor_maternidade,prazo,prazot,desconto,percentual\n		) VALUES (\n			r_id_fin_rubricas,r_slug,10,v_dominio,r_id_evento,UNIX_TIMESTAMP(NOW()),UNIX_TIMESTAMP(NOW()),\n			r_id_cad_servidores,r_id_fin_eventos,v_ano,v_mes,v_parcela,\n			r_referencia,r_valor_base,r_valor,r_valor_patronal,\n			r_valor_maternidade,r_prazo,r_prazot,r_desconto,r_percentual\n		);\n	END LOOP;\n	CLOSE cur1Referencias;\nEND','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_tapera','fin_folha_eventos_recorrentes','PROCEDURE','fin_folha_eventos_recorrentes','SQL','CONTAINS_SQL','NO','DEFINER','\nv_id_user INT(11),v_dominio VARCHAR(255),v_ano VARCHAR(4),v_mes VARCHAR(2),v_parcela VARCHAR(3)','','BEGIN\n	DECLARE done INT DEFAULT FALSE;\n	DECLARE r_id_fin_rubricas,r_id_cad_servidores,r_id_fin_eventos,r_prazo,r_prazot,r_id_evento INT(11);\n	DECLARE r_slug,r_referencia,r_valor_base,r_valor,r_valor_patronal,\n			r_valor_maternidade,r_desconto,r_percentual VARCHAR(255);	 \n	-- obter referências\n	DECLARE cur1Referencias CURSOR FOR  \n		SELECT fin_rubricas.id_cad_servidores,fin_rubricas.id_fin_eventos,\n			fin_rubricas.referencia,fin_rubricas.valor_base,fin_rubricas.valor,fin_rubricas.valor_patronal,\n			fin_rubricas.valor_maternidade,fin_rubricas.desconto,fin_rubricas.percentual \n			FROM fin_rubricas\n			/*buscar a folha de informação*/\n			JOIN fin_parametros ON fin_parametros.ano_informacao = fin_rubricas.ano\n			AND fin_parametros.mes_informacao = fin_rubricas.mes AND fin_parametros.parcela_informacao = fin_rubricas.parcela\n			AND fin_parametros.dominio = fin_rubricas.dominio\n			JOIN fin_eventos ON fin_eventos.id = fin_rubricas.id_fin_eventos\n			JOIN fin_sfuncional ON fin_parametros.ano_informacao = fin_sfuncional.ano\n			AND fin_parametros.mes_informacao = fin_sfuncional.mes AND fin_parametros.parcela_informacao = fin_sfuncional.parcela\n			AND fin_rubricas.dominio = fin_sfuncional.dominio AND fin_sfuncional.id_cad_servidores = fin_rubricas.id_cad_servidores\n			WHERE fin_rubricas.dominio = v_dominio AND fin_parametros.ano = v_ano \n			AND fin_parametros.mes = v_mes AND fin_parametros.parcela = v_parcela			\n			AND fin_eventos.ev_root != 1 AND fin_eventos.fixo = 1 AND fin_rubricas.prazot = fin_rubricas.prazo \n			AND fin_rubricas.prazot IN (1,999) and fin_rubricas.valor > 0 \n			AND fin_sfuncional.situacao = 1 AND fin_sfuncional.situacaofuncional >= 1\n			GROUP BY fin_rubricas.id_cad_servidores,fin_rubricas.id_fin_eventos,fin_parametros.ano,fin_parametros.mes,fin_parametros.parcela\n			ORDER BY fin_rubricas.id_cad_servidores,fin_eventos.tipo,fin_eventos.id_evento;\n	DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;\n	-- Retorna e armazena o último id da tabela fiin_rubricas\n	SET r_id_fin_rubricas = (SELECT MAX(id) FROM fin_rubricas);	\n	\n	-- Varre as referencias para localizar a correta e registrar o valor\n	OPEN cur1Referencias;\n	read_loop: LOOP\n		FETCH cur1Referencias INTO r_id_cad_servidores,r_id_fin_eventos,r_referencia,\n			r_valor_base,r_valor,r_valor_patronal,r_valor_maternidade,r_desconto,r_percentual;\n		IF done THEN\n			LEAVE read_loop;\n		END IF;	\n		/*primeiro gera um slug*/\n		SET r_slug = SHA(CONCAT(UNIX_TIMESTAMP(NOW()),r_id_fin_rubricas));\n		/*depois seta o novo r_id_fin_rubricas*/\n		SET r_id_fin_rubricas = r_id_fin_rubricas + 1;	\n		/*para garantir a integridade da chave primária, efetua uma segunda verificação e geração de r_id_fin_rubricas, se necessário*/	\n		IF (SELECT id FROM fin_rubricas WHERE id = r_id_fin_rubricas) IS NOT NULL THEN\n			SET r_id_fin_rubricas = r_id_fin_rubricas + 1;\n		END IF;\n		SET r_id_evento = getEventoSistema(v_dominio,CONCAT(\'Inclusão da rúbrica recorrente id: \', r_id_fin_eventos),\'actionC\', \'fin_rubricas\', r_id_fin_rubricas, v_id_user);\n		SET r_valor_base = 0, r_valor = 0, r_valor_patronal = 0, r_valor_maternidade = 0, r_desconto = 0, r_prazo = 1, r_prazot = 1;\n		INSERT INTO fin_rubricas(\n			id,slug,`status`,dominio,evento,created_at,updated_at,\n			id_cad_servidores,id_fin_eventos,ano,mes,parcela,\n			referencia,valor_base,valor,valor_patronal,\n			valor_maternidade,prazo,prazot,desconto,percentual\n		) VALUES (\n			r_id_fin_rubricas,r_slug,10,v_dominio,r_id_evento,UNIX_TIMESTAMP(NOW()),UNIX_TIMESTAMP(NOW()),\n			r_id_cad_servidores,r_id_fin_eventos,v_ano,v_mes,v_parcela,\n			r_referencia,r_valor_base,r_valor,r_valor_patronal,\n			r_valor_maternidade,r_prazo,r_prazot,r_desconto,r_percentual\n		);\n	END LOOP;\n	CLOSE cur1Referencias;\nEND','root@localhost','2019-06-13 10:02:55','2019-06-13 10:02:55','NO_AUTO_VALUE_ON_ZERO','','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN\n	DECLARE done INT DEFAULT FALSE;\n	DECLARE r_id_fin_rubricas,r_id_cad_servidores,r_id_fin_eventos,r_prazo,r_prazot,r_id_evento INT(11);\n	DECLARE r_slug,r_referencia,r_valor_base,r_valor,r_valor_patronal,\n			r_valor_maternidade,r_desconto,r_percentual VARCHAR(255);	 \n	-- obter referências\n	DECLARE cur1Referencias CURSOR FOR  \n		SELECT fin_rubricas.id_cad_servidores,fin_rubricas.id_fin_eventos,\n			fin_rubricas.referencia,fin_rubricas.valor_base,fin_rubricas.valor,fin_rubricas.valor_patronal,\n			fin_rubricas.valor_maternidade,fin_rubricas.desconto,fin_rubricas.percentual \n			FROM fin_rubricas\n			/*buscar a folha de informação*/\n			JOIN fin_parametros ON fin_parametros.ano_informacao = fin_rubricas.ano\n			AND fin_parametros.mes_informacao = fin_rubricas.mes AND fin_parametros.parcela_informacao = fin_rubricas.parcela\n			AND fin_parametros.dominio = fin_rubricas.dominio\n			JOIN fin_eventos ON fin_eventos.id = fin_rubricas.id_fin_eventos\n			JOIN fin_sfuncional ON fin_parametros.ano_informacao = fin_sfuncional.ano\n			AND fin_parametros.mes_informacao = fin_sfuncional.mes AND fin_parametros.parcela_informacao = fin_sfuncional.parcela\n			AND fin_rubricas.dominio = fin_sfuncional.dominio AND fin_sfuncional.id_cad_servidores = fin_rubricas.id_cad_servidores\n			WHERE fin_rubricas.dominio = v_dominio AND fin_parametros.ano = v_ano \n			AND fin_parametros.mes = v_mes AND fin_parametros.parcela = v_parcela			\n			AND fin_eventos.ev_root != 1 AND fin_eventos.fixo = 1 AND fin_rubricas.prazot = fin_rubricas.prazo \n			AND fin_rubricas.prazot IN (1,999) and fin_rubricas.valor > 0 \n			AND fin_sfuncional.situacao = 1 AND fin_sfuncional.situacaofuncional >= 1\n			GROUP BY fin_rubricas.id_cad_servidores,fin_rubricas.id_fin_eventos,fin_parametros.ano,fin_parametros.mes,fin_parametros.parcela\n			ORDER BY fin_rubricas.id_cad_servidores,fin_eventos.tipo,fin_eventos.id_evento;\n	DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;\n	-- Retorna e armazena o último id da tabela fiin_rubricas\n	SET r_id_fin_rubricas = (SELECT MAX(id) FROM fin_rubricas);	\n	\n	-- Varre as referencias para localizar a correta e registrar o valor\n	OPEN cur1Referencias;\n	read_loop: LOOP\n		FETCH cur1Referencias INTO r_id_cad_servidores,r_id_fin_eventos,r_referencia,\n			r_valor_base,r_valor,r_valor_patronal,r_valor_maternidade,r_desconto,r_percentual;\n		IF done THEN\n			LEAVE read_loop;\n		END IF;	\n		/*primeiro gera um slug*/\n		SET r_slug = SHA(CONCAT(UNIX_TIMESTAMP(NOW()),r_id_fin_rubricas));\n		/*depois seta o novo r_id_fin_rubricas*/\n		SET r_id_fin_rubricas = r_id_fin_rubricas + 1;	\n		/*para garantir a integridade da chave primária, efetua uma segunda verificação e geração de r_id_fin_rubricas, se necessário*/	\n		IF (SELECT id FROM fin_rubricas WHERE id = r_id_fin_rubricas) IS NOT NULL THEN\n			SET r_id_fin_rubricas = r_id_fin_rubricas + 1;\n		END IF;\n		SET r_id_evento = getEventoSistema(v_dominio,CONCAT(\'Inclusão da rúbrica recorrente id: \', r_id_fin_eventos),\'actionC\', \'fin_rubricas\', r_id_fin_rubricas, v_id_user);\n		SET r_valor_base = 0, r_valor = 0, r_valor_patronal = 0, r_valor_maternidade = 0, r_desconto = 0, r_prazo = 1, r_prazot = 1;\n		INSERT INTO fin_rubricas(\n			id,slug,`status`,dominio,evento,created_at,updated_at,\n			id_cad_servidores,id_fin_eventos,ano,mes,parcela,\n			referencia,valor_base,valor,valor_patronal,\n			valor_maternidade,prazo,prazot,desconto,percentual\n		) VALUES (\n			r_id_fin_rubricas,r_slug,10,v_dominio,r_id_evento,UNIX_TIMESTAMP(NOW()),UNIX_TIMESTAMP(NOW()),\n			r_id_cad_servidores,r_id_fin_eventos,v_ano,v_mes,v_parcela,\n			r_referencia,r_valor_base,r_valor,r_valor_patronal,\n			r_valor_maternidade,r_prazo,r_prazot,r_desconto,r_percentual\n		);\n	END LOOP;\n	CLOSE cur1Referencias;\nEND','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_tapera','fin_folha_ev_basico','PROCEDURE','fin_folha_ev_basico','SQL','CONTAINS_SQL','NO','DEFINER','v_id_user VARCHAR(255),v_dominio VARCHAR(255),v_ano VARCHAR(4),v_mes VARCHAR(2),\nv_parcela VARCHAR(3),v_id_cad_servidor VARCHAR(255)','','BEGIN\n DECLARE r_valor, v_valor DECIMAL(11,2);\n DECLARE v_referencia, v_anos, v_meses, v_dias CHAR(2);\n DECLARE v_i_ano_inicial, v_i_ano_final CHAR(3);\n DECLARE v_id_pccs, v_id_vinculo, v_dias_mes, v_dias_trabalhados, r_id_evento, r_id_fin_eventos, r_id_fin_rubricas INT;\n DECLARE v_d_admissao DATE; \n DECLARE done INT DEFAULT FALSE; \n DECLARE exec INT DEFAULT TRUE;  \n -- obter referências\n DECLARE cur1Referencias CURSOR FOR  \n	SELECT fin_referencias.valor, cad_classes.i_ano_inicial, cad_classes.i_ano_final \n		FROM fin_referencias \n		JOIN cad_pccs ON cad_pccs.dominio = fin_referencias.dominio \n			AND cad_pccs.id_pccs = fin_referencias.id_pccs \n		JOIN cad_classes ON cad_classes.dominio = fin_referencias.dominio \n			AND cad_classes.id_pccs = cad_pccs.id_pccs \n			AND cad_classes.id_classe = fin_referencias.id_classe \n		WHERE (cad_pccs.dominio=v_dominio) AND (fin_referencias.id_pccs=v_id_pccs) \n			AND (STR_TO_DATE(fin_referencias.data, \'%d/%m/%Y\') <= LAST_DAY(CONCAT(v_ano, \'-\', v_mes, \'-1\'))) \n			AND CAST(v_anos AS UNSIGNED) BETWEEN CAST(cad_classes.i_ano_inicial AS UNSIGNED) AND CAST(cad_classes.i_ano_final AS UNSIGNED)\n		ORDER BY fin_referencias.id_classe DESC, fin_referencias.referencia DESC\n		LIMIT 100000;\n DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;\n \n SET v_dias_mes = DATE_FORMAT(LAST_DAY(CONCAT(v_ano, \'-\', v_mes, \'-1\')), \'%d\');\n SET v_dias_trabalhados = getDiasPagarVctoBasico(v_id_cad_servidor,v_ano,v_mes);\n SET v_referencia = v_dias_trabalhados;\n SET r_valor = 0;\n -- Registra valor para: v_id_pccs, v_d_admissao, v_anos, v_meses, v_dias \n SELECT fin_sfuncional.id_pccs,cad_sfuncional.id_vinculo,\n	/*CONCAT(SUBSTR(cad_servidores.d_admissao, 7),\'-\',SUBSTR(cad_servidores.d_admissao, 4,2),\'-\',SUBSTR(cad_servidores.d_admissao, 1,2))*/\n	STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\')data_adm,\n	TIMESTAMPDIFF(YEAR, STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\'), LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) AS anos,\n	TIMESTAMPDIFF(MONTH, STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\') + INTERVAL TIMESTAMPDIFF(YEAR,  STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\'), LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) YEAR , LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) AS meses,\n	TIMESTAMPDIFF(DAY, STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\') + INTERVAL TIMESTAMPDIFF(MONTH,  STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\'), LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) MONTH , LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) + 1 AS dias\n	INTO v_id_pccs, v_id_vinculo, v_d_admissao, v_anos, v_meses, v_dias\n	FROM cad_sfuncional\n	JOIN cad_servidores ON cad_sfuncional.id_cad_servidores = cad_servidores.id\n	JOIN fin_sfuncional ON cad_sfuncional.id_cad_servidores = fin_sfuncional.id_cad_servidores AND \n	cad_sfuncional.ano = fin_sfuncional.ano AND cad_sfuncional.mes = fin_sfuncional.mes AND\n	cad_sfuncional.parcela = fin_sfuncional.parcela\n	WHERE fin_sfuncional.ano = v_ano AND fin_sfuncional.mes = v_mes AND fin_sfuncional.parcela = v_parcela \n	AND fin_sfuncional.id_cad_servidores = v_id_cad_servidor;\n	-- Varre as referencias para localizar a correta e registrar o valor\n	OPEN cur1Referencias;\n	read_loop: LOOP\n		FETCH cur1Referencias INTO v_valor, v_i_ano_inicial, v_i_ano_final;\n		IF done THEN\n			LEAVE read_loop;\n		END IF;\n		IF !(v_anos = v_i_ano_final && (v_meses != 0 || v_dias != 0)) THEN\n			SET r_valor = ((v_valor / v_dias_mes) * v_dias_trabalhados);\n			IF v_i_ano_final != 0 AND v_i_ano_inicial != 99 THEN\n				SET done = TRUE;\n			ELSE \n				SET done = FALSE;\n			END IF;\n		END IF;\n	END LOOP;\n	CLOSE cur1Referencias;\n	\n SET r_id_fin_eventos = getidvinculo(v_dominio,v_id_vinculo);\n \n IF v_dias_trabalhados > 0 THEN\n	SET exec = TRUE;\n ELSE\n	SET exec = FALSE;\n END IF;\n \nIF exec = TRUE THEN\n	-- Retorna e armazena o último id da tabela fiin_rubricas\n	SET r_id_fin_rubricas = (SELECT MAX(id) FROM fin_rubricas) + 1;\n	/*para garantir a integridade da chave primária, efetua uma segunda verificação e geração de r_id_fin_rubricas, se necessário*/	\n	IF (SELECT id FROM fin_rubricas WHERE id = r_id_fin_rubricas) IS NOT NULL THEN\n		SET r_id_fin_rubricas = r_id_fin_rubricas + 1;\n	END IF;	\n	SET r_id_evento = getEventoSistema(v_dominio,CONCAT(\'Inclusão da rúbrica id: \', r_id_fin_eventos),\'actionC\', \'fin_rubricas\', r_id_fin_rubricas, v_id_user);\n	-- Insere a rúbrica\n	INSERT INTO fin_rubricas (id,slug,STATUS,dominio,evento,created_at,updated_at,\n		id_cad_servidores,id_fin_eventos,\n		ano,mes,parcela,referencia,valor_base,valor,valor_patronal,valor_maternidade,prazo,prazot,desconto,percentual) \n	VALUES(\n		r_id_fin_rubricas,SHA(CONCAT(NOW(),v_dominio,v_id_cad_servidor)),10,v_dominio,r_id_evento,UNIX_TIMESTAMP(NOW()),UNIX_TIMESTAMP(NOW()),\n		v_id_cad_servidor,r_id_fin_eventos,\n		v_ano,v_mes,v_parcela,v_referencia,0.00,r_valor,0.00,0.00,1,1,0.00,100.00\n	);\n END IF; \n /*\nSELECT v_dias_trabalhados, v_id_pccs, r_id_fin_eventos, v_d_admissao, v_anos, v_meses, v_dias, r_valor, exec, v_dias_mes;\n */\nEND','root@localhost','2019-06-13 10:02:55','2019-06-13 10:02:55','NO_AUTO_VALUE_ON_ZERO','','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN\n DECLARE r_valor, v_valor DECIMAL(11,2);\n DECLARE v_referencia, v_anos, v_meses, v_dias CHAR(2);\n DECLARE v_i_ano_inicial, v_i_ano_final CHAR(3);\n DECLARE v_id_pccs, v_id_vinculo, v_dias_mes, v_dias_trabalhados, r_id_evento, r_id_fin_eventos, r_id_fin_rubricas INT;\n DECLARE v_d_admissao DATE; \n DECLARE done INT DEFAULT FALSE; \n DECLARE exec INT DEFAULT TRUE;  \n -- obter referências\n DECLARE cur1Referencias CURSOR FOR  \n	SELECT fin_referencias.valor, cad_classes.i_ano_inicial, cad_classes.i_ano_final \n		FROM fin_referencias \n		JOIN cad_pccs ON cad_pccs.dominio = fin_referencias.dominio \n			AND cad_pccs.id_pccs = fin_referencias.id_pccs \n		JOIN cad_classes ON cad_classes.dominio = fin_referencias.dominio \n			AND cad_classes.id_pccs = cad_pccs.id_pccs \n			AND cad_classes.id_classe = fin_referencias.id_classe \n		WHERE (cad_pccs.dominio=v_dominio) AND (fin_referencias.id_pccs=v_id_pccs) \n			AND (STR_TO_DATE(fin_referencias.data, \'%d/%m/%Y\') <= LAST_DAY(CONCAT(v_ano, \'-\', v_mes, \'-1\'))) \n			AND CAST(v_anos AS UNSIGNED) BETWEEN CAST(cad_classes.i_ano_inicial AS UNSIGNED) AND CAST(cad_classes.i_ano_final AS UNSIGNED)\n		ORDER BY fin_referencias.id_classe DESC, fin_referencias.referencia DESC\n		LIMIT 100000;\n DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;\n \n SET v_dias_mes = DATE_FORMAT(LAST_DAY(CONCAT(v_ano, \'-\', v_mes, \'-1\')), \'%d\');\n SET v_dias_trabalhados = getDiasPagarVctoBasico(v_id_cad_servidor,v_ano,v_mes);\n SET v_referencia = v_dias_trabalhados;\n SET r_valor = 0;\n -- Registra valor para: v_id_pccs, v_d_admissao, v_anos, v_meses, v_dias \n SELECT fin_sfuncional.id_pccs,cad_sfuncional.id_vinculo,\n	/*CONCAT(SUBSTR(cad_servidores.d_admissao, 7),\'-\',SUBSTR(cad_servidores.d_admissao, 4,2),\'-\',SUBSTR(cad_servidores.d_admissao, 1,2))*/\n	STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\')data_adm,\n	TIMESTAMPDIFF(YEAR, STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\'), LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) AS anos,\n	TIMESTAMPDIFF(MONTH, STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\') + INTERVAL TIMESTAMPDIFF(YEAR,  STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\'), LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) YEAR , LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) AS meses,\n	TIMESTAMPDIFF(DAY, STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\') + INTERVAL TIMESTAMPDIFF(MONTH,  STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\'), LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) MONTH , LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) + 1 AS dias\n	INTO v_id_pccs, v_id_vinculo, v_d_admissao, v_anos, v_meses, v_dias\n	FROM cad_sfuncional\n	JOIN cad_servidores ON cad_sfuncional.id_cad_servidores = cad_servidores.id\n	JOIN fin_sfuncional ON cad_sfuncional.id_cad_servidores = fin_sfuncional.id_cad_servidores AND \n	cad_sfuncional.ano = fin_sfuncional.ano AND cad_sfuncional.mes = fin_sfuncional.mes AND\n	cad_sfuncional.parcela = fin_sfuncional.parcela\n	WHERE fin_sfuncional.ano = v_ano AND fin_sfuncional.mes = v_mes AND fin_sfuncional.parcela = v_parcela \n	AND fin_sfuncional.id_cad_servidores = v_id_cad_servidor;\n	-- Varre as referencias para localizar a correta e registrar o valor\n	OPEN cur1Referencias;\n	read_loop: LOOP\n		FETCH cur1Referencias INTO v_valor, v_i_ano_inicial, v_i_ano_final;\n		IF done THEN\n			LEAVE read_loop;\n		END IF;\n		IF !(v_anos = v_i_ano_final && (v_meses != 0 || v_dias != 0)) THEN\n			SET r_valor = ((v_valor / v_dias_mes) * v_dias_trabalhados);\n			IF v_i_ano_final != 0 AND v_i_ano_inicial != 99 THEN\n				SET done = TRUE;\n			ELSE \n				SET done = FALSE;\n			END IF;\n		END IF;\n	END LOOP;\n	CLOSE cur1Referencias;\n	\n SET r_id_fin_eventos = getidvinculo(v_dominio,v_id_vinculo);\n \n IF v_dias_trabalhados > 0 THEN\n	SET exec = TRUE;\n ELSE\n	SET exec = FALSE;\n END IF;\n \nIF exec = TRUE THEN\n	-- Retorna e armazena o último id da tabela fiin_rubricas\n	SET r_id_fin_rubricas = (SELECT MAX(id) FROM fin_rubricas) + 1;\n	/*para garantir a integridade da chave primária, efetua uma segunda verificação e geração de r_id_fin_rubricas, se necessário*/	\n	IF (SELECT id FROM fin_rubricas WHERE id = r_id_fin_rubricas) IS NOT NULL THEN\n		SET r_id_fin_rubricas = r_id_fin_rubricas + 1;\n	END IF;	\n	SET r_id_evento = getEventoSistema(v_dominio,CONCAT(\'Inclusão da rúbrica id: \', r_id_fin_eventos),\'actionC\', \'fin_rubricas\', r_id_fin_rubricas, v_id_user);\n	-- Insere a rúbrica\n	INSERT INTO fin_rubricas (id,slug,STATUS,dominio,evento,created_at,updated_at,\n		id_cad_servidores,id_fin_eventos,\n		ano,mes,parcela,referencia,valor_base,valor,valor_patronal,valor_maternidade,prazo,prazot,desconto,percentual) \n	VALUES(\n		r_id_fin_rubricas,SHA(CONCAT(NOW(),v_dominio,v_id_cad_servidor)),10,v_dominio,r_id_evento,UNIX_TIMESTAMP(NOW()),UNIX_TIMESTAMP(NOW()),\n		v_id_cad_servidor,r_id_fin_eventos,\n		v_ano,v_mes,v_parcela,v_referencia,0.00,r_valor,0.00,0.00,1,1,0.00,100.00\n	);\n END IF; \n /*\nSELECT v_dias_trabalhados, v_id_pccs, r_id_fin_eventos, v_d_admissao, v_anos, v_meses, v_dias, r_valor, exec, v_dias_mes;\n */\nEND','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('mgfolha_tapera','get_vcto_basico','PROCEDURE','get_vcto_basico','SQL','CONTAINS_SQL','NO','DEFINER','v_dominio VARCHAR(255),v_ano VARCHAR(4),v_mes VARCHAR(2),\nv_parcela VARCHAR(3),v_id_cad_servidor VARCHAR(255)','','BEGIN\n	DECLARE r_valor, v_valor DECIMAL(11,2);\n	DECLARE v_referencia, v_anos, v_meses, v_dias, v_i_ano_inicial, v_i_ano_final CHAR(2);\n	DECLARE v_id_referencia, v_id_pccs, v_id_vinculo, v_dias_mes, v_dias_trabalhados INT;\n	DECLARE v_d_admissao DATE; \n	DECLARE done INT DEFAULT FALSE; \n	DECLARE exec INT DEFAULT TRUE;  \n	-- obter referências\n	DECLARE cur1Referencias CURSOR FOR  \n	SELECT fin_referencias.id,/*MAX*/(fin_referencias.valor)valor, cad_classes.i_ano_inicial, cad_classes.i_ano_final \n		FROM fin_referencias \n		JOIN cad_pccs ON cad_pccs.dominio = fin_referencias.dominio \n			AND cad_pccs.id_pccs = fin_referencias.id_pccs \n		JOIN cad_classes ON cad_classes.dominio = fin_referencias.dominio \n			AND cad_classes.id_pccs = cad_pccs.id_pccs \n			AND cad_classes.id_classe = fin_referencias.id_classe \n		WHERE (cad_pccs.dominio=v_dominio) AND (fin_referencias.id_pccs=v_id_pccs) \n			AND (STR_TO_DATE(fin_referencias.data, \'%d/%m/%Y\') <= LAST_DAY(CONCAT(v_ano, \'-\', v_mes, \'-1\'))) \n			AND v_anos BETWEEN CAST(cad_classes.i_ano_inicial AS UNSIGNED) AND CAST(cad_classes.i_ano_final AS UNSIGNED)\n		-- GROUP BY cad_classes.i_ano_inicial, cad_classes.i_ano_final\n		ORDER BY fin_referencias.id_classe DESC, fin_referencias.referencia DESC\n		LIMIT 100000;\n	DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;\n	SET v_dias_mes = DATE_FORMAT(LAST_DAY(CONCAT(v_ano, \'-\', v_mes, \'-1\')), \'%d\');\n	SET v_dias_trabalhados = getDiasPagarVctoBasico(v_id_cad_servidor,v_ano,v_mes);\n	SET v_referencia = v_dias_trabalhados;\n	SET r_valor = 0;\n	-- Registra valor para: v_id_pccs, v_d_admissao, v_anos, v_meses, v_dias \n	SELECT fin_sfuncional.id_pccs,cad_sfuncional.id_vinculo,\n		/*CONCAT(SUBSTR(cad_servidores.d_admissao, 7),\'-\',SUBSTR(cad_servidores.d_admissao, 4,2),\'-\',SUBSTR(cad_servidores.d_admissao, 1,2))*/\n		STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\')data_adm,\n		TIMESTAMPDIFF(YEAR, STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\'), LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) AS anos,\n		TIMESTAMPDIFF(MONTH, STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\') + INTERVAL TIMESTAMPDIFF(YEAR,  STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\'), LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) YEAR , LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) AS meses,\n		TIMESTAMPDIFF(DAY, STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\') + INTERVAL TIMESTAMPDIFF(MONTH,  STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\'), LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) MONTH , LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) + 1 AS dias\n		INTO v_id_pccs, v_id_vinculo, v_d_admissao, v_anos, v_meses, v_dias\n		FROM cad_sfuncional\n		JOIN cad_servidores ON cad_sfuncional.id_cad_servidores = cad_servidores.id\n		JOIN fin_sfuncional ON cad_sfuncional.id_cad_servidores = fin_sfuncional.id_cad_servidores AND \n		cad_sfuncional.ano = fin_sfuncional.ano AND cad_sfuncional.mes = fin_sfuncional.mes AND\n		cad_sfuncional.parcela = fin_sfuncional.parcela\n		WHERE fin_sfuncional.ano = v_ano AND fin_sfuncional.mes = v_mes AND fin_sfuncional.parcela = v_parcela \n		AND fin_sfuncional.id_cad_servidores = v_id_cad_servidor;\n	-- Varre as referencias para localizar a correta e registrar o valor\n	OPEN cur1Referencias;\n	read_loop: LOOP\n		FETCH cur1Referencias INTO v_id_referencia, v_valor, v_i_ano_inicial, v_i_ano_final;\n		IF done THEN\n			LEAVE read_loop;\n		END IF;\n		IF !(v_anos = v_i_ano_final && (v_meses != 0 || v_dias != 0)) THEN\n			SET r_valor = ((v_valor / v_dias_mes) * v_dias_trabalhados);\n			IF v_i_ano_final != 0 AND v_i_ano_inicial != 99 THEN\n				SET done = TRUE;\n			ELSE \n				SET done = FALSE;\n			END IF;\n		END IF;\n	END LOOP;\n	CLOSE cur1Referencias;\n	-- armazena o id_fin_eventos baseado em cad_sfuncional.id_vinculo\n	IF (v_id_vinculo < 4) THEN\n		SET v_id_vinculo = (SELECT id FROM fin_eventos WHERE dominio = v_dominio AND id_evento = \'001\');\n	ELSEIF (v_id_vinculo BETWEEN 4 AND 5) THEN\n		SET v_id_vinculo = (SELECT id FROM fin_eventos WHERE dominio = v_dominio AND id_evento = \'003\');\n	ELSEIF (v_id_vinculo = 6) THEN \n		SET v_id_vinculo = (SELECT id FROM fin_eventos WHERE dominio = v_dominio AND id_evento = \'002\');\n	END IF;\n	SELECT v_id_referencia, v_dias_trabalhados, v_id_pccs, v_id_vinculo, v_d_admissao, v_anos, v_meses, v_dias, r_valor, exec, v_dias_mes;\nEND','root@localhost','2019-06-13 10:02:55','2019-06-13 10:02:55','NO_AUTO_VALUE_ON_ZERO','','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN\n	DECLARE r_valor, v_valor DECIMAL(11,2);\n	DECLARE v_referencia, v_anos, v_meses, v_dias, v_i_ano_inicial, v_i_ano_final CHAR(2);\n	DECLARE v_id_referencia, v_id_pccs, v_id_vinculo, v_dias_mes, v_dias_trabalhados INT;\n	DECLARE v_d_admissao DATE; \n	DECLARE done INT DEFAULT FALSE; \n	DECLARE exec INT DEFAULT TRUE;  \n	-- obter referências\n	DECLARE cur1Referencias CURSOR FOR  \n	SELECT fin_referencias.id,/*MAX*/(fin_referencias.valor)valor, cad_classes.i_ano_inicial, cad_classes.i_ano_final \n		FROM fin_referencias \n		JOIN cad_pccs ON cad_pccs.dominio = fin_referencias.dominio \n			AND cad_pccs.id_pccs = fin_referencias.id_pccs \n		JOIN cad_classes ON cad_classes.dominio = fin_referencias.dominio \n			AND cad_classes.id_pccs = cad_pccs.id_pccs \n			AND cad_classes.id_classe = fin_referencias.id_classe \n		WHERE (cad_pccs.dominio=v_dominio) AND (fin_referencias.id_pccs=v_id_pccs) \n			AND (STR_TO_DATE(fin_referencias.data, \'%d/%m/%Y\') <= LAST_DAY(CONCAT(v_ano, \'-\', v_mes, \'-1\'))) \n			AND v_anos BETWEEN CAST(cad_classes.i_ano_inicial AS UNSIGNED) AND CAST(cad_classes.i_ano_final AS UNSIGNED)\n		-- GROUP BY cad_classes.i_ano_inicial, cad_classes.i_ano_final\n		ORDER BY fin_referencias.id_classe DESC, fin_referencias.referencia DESC\n		LIMIT 100000;\n	DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;\n	SET v_dias_mes = DATE_FORMAT(LAST_DAY(CONCAT(v_ano, \'-\', v_mes, \'-1\')), \'%d\');\n	SET v_dias_trabalhados = getDiasPagarVctoBasico(v_id_cad_servidor,v_ano,v_mes);\n	SET v_referencia = v_dias_trabalhados;\n	SET r_valor = 0;\n	-- Registra valor para: v_id_pccs, v_d_admissao, v_anos, v_meses, v_dias \n	SELECT fin_sfuncional.id_pccs,cad_sfuncional.id_vinculo,\n		/*CONCAT(SUBSTR(cad_servidores.d_admissao, 7),\'-\',SUBSTR(cad_servidores.d_admissao, 4,2),\'-\',SUBSTR(cad_servidores.d_admissao, 1,2))*/\n		STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\')data_adm,\n		TIMESTAMPDIFF(YEAR, STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\'), LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) AS anos,\n		TIMESTAMPDIFF(MONTH, STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\') + INTERVAL TIMESTAMPDIFF(YEAR,  STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\'), LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) YEAR , LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) AS meses,\n		TIMESTAMPDIFF(DAY, STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\') + INTERVAL TIMESTAMPDIFF(MONTH,  STR_TO_DATE(cad_servidores.d_admissao, \'%d/%m/%Y\'), LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) MONTH , LAST_DAY(CONCAT(fin_sfuncional.ano, \'-\', fin_sfuncional.mes,\'-1\'))) + 1 AS dias\n		INTO v_id_pccs, v_id_vinculo, v_d_admissao, v_anos, v_meses, v_dias\n		FROM cad_sfuncional\n		JOIN cad_servidores ON cad_sfuncional.id_cad_servidores = cad_servidores.id\n		JOIN fin_sfuncional ON cad_sfuncional.id_cad_servidores = fin_sfuncional.id_cad_servidores AND \n		cad_sfuncional.ano = fin_sfuncional.ano AND cad_sfuncional.mes = fin_sfuncional.mes AND\n		cad_sfuncional.parcela = fin_sfuncional.parcela\n		WHERE fin_sfuncional.ano = v_ano AND fin_sfuncional.mes = v_mes AND fin_sfuncional.parcela = v_parcela \n		AND fin_sfuncional.id_cad_servidores = v_id_cad_servidor;\n	-- Varre as referencias para localizar a correta e registrar o valor\n	OPEN cur1Referencias;\n	read_loop: LOOP\n		FETCH cur1Referencias INTO v_id_referencia, v_valor, v_i_ano_inicial, v_i_ano_final;\n		IF done THEN\n			LEAVE read_loop;\n		END IF;\n		IF !(v_anos = v_i_ano_final && (v_meses != 0 || v_dias != 0)) THEN\n			SET r_valor = ((v_valor / v_dias_mes) * v_dias_trabalhados);\n			IF v_i_ano_final != 0 AND v_i_ano_inicial != 99 THEN\n				SET done = TRUE;\n			ELSE \n				SET done = FALSE;\n			END IF;\n		END IF;\n	END LOOP;\n	CLOSE cur1Referencias;\n	-- armazena o id_fin_eventos baseado em cad_sfuncional.id_vinculo\n	IF (v_id_vinculo < 4) THEN\n		SET v_id_vinculo = (SELECT id FROM fin_eventos WHERE dominio = v_dominio AND id_evento = \'001\');\n	ELSEIF (v_id_vinculo BETWEEN 4 AND 5) THEN\n		SET v_id_vinculo = (SELECT id FROM fin_eventos WHERE dominio = v_dominio AND id_evento = \'003\');\n	ELSEIF (v_id_vinculo = 6) THEN \n		SET v_id_vinculo = (SELECT id FROM fin_eventos WHERE dominio = v_dominio AND id_evento = \'002\');\n	END IF;\n	SELECT v_id_referencia, v_dias_trabalhados, v_id_pccs, v_id_vinculo, v_d_admissao, v_anos, v_meses, v_dias, r_valor, exec, v_dias_mes;\nEND','NONE');
insert  into `proc`(`db`,`name`,`type`,`specific_name`,`language`,`sql_data_access`,`is_deterministic`,`security_type`,`param_list`,`returns`,`body`,`definer`,`created`,`modified`,`sql_mode`,`comment`,`character_set_client`,`collation_connection`,`db_collation`,`body_utf8`,`aggregate`) values ('sjdatape_ouvidoria','getNextProtocol','FUNCTION','getNextProtocol','SQL','CONTAINS_SQL','NO','DEFINER','unix INT','varchar(20) CHARSET latin1','BEGIN\n	DECLARE quant INT;\n	DECLARE ano, mes VARCHAR(4);\n	\n	SELECT DATE_FORMAT(FROM_UNIXTIME(unix), \'%Y\'), DATE_FORMAT(FROM_UNIXTIME(unix), \'%m\') INTO ano, mes;\n	\n	SELECT COUNT(*) INTO quant FROM objetos WHERE DATE_FORMAT(FROM_UNIXTIME(created_at), \'%Y%m\') = CONCAT(ano,mes);\n		\n	RETURN CONCAT(ano, mes, LPAD(quant + 1,4,\'0\'));\n    END','root@localhost','2019-10-07 12:03:42','2019-10-07 12:03:42','NO_ZERO_IN_DATE,NO_ZERO_DATE,NO_ENGINE_SUBSTITUTION','Retorna o número do próximo protocolo baseado no mês de geração do registro','utf8','utf8_general_ci','latin1_swedish_ci','BEGIN\n	DECLARE quant INT;\n	DECLARE ano, mes VARCHAR(4);\n	\n	SELECT DATE_FORMAT(FROM_UNIXTIME(unix), \'%Y\'), DATE_FORMAT(FROM_UNIXTIME(unix), \'%m\') INTO ano, mes;\n	\n	SELECT COUNT(*) INTO quant FROM objetos WHERE DATE_FORMAT(FROM_UNIXTIME(created_at), \'%Y%m\') = CONCAT(ano,mes);\n		\n	RETURN CONCAT(ano, mes, LPAD(quant + 1,4,\'0\'));\n    END','NONE');

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
